"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@connectrpc";
exports.ids = ["vendor-chunks/@connectrpc"];
exports.modules = {

/***/ "(ssr)/./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertFetchApi: () => (/* binding */ assertFetchApi)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Asserts that the fetch API is available.\n */\nfunction assertFetchApi() {\n    try {\n        new Headers();\n    }\n    catch (_) {\n        throw new Error(\"connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC13ZWIvZGlzdC9lc20vYXNzZXJ0LWZldGNoLWFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY28vZXRob3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC13ZWIvZGlzdC9lc20vYXNzZXJ0LWZldGNoLWFwaS5qcz83NWM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZmV0Y2ggQVBJIGlzIGF2YWlsYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZldGNoQXBpKCkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBIZWFkZXJzKCk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbm5lY3Qtd2ViIHJlcXVpcmVzIHRoZSBmZXRjaCBBUEkuIEFyZSB5b3UgcnVubmluZyBvbiBhbiBvbGQgdmVyc2lvbiBvZiBOb2RlLmpzPyBOb2RlLmpzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gQ29ubmVjdCBmb3IgV2ViIC0gcGxlYXNlIHN0YXkgdHVuZWQgZm9yIENvbm5lY3QgZm9yIE5vZGUuXCIpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createConnectTransport: () => (/* binding */ createConnectTransport)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(ssr)/./node_modules/@bufbuild/protobuf/dist/esm/service-type.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @connectrpc/connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/context-values.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @connectrpc/connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/http-headers.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @connectrpc/connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _connectrpc_connect__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @connectrpc/connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js\");\n/* harmony import */ var _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @connectrpc/connect/protocol */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/request-header.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/get-request.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/validate-response.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js\");\n/* harmony import */ var _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @connectrpc/connect/protocol-connect */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/end-stream.js\");\n/* harmony import */ var _assert_fetch_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert-fetch-api.js */ \"(ssr)/./node_modules/@connectrpc/connect-web/dist/esm/assert-fetch-api.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n/**\n * Create a Transport for the Connect protocol, which makes unary and\n * server-streaming methods available to web browsers. It uses the fetch\n * API to make HTTP requests.\n */\nfunction createConnectTransport(options) {\n    var _a;\n    (0,_assert_fetch_api_js__WEBPACK_IMPORTED_MODULE_0__.assertFetchApi)();\n    const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : false;\n    return {\n        async unary(service, method, signal, timeoutMs, header, message, contextValues) {\n            var _a;\n            const { serialize, parse } = (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_1__.createClientMethodSerializers)(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_2__.runUnaryCall)({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service,\n                    method,\n                    url: (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_3__.createMethodUrl)(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_4__.requestHeader)(method.kind, useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_5__.createContextValues)(),\n                    message,\n                },\n                next: async (req) => {\n                    var _a;\n                    const useGet = options.useHttpGet === true &&\n                        method.idempotency === _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_6__.MethodIdempotency.NoSideEffects;\n                    let body = null;\n                    if (useGet) {\n                        req = (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_7__.transformConnectPostToGetRequest)(req, serialize(req.message), useBinaryFormat);\n                    }\n                    else {\n                        body = serialize(req.message);\n                    }\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const response = await fetch(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body }));\n                    const { isUnaryError, unaryError } = (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_8__.validateResponse)(method.kind, useBinaryFormat, response.status, response.headers);\n                    if (isUnaryError) {\n                        throw (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_9__.errorFromJson)((await response.json()), (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_10__.appendHeaders)(...(0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_11__.trailerDemux)(response.headers)), unaryError);\n                    }\n                    const [demuxedHeader, demuxedTrailer] = (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_11__.trailerDemux)(response.headers);\n                    return {\n                        stream: false,\n                        service,\n                        method,\n                        header: demuxedHeader,\n                        message: useBinaryFormat\n                            ? parse(new Uint8Array(await response.arrayBuffer()))\n                            : method.O.fromJson((await response.json()), (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_1__.getJsonOptions)(options.jsonOptions)),\n                        trailer: demuxedTrailer,\n                    };\n                },\n            });\n        },\n        async stream(service, method, signal, timeoutMs, header, input, contextValues) {\n            var _a;\n            const { serialize, parse } = (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_1__.createClientMethodSerializers)(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            function parseResponseBody(body, trailerTarget, header, signal) {\n                return __asyncGenerator(this, arguments, function* parseResponseBody_1() {\n                    const reader = (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_12__.createEnvelopeReadableStream)(body).getReader();\n                    let endStreamReceived = false;\n                    for (;;) {\n                        const result = yield __await(reader.read());\n                        if (result.done) {\n                            break;\n                        }\n                        const { flags, data } = result.value;\n                        if ((flags & _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_13__.compressedFlag) === _connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_13__.compressedFlag) {\n                            throw new _connectrpc_connect__WEBPACK_IMPORTED_MODULE_14__.ConnectError(`protocol error: received unsupported compressed output`, _connectrpc_connect__WEBPACK_IMPORTED_MODULE_15__.Code.Internal);\n                        }\n                        if ((flags & _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_16__.endStreamFlag) === _connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_16__.endStreamFlag) {\n                            endStreamReceived = true;\n                            const endStream = (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_16__.endStreamFromJson)(data);\n                            if (endStream.error) {\n                                const error = endStream.error;\n                                header.forEach((value, key) => {\n                                    error.metadata.append(key, value);\n                                });\n                                throw error;\n                            }\n                            endStream.metadata.forEach((value, key) => trailerTarget.set(key, value));\n                            continue;\n                        }\n                        yield yield __await(parse(data));\n                    }\n                    // Node wil not throw an AbortError on `read` if the\n                    // signal is aborted before `getReader` is called.\n                    // As a work around we check at the end and throw.\n                    //\n                    // Ref: https://github.com/nodejs/undici/issues/1940\n                    if (\"throwIfAborted\" in signal) {\n                        // We assume that implementations without `throwIfAborted` (old\n                        // browsers) do honor aborted signals on `read`.\n                        signal.throwIfAborted();\n                    }\n                    if (!endStreamReceived) {\n                        throw \"missing EndStreamResponse\";\n                    }\n                });\n            }\n            async function createRequestBody(input) {\n                if (method.kind != _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_6__.MethodKind.ServerStreaming) {\n                    throw \"The fetch API does not support streaming request bodies\";\n                }\n                const r = await input[Symbol.asyncIterator]().next();\n                if (r.done == true) {\n                    throw \"missing request message\";\n                }\n                return (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_12__.encodeEnvelope)(0, serialize(r.value));\n            }\n            timeoutMs =\n                timeoutMs === undefined\n                    ? options.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_2__.runStreamingCall)({\n                interceptors: options.interceptors,\n                timeoutMs,\n                signal,\n                req: {\n                    stream: true,\n                    service,\n                    method,\n                    url: (0,_connectrpc_connect_protocol__WEBPACK_IMPORTED_MODULE_3__.createMethodUrl)(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_4__.requestHeader)(method.kind, useBinaryFormat, timeoutMs, header, false),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : (0,_connectrpc_connect__WEBPACK_IMPORTED_MODULE_5__.createContextValues)(),\n                    message: input,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));\n                    (0,_connectrpc_connect_protocol_connect__WEBPACK_IMPORTED_MODULE_8__.validateResponse)(method.kind, useBinaryFormat, fRes.status, fRes.headers);\n                    if (fRes.body === null) {\n                        throw \"missing response body\";\n                    }\n                    const trailer = new Headers();\n                    const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, trailer, fRes.headers, req.signal) });\n                    return res;\n                },\n            });\n        },\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC13ZWIvZGlzdC9lc20vY29ubmVjdC10cmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJLDRCQUE0QjtBQUN2RCx3QkFBd0IsU0FBSSxJQUFJLFNBQUk7QUFDcEM7QUFDQTtBQUNBLGlCQUFpQixvR0FBb0csY0FBYztBQUNuSSw4QkFBOEIsc0JBQXNCO0FBQ3BELDBCQUEwQixZQUFZLHNCQUFzQixxQ0FBcUMsMkNBQTJDLE1BQU07QUFDbEosNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCO0FBQzRFO0FBQ2tCO0FBQytHO0FBQ3BCO0FBQ2xJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsSUFBSSxvRUFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUIsRUFBRSwyRkFBNkI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBFQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZFQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsNEJBQTRCLG1GQUFhO0FBQ3pDLHdHQUF3Ryx3RUFBbUI7QUFDM0g7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlFQUFpQjtBQUNoRTtBQUNBO0FBQ0EsOEJBQThCLHNHQUFnQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGVBQWUsK0NBQStDO0FBQ3RKLDRCQUE0QiwyQkFBMkIsRUFBRSxzRkFBZ0I7QUFDekU7QUFDQSw4QkFBOEIsbUZBQWEsMEJBQTBCLG1FQUFhLElBQUksbUZBQVk7QUFDbEc7QUFDQSw0REFBNEQsbUZBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsNEVBQWM7QUFDdkY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLEVBQUUsMkZBQTZCO0FBQ3RFO0FBQ0E7QUFDQSxtQ0FBbUMsMkZBQTRCO0FBQy9EO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUMscUNBQXFDLHlFQUFjLE1BQU0seUVBQWM7QUFDdkUsc0NBQXNDLDhEQUFZLDJEQUEyRCxzREFBSTtBQUNqSDtBQUNBLHFDQUFxQyxnRkFBYSxNQUFNLGdGQUFhO0FBQ3JFO0FBQ0EsOENBQThDLHdGQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUMsMERBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZFQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhFQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2RUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDRCQUE0QixtRkFBYTtBQUN6Qyx3R0FBd0csd0VBQW1CO0FBQzNIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixlQUFlLHFGQUFxRjtBQUN4TCxvQkFBb0Isc0ZBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVUseUdBQXlHO0FBQ2pMO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3Qtd2ViL2Rpc3QvZXNtL2Nvbm5lY3QtdHJhbnNwb3J0LmpzP2VhOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNHZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn07XG5pbXBvcnQgeyBNZXNzYWdlLCBNZXRob2RJZGVtcG90ZW5jeSwgTWV0aG9kS2luZCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IENvZGUsIENvbm5lY3RFcnJvciwgYXBwZW5kSGVhZGVycywgY3JlYXRlQ29udGV4dFZhbHVlcywgfSBmcm9tIFwiQGNvbm5lY3RycGMvY29ubmVjdFwiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50TWV0aG9kU2VyaWFsaXplcnMsIGNyZWF0ZUVudmVsb3BlUmVhZGFibGVTdHJlYW0sIGNyZWF0ZU1ldGhvZFVybCwgZ2V0SnNvbk9wdGlvbnMsIGVuY29kZUVudmVsb3BlLCBydW5TdHJlYW1pbmdDYWxsLCBydW5VbmFyeUNhbGwsIGNvbXByZXNzZWRGbGFnLCB9IGZyb20gXCJAY29ubmVjdHJwYy9jb25uZWN0L3Byb3RvY29sXCI7XG5pbXBvcnQgeyBlbmRTdHJlYW1GbGFnLCBlbmRTdHJlYW1Gcm9tSnNvbiwgZXJyb3JGcm9tSnNvbiwgcmVxdWVzdEhlYWRlciwgdHJhaWxlckRlbXV4LCB0cmFuc2Zvcm1Db25uZWN0UG9zdFRvR2V0UmVxdWVzdCwgdmFsaWRhdGVSZXNwb25zZSwgfSBmcm9tIFwiQGNvbm5lY3RycGMvY29ubmVjdC9wcm90b2NvbC1jb25uZWN0XCI7XG5pbXBvcnQgeyBhc3NlcnRGZXRjaEFwaSB9IGZyb20gXCIuL2Fzc2VydC1mZXRjaC1hcGkuanNcIjtcbi8qKlxuICogQ3JlYXRlIGEgVHJhbnNwb3J0IGZvciB0aGUgQ29ubmVjdCBwcm90b2NvbCwgd2hpY2ggbWFrZXMgdW5hcnkgYW5kXG4gKiBzZXJ2ZXItc3RyZWFtaW5nIG1ldGhvZHMgYXZhaWxhYmxlIHRvIHdlYiBicm93c2Vycy4gSXQgdXNlcyB0aGUgZmV0Y2hcbiAqIEFQSSB0byBtYWtlIEhUVFAgcmVxdWVzdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25uZWN0VHJhbnNwb3J0KG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgYXNzZXJ0RmV0Y2hBcGkoKTtcbiAgICBjb25zdCB1c2VCaW5hcnlGb3JtYXQgPSAoX2EgPSBvcHRpb25zLnVzZUJpbmFyeUZvcm1hdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgdW5hcnkoc2VydmljZSwgbWV0aG9kLCBzaWduYWwsIHRpbWVvdXRNcywgaGVhZGVyLCBtZXNzYWdlLCBjb250ZXh0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IHNlcmlhbGl6ZSwgcGFyc2UgfSA9IGNyZWF0ZUNsaWVudE1ldGhvZFNlcmlhbGl6ZXJzKG1ldGhvZCwgdXNlQmluYXJ5Rm9ybWF0LCBvcHRpb25zLmpzb25PcHRpb25zLCBvcHRpb25zLmJpbmFyeU9wdGlvbnMpO1xuICAgICAgICAgICAgdGltZW91dE1zID1cbiAgICAgICAgICAgICAgICB0aW1lb3V0TXMgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZGVmYXVsdFRpbWVvdXRNc1xuICAgICAgICAgICAgICAgICAgICA6IHRpbWVvdXRNcyA8PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aW1lb3V0TXM7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcnVuVW5hcnlDYWxsKHtcbiAgICAgICAgICAgICAgICBpbnRlcmNlcHRvcnM6IG9wdGlvbnMuaW50ZXJjZXB0b3JzLFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0TXMsXG4gICAgICAgICAgICAgICAgcmVxOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjcmVhdGVNZXRob2RVcmwob3B0aW9ucy5iYXNlVXJsLCBzZXJ2aWNlLCBtZXRob2QpLFxuICAgICAgICAgICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0OiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiByZXF1ZXN0SGVhZGVyKG1ldGhvZC5raW5kLCB1c2VCaW5hcnlGb3JtYXQsIHRpbWVvdXRNcywgaGVhZGVyLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRWYWx1ZXM6IGNvbnRleHRWYWx1ZXMgIT09IG51bGwgJiYgY29udGV4dFZhbHVlcyAhPT0gdm9pZCAwID8gY29udGV4dFZhbHVlcyA6IGNyZWF0ZUNvbnRleHRWYWx1ZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5leHQ6IGFzeW5jIChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VHZXQgPSBvcHRpb25zLnVzZUh0dHBHZXQgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZC5pZGVtcG90ZW5jeSA9PT0gTWV0aG9kSWRlbXBvdGVuY3kuTm9TaWRlRWZmZWN0cztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEgPSB0cmFuc2Zvcm1Db25uZWN0UG9zdFRvR2V0UmVxdWVzdChyZXEsIHNlcmlhbGl6ZShyZXEubWVzc2FnZSksIHVzZUJpbmFyeUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gc2VyaWFsaXplKHJlcS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaCA9IChfYSA9IG9wdGlvbnMuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxLnVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXEuaW5pdCksIHsgaGVhZGVyczogcmVxLmhlYWRlciwgc2lnbmFsOiByZXEuc2lnbmFsLCBib2R5IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpc1VuYXJ5RXJyb3IsIHVuYXJ5RXJyb3IgfSA9IHZhbGlkYXRlUmVzcG9uc2UobWV0aG9kLmtpbmQsIHVzZUJpbmFyeUZvcm1hdCwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5hcnlFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JGcm9tSnNvbigoYXdhaXQgcmVzcG9uc2UuanNvbigpKSwgYXBwZW5kSGVhZGVycyguLi50cmFpbGVyRGVtdXgocmVzcG9uc2UuaGVhZGVycykpLCB1bmFyeUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZGVtdXhlZEhlYWRlciwgZGVtdXhlZFRyYWlsZXJdID0gdHJhaWxlckRlbXV4KHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGRlbXV4ZWRIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB1c2VCaW5hcnlGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlKG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbWV0aG9kLk8uZnJvbUpzb24oKGF3YWl0IHJlc3BvbnNlLmpzb24oKSksIGdldEpzb25PcHRpb25zKG9wdGlvbnMuanNvbk9wdGlvbnMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsZXI6IGRlbXV4ZWRUcmFpbGVyLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc3RyZWFtKHNlcnZpY2UsIG1ldGhvZCwgc2lnbmFsLCB0aW1lb3V0TXMsIGhlYWRlciwgaW5wdXQsIGNvbnRleHRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWFsaXplLCBwYXJzZSB9ID0gY3JlYXRlQ2xpZW50TWV0aG9kU2VyaWFsaXplcnMobWV0aG9kLCB1c2VCaW5hcnlGb3JtYXQsIG9wdGlvbnMuanNvbk9wdGlvbnMsIG9wdGlvbnMuYmluYXJ5T3B0aW9ucyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlQm9keShib2R5LCB0cmFpbGVyVGFyZ2V0LCBoZWFkZXIsIHNpZ25hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHBhcnNlUmVzcG9uc2VCb2R5XzEoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IGNyZWF0ZUVudmVsb3BlUmVhZGFibGVTdHJlYW0oYm9keSkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRTdHJlYW1SZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBfX2F3YWl0KHJlYWRlci5yZWFkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsYWdzLCBkYXRhIH0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgY29tcHJlc3NlZEZsYWcpID09PSBjb21wcmVzc2VkRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHByb3RvY29sIGVycm9yOiByZWNlaXZlZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIG91dHB1dGAsIENvZGUuSW50ZXJuYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIGVuZFN0cmVhbUZsYWcpID09PSBlbmRTdHJlYW1GbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3RyZWFtUmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFN0cmVhbSA9IGVuZFN0cmVhbUZyb21Kc29uKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRTdHJlYW0uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlbmRTdHJlYW0uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXRhZGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3RyZWFtLm1ldGFkYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRyYWlsZXJUYXJnZXQuc2V0KGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocGFyc2UoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUgd2lsIG5vdCB0aHJvdyBhbiBBYm9ydEVycm9yIG9uIGByZWFkYCBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2lnbmFsIGlzIGFib3J0ZWQgYmVmb3JlIGBnZXRSZWFkZXJgIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXMgYSB3b3JrIGFyb3VuZCB3ZSBjaGVjayBhdCB0aGUgZW5kIGFuZCB0aHJvdy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTk0MFxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0aHJvd0lmQWJvcnRlZFwiIGluIHNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgaW1wbGVtZW50YXRpb25zIHdpdGhvdXQgYHRocm93SWZBYm9ydGVkYCAob2xkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycykgZG8gaG9ub3IgYWJvcnRlZCBzaWduYWxzIG9uIGByZWFkYC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5kU3RyZWFtUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwibWlzc2luZyBFbmRTdHJlYW1SZXNwb25zZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYyBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0Qm9keShpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2Qua2luZCAhPSBNZXRob2RLaW5kLlNlcnZlclN0cmVhbWluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlRoZSBmZXRjaCBBUEkgZG9lcyBub3Qgc3VwcG9ydCBzdHJlYW1pbmcgcmVxdWVzdCBib2RpZXNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IGlucHV0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoci5kb25lID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJtaXNzaW5nIHJlcXVlc3QgbWVzc2FnZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlRW52ZWxvcGUoMCwgc2VyaWFsaXplKHIudmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVvdXRNcyA9XG4gICAgICAgICAgICAgICAgdGltZW91dE1zID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmRlZmF1bHRUaW1lb3V0TXNcbiAgICAgICAgICAgICAgICAgICAgOiB0aW1lb3V0TXMgPD0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGltZW91dE1zO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1blN0cmVhbWluZ0NhbGwoe1xuICAgICAgICAgICAgICAgIGludGVyY2VwdG9yczogb3B0aW9ucy5pbnRlcmNlcHRvcnMsXG4gICAgICAgICAgICAgICAgdGltZW91dE1zLFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgICByZXE6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHVybDogY3JlYXRlTWV0aG9kVXJsKG9wdGlvbnMuYmFzZVVybCwgc2VydmljZSwgbWV0aG9kKSxcbiAgICAgICAgICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAoX2EgPSBvcHRpb25zLmNyZWRlbnRpYWxzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdDogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogcmVxdWVzdEhlYWRlcihtZXRob2Qua2luZCwgdXNlQmluYXJ5Rm9ybWF0LCB0aW1lb3V0TXMsIGhlYWRlciwgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0VmFsdWVzOiBjb250ZXh0VmFsdWVzICE9PSBudWxsICYmIGNvbnRleHRWYWx1ZXMgIT09IHZvaWQgMCA/IGNvbnRleHRWYWx1ZXMgOiBjcmVhdGVDb250ZXh0VmFsdWVzKCksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGlucHV0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV4dDogYXN5bmMgKHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoID0gKF9hID0gb3B0aW9ucy5mZXRjaCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZlJlcyA9IGF3YWl0IGZldGNoKHJlcS51cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxLmluaXQpLCB7IGhlYWRlcnM6IHJlcS5oZWFkZXIsIHNpZ25hbDogcmVxLnNpZ25hbCwgYm9keTogYXdhaXQgY3JlYXRlUmVxdWVzdEJvZHkocmVxLm1lc3NhZ2UpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVSZXNwb25zZShtZXRob2Qua2luZCwgdXNlQmluYXJ5Rm9ybWF0LCBmUmVzLnN0YXR1cywgZlJlcy5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZSZXMuYm9keSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJtaXNzaW5nIHJlc3BvbnNlIGJvZHlcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFpbGVyID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXEpLCB7IGhlYWRlcjogZlJlcy5oZWFkZXJzLCB0cmFpbGVyLCBtZXNzYWdlOiBwYXJzZVJlc3BvbnNlQm9keShmUmVzLmJvZHksIHRyYWlsZXIsIGZSZXMuaGVhZGVycywgcmVxLnNpZ25hbCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect-web/dist/esm/connect-transport.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/any-client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/any-client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeAnyClient: () => (/* binding */ makeAnyClient)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create any client for the given service.\n *\n * The given createMethod function is called for each method definition\n * of the service. The function it returns is added to the client object\n * as a method.\n */\nfunction makeAnyClient(service, createMethod) {\n    const client = {};\n    for (const [localName, methodInfo] of Object.entries(service.methods)) {\n        const method = createMethod(Object.assign(Object.assign({}, methodInfo), { localName,\n            service }));\n        if (method != null) {\n            client[localName] = method;\n        }\n    }\n    return client;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9hbnktY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY28vZXRob3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9hbnktY2xpZW50LmpzPzA0NGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGFueSBjbGllbnQgZm9yIHRoZSBnaXZlbiBzZXJ2aWNlLlxuICpcbiAqIFRoZSBnaXZlbiBjcmVhdGVNZXRob2QgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoIG1ldGhvZCBkZWZpbml0aW9uXG4gKiBvZiB0aGUgc2VydmljZS4gVGhlIGZ1bmN0aW9uIGl0IHJldHVybnMgaXMgYWRkZWQgdG8gdGhlIGNsaWVudCBvYmplY3RcbiAqIGFzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUFueUNsaWVudChzZXJ2aWNlLCBjcmVhdGVNZXRob2QpIHtcbiAgICBjb25zdCBjbGllbnQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtsb2NhbE5hbWUsIG1ldGhvZEluZm9dIG9mIE9iamVjdC5lbnRyaWVzKHNlcnZpY2UubWV0aG9kcykpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gY3JlYXRlTWV0aG9kKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWV0aG9kSW5mbyksIHsgbG9jYWxOYW1lLFxuICAgICAgICAgICAgc2VydmljZSB9KSk7XG4gICAgICAgIGlmIChtZXRob2QgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xpZW50W2xvY2FsTmFtZV0gPSBtZXRob2Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/any-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js":
/*!***********************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/code.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Connect represents categories of errors as codes, and each code maps to a\n * specific HTTP status code. The codes and their semantics were chosen to\n * match gRPC. Only the codes below are valid — there are no user-defined\n * codes.\n *\n * See the specification at https://connectrpc.com/docs/protocol#error-codes\n * for details.\n */\nvar Code;\n(function (Code) {\n    /**\n     * Canceled, usually be the user\n     */\n    Code[Code[\"Canceled\"] = 1] = \"Canceled\";\n    /**\n     * Unknown error\n     */\n    Code[Code[\"Unknown\"] = 2] = \"Unknown\";\n    /**\n     * Argument invalid regardless of system state\n     */\n    Code[Code[\"InvalidArgument\"] = 3] = \"InvalidArgument\";\n    /**\n     * Operation expired, may or may not have completed.\n     */\n    Code[Code[\"DeadlineExceeded\"] = 4] = \"DeadlineExceeded\";\n    /**\n     * Entity not found.\n     */\n    Code[Code[\"NotFound\"] = 5] = \"NotFound\";\n    /**\n     * Entity already exists.\n     */\n    Code[Code[\"AlreadyExists\"] = 6] = \"AlreadyExists\";\n    /**\n     * Operation not authorized.\n     */\n    Code[Code[\"PermissionDenied\"] = 7] = \"PermissionDenied\";\n    /**\n     * Quota exhausted.\n     */\n    Code[Code[\"ResourceExhausted\"] = 8] = \"ResourceExhausted\";\n    /**\n     * Argument invalid in current system state.\n     */\n    Code[Code[\"FailedPrecondition\"] = 9] = \"FailedPrecondition\";\n    /**\n     * Operation aborted.\n     */\n    Code[Code[\"Aborted\"] = 10] = \"Aborted\";\n    /**\n     * Out of bounds, use instead of FailedPrecondition.\n     */\n    Code[Code[\"OutOfRange\"] = 11] = \"OutOfRange\";\n    /**\n     * Operation not implemented or disabled.\n     */\n    Code[Code[\"Unimplemented\"] = 12] = \"Unimplemented\";\n    /**\n     * Internal error, reserved for \"serious errors\".\n     */\n    Code[Code[\"Internal\"] = 13] = \"Internal\";\n    /**\n     * Unavailable, client should back off and retry.\n     */\n    Code[Code[\"Unavailable\"] = 14] = \"Unavailable\";\n    /**\n     * Unrecoverable data loss or corruption.\n     */\n    Code[Code[\"DataLoss\"] = 15] = \"DataLoss\";\n    /**\n     * Request isn't authenticated.\n     */\n    Code[Code[\"Unauthenticated\"] = 16] = \"Unauthenticated\";\n})(Code || (Code = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9jb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY28vZXRob3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9jb2RlLmpzPzUxZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ29ubmVjdCByZXByZXNlbnRzIGNhdGVnb3JpZXMgb2YgZXJyb3JzIGFzIGNvZGVzLCBhbmQgZWFjaCBjb2RlIG1hcHMgdG8gYVxuICogc3BlY2lmaWMgSFRUUCBzdGF0dXMgY29kZS4gVGhlIGNvZGVzIGFuZCB0aGVpciBzZW1hbnRpY3Mgd2VyZSBjaG9zZW4gdG9cbiAqIG1hdGNoIGdSUEMuIE9ubHkgdGhlIGNvZGVzIGJlbG93IGFyZSB2YWxpZCDigJQgdGhlcmUgYXJlIG5vIHVzZXItZGVmaW5lZFxuICogY29kZXMuXG4gKlxuICogU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGF0IGh0dHBzOi8vY29ubmVjdHJwYy5jb20vZG9jcy9wcm90b2NvbCNlcnJvci1jb2Rlc1xuICogZm9yIGRldGFpbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29kZTtcbihmdW5jdGlvbiAoQ29kZSkge1xuICAgIC8qKlxuICAgICAqIENhbmNlbGVkLCB1c3VhbGx5IGJlIHRoZSB1c2VyXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiQ2FuY2VsZWRcIl0gPSAxXSA9IFwiQ2FuY2VsZWRcIjtcbiAgICAvKipcbiAgICAgKiBVbmtub3duIGVycm9yXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiVW5rbm93blwiXSA9IDJdID0gXCJVbmtub3duXCI7XG4gICAgLyoqXG4gICAgICogQXJndW1lbnQgaW52YWxpZCByZWdhcmRsZXNzIG9mIHN5c3RlbSBzdGF0ZVxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIkludmFsaWRBcmd1bWVudFwiXSA9IDNdID0gXCJJbnZhbGlkQXJndW1lbnRcIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gZXhwaXJlZCwgbWF5IG9yIG1heSBub3QgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiRGVhZGxpbmVFeGNlZWRlZFwiXSA9IDRdID0gXCJEZWFkbGluZUV4Y2VlZGVkXCI7XG4gICAgLyoqXG4gICAgICogRW50aXR5IG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJOb3RGb3VuZFwiXSA9IDVdID0gXCJOb3RGb3VuZFwiO1xuICAgIC8qKlxuICAgICAqIEVudGl0eSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJBbHJlYWR5RXhpc3RzXCJdID0gNl0gPSBcIkFscmVhZHlFeGlzdHNcIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb24gbm90IGF1dGhvcml6ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IDddID0gXCJQZXJtaXNzaW9uRGVuaWVkXCI7XG4gICAgLyoqXG4gICAgICogUXVvdGEgZXhoYXVzdGVkLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIlJlc291cmNlRXhoYXVzdGVkXCJdID0gOF0gPSBcIlJlc291cmNlRXhoYXVzdGVkXCI7XG4gICAgLyoqXG4gICAgICogQXJndW1lbnQgaW52YWxpZCBpbiBjdXJyZW50IHN5c3RlbSBzdGF0ZS5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJGYWlsZWRQcmVjb25kaXRpb25cIl0gPSA5XSA9IFwiRmFpbGVkUHJlY29uZGl0aW9uXCI7XG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIGFib3J0ZWQuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiQWJvcnRlZFwiXSA9IDEwXSA9IFwiQWJvcnRlZFwiO1xuICAgIC8qKlxuICAgICAqIE91dCBvZiBib3VuZHMsIHVzZSBpbnN0ZWFkIG9mIEZhaWxlZFByZWNvbmRpdGlvbi5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJPdXRPZlJhbmdlXCJdID0gMTFdID0gXCJPdXRPZlJhbmdlXCI7XG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9uIG5vdCBpbXBsZW1lbnRlZCBvciBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBDb2RlW0NvZGVbXCJVbmltcGxlbWVudGVkXCJdID0gMTJdID0gXCJVbmltcGxlbWVudGVkXCI7XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZXJyb3IsIHJlc2VydmVkIGZvciBcInNlcmlvdXMgZXJyb3JzXCIuXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiSW50ZXJuYWxcIl0gPSAxM10gPSBcIkludGVybmFsXCI7XG4gICAgLyoqXG4gICAgICogVW5hdmFpbGFibGUsIGNsaWVudCBzaG91bGQgYmFjayBvZmYgYW5kIHJldHJ5LlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIlVuYXZhaWxhYmxlXCJdID0gMTRdID0gXCJVbmF2YWlsYWJsZVwiO1xuICAgIC8qKlxuICAgICAqIFVucmVjb3ZlcmFibGUgZGF0YSBsb3NzIG9yIGNvcnJ1cHRpb24uXG4gICAgICovXG4gICAgQ29kZVtDb2RlW1wiRGF0YUxvc3NcIl0gPSAxNV0gPSBcIkRhdGFMb3NzXCI7XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBpc24ndCBhdXRoZW50aWNhdGVkLlxuICAgICAqL1xuICAgIENvZGVbQ29kZVtcIlVuYXV0aGVudGljYXRlZFwiXSA9IDE2XSA9IFwiVW5hdXRoZW50aWNhdGVkXCI7XG59KShDb2RlIHx8IChDb2RlID0ge30pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/connect-error.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectError: () => (/* binding */ ConnectError)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _protocol_connect_code_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protocol-connect/code-string.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * ConnectError captures four pieces of information: a Code, an error\n * message, an optional cause of the error, and an optional collection of\n * arbitrary Protobuf messages called  \"details\".\n *\n * Because developer tools typically show just the error message, we prefix\n * it with the status code, so that the most important information is always\n * visible immediately.\n *\n * Error details are wrapped with google.protobuf.Any on the wire, so that\n * a server or middleware can attach arbitrary data to an error. Use the\n * method findDetails() to retrieve the details.\n */\nclass ConnectError extends Error {\n    /**\n     * Create a new ConnectError.\n     * If no code is provided, code \"unknown\" is used.\n     * Outgoing details are only relevant for the server side - a service may\n     * raise an error with details, and it is up to the protocol implementation\n     * to encode and send the details along with error.\n     */\n    constructor(message, code = _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unknown, metadata, outgoingDetails, cause) {\n        super(createMessage(message, code));\n        this.name = \"ConnectError\";\n        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.rawMessage = message;\n        this.code = code;\n        this.metadata = new Headers(metadata !== null && metadata !== void 0 ? metadata : {});\n        this.details = outgoingDetails !== null && outgoingDetails !== void 0 ? outgoingDetails : [];\n        this.cause = cause;\n    }\n    /**\n     * Convert any value - typically a caught error into a ConnectError,\n     * following these rules:\n     * - If the value is already a ConnectError, return it as is.\n     * - If the value is an AbortError from the fetch API, return the message\n     *   of the AbortError with code Canceled.\n     * - For other Errors, return the error message with code Unknown by default.\n     * - For other values, return the values String representation as a message,\n     *   with the code Unknown by default.\n     * The original value will be used for the \"cause\" property for the new\n     * ConnectError.\n     */\n    static from(reason, code = _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unknown) {\n        if (reason instanceof ConnectError) {\n            return reason;\n        }\n        if (reason instanceof Error) {\n            if (reason.name == \"AbortError\") {\n                // Fetch requests can only be canceled with an AbortController.\n                // We detect that condition by looking at the name of the raised\n                // error object, and translate to the appropriate status code.\n                return new ConnectError(reason.message, _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Canceled);\n            }\n            return new ConnectError(reason.message, code, undefined, undefined, reason);\n        }\n        return new ConnectError(String(reason), code, undefined, undefined, reason);\n    }\n    static [Symbol.hasInstance](v) {\n        if (!(v instanceof Error)) {\n            return false;\n        }\n        if (Object.getPrototypeOf(v) === ConnectError.prototype) {\n            return true;\n        }\n        return (v.name === \"ConnectError\" &&\n            \"code\" in v &&\n            typeof v.code === \"number\" &&\n            \"metadata\" in v &&\n            \"details\" in v &&\n            Array.isArray(v.details) &&\n            \"rawMessage\" in v &&\n            typeof v.rawMessage == \"string\" &&\n            \"cause\" in v);\n    }\n    findDetails(typeOrRegistry) {\n        const registry = \"typeName\" in typeOrRegistry\n            ? {\n                findMessage: (typeName) => typeName === typeOrRegistry.typeName ? typeOrRegistry : undefined,\n            }\n            : typeOrRegistry;\n        const details = [];\n        for (const data of this.details) {\n            if (\"getType\" in data) {\n                if (registry.findMessage(data.getType().typeName)) {\n                    details.push(data);\n                }\n                continue;\n            }\n            const type = registry.findMessage(data.type);\n            if (type) {\n                try {\n                    details.push(type.fromBinary(data.value));\n                }\n                catch (_) {\n                    // We silently give up if we are unable to parse the detail, because\n                    // that appears to be the least worst behavior.\n                    // It is very unlikely that a user surrounds a catch body handling the\n                    // error with another try-catch statement, and we do not want to\n                    // recommend doing so.\n                }\n            }\n        }\n        return details;\n    }\n}\n/**\n * Create an error message, prefixing the given code.\n */\nfunction createMessage(message, code) {\n    return message.length\n        ? `[${(0,_protocol_connect_code_string_js__WEBPACK_IMPORTED_MODULE_1__.codeToString)(code)}] ${message}`\n        : `[${(0,_protocol_connect_code_string_js__WEBPACK_IMPORTED_MODULE_1__.codeToString)(code)}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9jb25uZWN0LWVycm9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lDO0FBQ2dDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBDQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMENBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhFQUFZLE9BQU8sSUFBSSxRQUFRO0FBQzdDLGNBQWMsOEVBQVksT0FBTztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vY29ubmVjdC1lcnJvci5qcz9kZTc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgY29kZVRvU3RyaW5nIH0gZnJvbSBcIi4vcHJvdG9jb2wtY29ubmVjdC9jb2RlLXN0cmluZy5qc1wiO1xuLyoqXG4gKiBDb25uZWN0RXJyb3IgY2FwdHVyZXMgZm91ciBwaWVjZXMgb2YgaW5mb3JtYXRpb246IGEgQ29kZSwgYW4gZXJyb3JcbiAqIG1lc3NhZ2UsIGFuIG9wdGlvbmFsIGNhdXNlIG9mIHRoZSBlcnJvciwgYW5kIGFuIG9wdGlvbmFsIGNvbGxlY3Rpb24gb2ZcbiAqIGFyYml0cmFyeSBQcm90b2J1ZiBtZXNzYWdlcyBjYWxsZWQgIFwiZGV0YWlsc1wiLlxuICpcbiAqIEJlY2F1c2UgZGV2ZWxvcGVyIHRvb2xzIHR5cGljYWxseSBzaG93IGp1c3QgdGhlIGVycm9yIG1lc3NhZ2UsIHdlIHByZWZpeFxuICogaXQgd2l0aCB0aGUgc3RhdHVzIGNvZGUsIHNvIHRoYXQgdGhlIG1vc3QgaW1wb3J0YW50IGluZm9ybWF0aW9uIGlzIGFsd2F5c1xuICogdmlzaWJsZSBpbW1lZGlhdGVseS5cbiAqXG4gKiBFcnJvciBkZXRhaWxzIGFyZSB3cmFwcGVkIHdpdGggZ29vZ2xlLnByb3RvYnVmLkFueSBvbiB0aGUgd2lyZSwgc28gdGhhdFxuICogYSBzZXJ2ZXIgb3IgbWlkZGxld2FyZSBjYW4gYXR0YWNoIGFyYml0cmFyeSBkYXRhIHRvIGFuIGVycm9yLiBVc2UgdGhlXG4gKiBtZXRob2QgZmluZERldGFpbHMoKSB0byByZXRyaWV2ZSB0aGUgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbm5lY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQ29ubmVjdEVycm9yLlxuICAgICAqIElmIG5vIGNvZGUgaXMgcHJvdmlkZWQsIGNvZGUgXCJ1bmtub3duXCIgaXMgdXNlZC5cbiAgICAgKiBPdXRnb2luZyBkZXRhaWxzIGFyZSBvbmx5IHJlbGV2YW50IGZvciB0aGUgc2VydmVyIHNpZGUgLSBhIHNlcnZpY2UgbWF5XG4gICAgICogcmFpc2UgYW4gZXJyb3Igd2l0aCBkZXRhaWxzLCBhbmQgaXQgaXMgdXAgdG8gdGhlIHByb3RvY29sIGltcGxlbWVudGF0aW9uXG4gICAgICogdG8gZW5jb2RlIGFuZCBzZW5kIHRoZSBkZXRhaWxzIGFsb25nIHdpdGggZXJyb3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSA9IENvZGUuVW5rbm93biwgbWV0YWRhdGEsIG91dGdvaW5nRGV0YWlscywgY2F1c2UpIHtcbiAgICAgICAgc3VwZXIoY3JlYXRlTWVzc2FnZShtZXNzYWdlLCBjb2RlKSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQ29ubmVjdEVycm9yXCI7XG4gICAgICAgIC8vIHNlZSBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi0yLmh0bWwjZXhhbXBsZVxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICB0aGlzLnJhd01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IEhlYWRlcnMobWV0YWRhdGEgIT09IG51bGwgJiYgbWV0YWRhdGEgIT09IHZvaWQgMCA/IG1ldGFkYXRhIDoge30pO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBvdXRnb2luZ0RldGFpbHMgIT09IG51bGwgJiYgb3V0Z29pbmdEZXRhaWxzICE9PSB2b2lkIDAgPyBvdXRnb2luZ0RldGFpbHMgOiBbXTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFueSB2YWx1ZSAtIHR5cGljYWxseSBhIGNhdWdodCBlcnJvciBpbnRvIGEgQ29ubmVjdEVycm9yLFxuICAgICAqIGZvbGxvd2luZyB0aGVzZSBydWxlczpcbiAgICAgKiAtIElmIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IGEgQ29ubmVjdEVycm9yLCByZXR1cm4gaXQgYXMgaXMuXG4gICAgICogLSBJZiB0aGUgdmFsdWUgaXMgYW4gQWJvcnRFcnJvciBmcm9tIHRoZSBmZXRjaCBBUEksIHJldHVybiB0aGUgbWVzc2FnZVxuICAgICAqICAgb2YgdGhlIEFib3J0RXJyb3Igd2l0aCBjb2RlIENhbmNlbGVkLlxuICAgICAqIC0gRm9yIG90aGVyIEVycm9ycywgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlIHdpdGggY29kZSBVbmtub3duIGJ5IGRlZmF1bHQuXG4gICAgICogLSBGb3Igb3RoZXIgdmFsdWVzLCByZXR1cm4gdGhlIHZhbHVlcyBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgYSBtZXNzYWdlLFxuICAgICAqICAgd2l0aCB0aGUgY29kZSBVbmtub3duIGJ5IGRlZmF1bHQuXG4gICAgICogVGhlIG9yaWdpbmFsIHZhbHVlIHdpbGwgYmUgdXNlZCBmb3IgdGhlIFwiY2F1c2VcIiBwcm9wZXJ0eSBmb3IgdGhlIG5ld1xuICAgICAqIENvbm5lY3RFcnJvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShyZWFzb24sIGNvZGUgPSBDb2RlLlVua25vd24pIHtcbiAgICAgICAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIENvbm5lY3RFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChyZWFzb24ubmFtZSA9PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIHJlcXVlc3RzIGNhbiBvbmx5IGJlIGNhbmNlbGVkIHdpdGggYW4gQWJvcnRDb250cm9sbGVyLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRldGVjdCB0aGF0IGNvbmRpdGlvbiBieSBsb29raW5nIGF0IHRoZSBuYW1lIG9mIHRoZSByYWlzZWRcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBvYmplY3QsIGFuZCB0cmFuc2xhdGUgdG8gdGhlIGFwcHJvcHJpYXRlIHN0YXR1cyBjb2RlLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29ubmVjdEVycm9yKHJlYXNvbi5tZXNzYWdlLCBDb2RlLkNhbmNlbGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29ubmVjdEVycm9yKHJlYXNvbi5tZXNzYWdlLCBjb2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbm5lY3RFcnJvcihTdHJpbmcocmVhc29uKSwgY29kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHJlYXNvbik7XG4gICAgfVxuICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXSh2KSB7XG4gICAgICAgIGlmICghKHYgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHYpID09PSBDb25uZWN0RXJyb3IucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHYubmFtZSA9PT0gXCJDb25uZWN0RXJyb3JcIiAmJlxuICAgICAgICAgICAgXCJjb2RlXCIgaW4gdiAmJlxuICAgICAgICAgICAgdHlwZW9mIHYuY29kZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiIGluIHYgJiZcbiAgICAgICAgICAgIFwiZGV0YWlsc1wiIGluIHYgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodi5kZXRhaWxzKSAmJlxuICAgICAgICAgICAgXCJyYXdNZXNzYWdlXCIgaW4gdiAmJlxuICAgICAgICAgICAgdHlwZW9mIHYucmF3TWVzc2FnZSA9PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICBcImNhdXNlXCIgaW4gdik7XG4gICAgfVxuICAgIGZpbmREZXRhaWxzKHR5cGVPclJlZ2lzdHJ5KSB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gXCJ0eXBlTmFtZVwiIGluIHR5cGVPclJlZ2lzdHJ5XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBmaW5kTWVzc2FnZTogKHR5cGVOYW1lKSA9PiB0eXBlTmFtZSA9PT0gdHlwZU9yUmVnaXN0cnkudHlwZU5hbWUgPyB0eXBlT3JSZWdpc3RyeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdHlwZU9yUmVnaXN0cnk7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHRoaXMuZGV0YWlscykge1xuICAgICAgICAgICAgaWYgKFwiZ2V0VHlwZVwiIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnkuZmluZE1lc3NhZ2UoZGF0YS5nZXRUeXBlKCkudHlwZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcmVnaXN0cnkuZmluZE1lc3NhZ2UoZGF0YS50eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKHR5cGUuZnJvbUJpbmFyeShkYXRhLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNpbGVudGx5IGdpdmUgdXAgaWYgd2UgYXJlIHVuYWJsZSB0byBwYXJzZSB0aGUgZGV0YWlsLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgYXBwZWFycyB0byBiZSB0aGUgbGVhc3Qgd29yc3QgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIHZlcnkgdW5saWtlbHkgdGhhdCBhIHVzZXIgc3Vycm91bmRzIGEgY2F0Y2ggYm9keSBoYW5kbGluZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3Igd2l0aCBhbm90aGVyIHRyeS1jYXRjaCBzdGF0ZW1lbnQsIGFuZCB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNvbW1lbmQgZG9pbmcgc28uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yIG1lc3NhZ2UsIHByZWZpeGluZyB0aGUgZ2l2ZW4gY29kZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZShtZXNzYWdlLCBjb2RlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoXG4gICAgICAgID8gYFske2NvZGVUb1N0cmluZyhjb2RlKX1dICR7bWVzc2FnZX1gXG4gICAgICAgIDogYFske2NvZGVUb1N0cmluZyhjb2RlKX1dYDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/context-values.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/context-values.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createContextKey: () => (/* binding */ createContextKey),\n/* harmony export */   createContextValues: () => (/* binding */ createContextValues)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * createContextValues creates a new ContextValues.\n */\nfunction createContextValues() {\n    return {\n        get(key) {\n            return key.id in this ? this[key.id] : key.defaultValue;\n        },\n        set(key, value) {\n            this[key.id] = value;\n            return this;\n        },\n        delete(key) {\n            delete this[key.id];\n            return this;\n        },\n    };\n}\n/**\n * createContextKey creates a new ContextKey.\n */\nfunction createContextKey(defaultValue, options) {\n    return { id: Symbol(options === null || options === void 0 ? void 0 : options.description), defaultValue };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9jb250ZXh0LXZhbHVlcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL2NvbnRleHQtdmFsdWVzLmpzPzg5YjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogY3JlYXRlQ29udGV4dFZhbHVlcyBjcmVhdGVzIGEgbmV3IENvbnRleHRWYWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0VmFsdWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkuaWQgaW4gdGhpcyA/IHRoaXNba2V5LmlkXSA6IGtleS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2tleS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpc1trZXkuaWRdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogY3JlYXRlQ29udGV4dEtleSBjcmVhdGVzIGEgbmV3IENvbnRleHRLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0S2V5KGRlZmF1bHRWYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB7IGlkOiBTeW1ib2wob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc2NyaXB0aW9uKSwgZGVmYXVsdFZhbHVlIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/context-values.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/http-headers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/http-headers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendHeaders: () => (/* binding */ appendHeaders),\n/* harmony export */   decodeBinaryHeader: () => (/* binding */ decodeBinaryHeader),\n/* harmony export */   encodeBinaryHeader: () => (/* binding */ encodeBinaryHeader)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(ssr)/./node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Encode a single binary header value according to the Connect\n * and gRPC specifications.\n *\n * This function accepts raw binary data from a buffer, a string\n * with UTF-8 text, or a protobuf message. It encodes the input\n * with unpadded base64 and returns a string that can be used for\n * a header whose name ends with `-bin`.\n */\nfunction encodeBinaryHeader(value) {\n    let bytes;\n    if (typeof value == \"object\" && \"getType\" in value) {\n        bytes = value.toBinary();\n    }\n    else if (typeof value == \"string\") {\n        bytes = new TextEncoder().encode(value);\n    }\n    else {\n        bytes = value instanceof Uint8Array ? value : new Uint8Array(value);\n    }\n    return _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__.protoBase64.enc(bytes).replace(/=+$/, \"\");\n}\nfunction decodeBinaryHeader(value, type, options) {\n    try {\n        const bytes = _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__.protoBase64.dec(value);\n        if (type) {\n            return type.fromBinary(bytes, options);\n        }\n        return bytes;\n    }\n    catch (e) {\n        throw _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError.from(e, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.DataLoss);\n    }\n}\n/**\n * Merge two or more Headers objects by appending all fields from\n * all inputs to a new Headers object.\n */\nfunction appendHeaders(...headers) {\n    const h = new Headers();\n    for (const e of headers) {\n        e.forEach((value, key) => {\n            h.append(key, value);\n        });\n    }\n    return h;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9odHRwLWhlYWRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUQ7QUFDQztBQUNqQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBVztBQUN0QjtBQUNPO0FBQ1A7QUFDQSxzQkFBc0IsMkRBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyREFBWSxTQUFTLDBDQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY28vZXRob3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9odHRwLWhlYWRlcnMuanM/NTljNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgcHJvdG9CYXNlNjQgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4vY29kZS5qc1wiO1xuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgYmluYXJ5IGhlYWRlciB2YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIENvbm5lY3RcbiAqIGFuZCBnUlBDIHNwZWNpZmljYXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyByYXcgYmluYXJ5IGRhdGEgZnJvbSBhIGJ1ZmZlciwgYSBzdHJpbmdcbiAqIHdpdGggVVRGLTggdGV4dCwgb3IgYSBwcm90b2J1ZiBtZXNzYWdlLiBJdCBlbmNvZGVzIHRoZSBpbnB1dFxuICogd2l0aCB1bnBhZGRlZCBiYXNlNjQgYW5kIHJldHVybnMgYSBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCBmb3JcbiAqIGEgaGVhZGVyIHdob3NlIG5hbWUgZW5kcyB3aXRoIGAtYmluYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJpbmFyeUhlYWRlcih2YWx1ZSkge1xuICAgIGxldCBieXRlcztcbiAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgXCJnZXRUeXBlXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgYnl0ZXMgPSB2YWx1ZS50b0JpbmFyeSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBieXRlcyA9IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSA/IHZhbHVlIDogbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdG9CYXNlNjQuZW5jKGJ5dGVzKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCaW5hcnlIZWFkZXIodmFsdWUsIHR5cGUsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHByb3RvQmFzZTY0LmRlYyh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IENvbm5lY3RFcnJvci5mcm9tKGUsIENvZGUuRGF0YUxvc3MpO1xuICAgIH1cbn1cbi8qKlxuICogTWVyZ2UgdHdvIG9yIG1vcmUgSGVhZGVycyBvYmplY3RzIGJ5IGFwcGVuZGluZyBhbGwgZmllbGRzIGZyb21cbiAqIGFsbCBpbnB1dHMgdG8gYSBuZXcgSGVhZGVycyBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRIZWFkZXJzKC4uLmhlYWRlcnMpIHtcbiAgICBjb25zdCBoID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgaGVhZGVycykge1xuICAgICAgICBlLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGguYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGg7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/http-headers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/interceptor.js":
/*!******************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/interceptor.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyInterceptors: () => (/* binding */ applyInterceptors)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * applyInterceptors takes the given UnaryFn or ServerStreamingFn, and wraps\n * it with each of the given interceptors, returning a new UnaryFn or\n * ServerStreamingFn.\n */\nfunction applyInterceptors(next, interceptors) {\n    var _a;\n    return ((_a = interceptors === null || interceptors === void 0 ? void 0 : interceptors.concat().reverse().reduce(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    (n, i) => i(n), next)) !== null && _a !== void 0 ? _a : next);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9pbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY28vZXRob3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9pbnRlcmNlcHRvci5qcz82ZTBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIGFwcGx5SW50ZXJjZXB0b3JzIHRha2VzIHRoZSBnaXZlbiBVbmFyeUZuIG9yIFNlcnZlclN0cmVhbWluZ0ZuLCBhbmQgd3JhcHNcbiAqIGl0IHdpdGggZWFjaCBvZiB0aGUgZ2l2ZW4gaW50ZXJjZXB0b3JzLCByZXR1cm5pbmcgYSBuZXcgVW5hcnlGbiBvclxuICogU2VydmVyU3RyZWFtaW5nRm4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUludGVyY2VwdG9ycyhuZXh0LCBpbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBpbnRlcmNlcHRvcnMgPT09IG51bGwgfHwgaW50ZXJjZXB0b3JzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRvcnMuY29uY2F0KCkucmV2ZXJzZSgpLnJlZHVjZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgIChuLCBpKSA9PiBpKG4pLCBuZXh0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV4dCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/promise-client.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/promise-client.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBiDiStreamingFn: () => (/* binding */ createBiDiStreamingFn),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createClientStreamingFn: () => (/* binding */ createClientStreamingFn),\n/* harmony export */   createPromiseClient: () => (/* binding */ createPromiseClient),\n/* harmony export */   createServerStreamingFn: () => (/* binding */ createServerStreamingFn),\n/* harmony export */   createUnaryFn: () => (/* binding */ createUnaryFn)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(ssr)/./node_modules/@bufbuild/protobuf/dist/esm/service-type.js\");\n/* harmony import */ var _any_client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./any-client.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/any-client.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _protocol_async_iterable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./protocol/async-iterable.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncDelegator = (undefined && undefined.__asyncDelegator) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n/**\n * Create a Client for the given service, invoking RPCs through the\n * given transport.\n */\nfunction createClient(service, transport) {\n    return (0,_any_client_js__WEBPACK_IMPORTED_MODULE_0__.makeAnyClient)(service, (method) => {\n        switch (method.kind) {\n            case _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.MethodKind.Unary:\n                return createUnaryFn(transport, service, method);\n            case _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.MethodKind.ServerStreaming:\n                return createServerStreamingFn(transport, service, method);\n            case _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.MethodKind.ClientStreaming:\n                return createClientStreamingFn(transport, service, method);\n            case _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.MethodKind.BiDiStreaming:\n                return createBiDiStreamingFn(transport, service, method);\n            default:\n                return null;\n        }\n    });\n}\n/**\n * @deprecated use createClient.\n */\nfunction createPromiseClient(service, transport) {\n    return createClient(service, transport);\n}\nfunction createUnaryFn(transport, service, method) {\n    return async function (input, options) {\n        var _a, _b;\n        const response = await transport.unary(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, input, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n        (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        return response.message;\n    };\n}\nfunction createServerStreamingFn(transport, service, method) {\n    return function (input, options) {\n        return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, (0,_protocol_async_iterable_js__WEBPACK_IMPORTED_MODULE_2__.createAsyncIterable)([input]), options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction createClientStreamingFn(transport, service, method) {\n    return async function (request, options) {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        const response = await transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_d = options === null || options === void 0 ? void 0 : options.onHeader) === null || _d === void 0 ? void 0 : _d.call(options, response.header);\n        let singleMessage;\n        let count = 0;\n        try {\n            for (var _f = true, _g = __asyncValues(response.message), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                _c = _h.value;\n                _f = false;\n                const message = _c;\n                singleMessage = message;\n                count++;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (!singleMessage) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_3__.ConnectError(\"protocol error: missing response message\", _code_js__WEBPACK_IMPORTED_MODULE_4__.Code.Unimplemented);\n        }\n        if (count > 1) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_3__.ConnectError(\"protocol error: received extra messages for client streaming method\", _code_js__WEBPACK_IMPORTED_MODULE_4__.Code.Unimplemented);\n        }\n        (_e = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _e === void 0 ? void 0 : _e.call(options, response.trailer);\n        return singleMessage;\n    };\n}\nfunction createBiDiStreamingFn(transport, service, method) {\n    return function (request, options) {\n        return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction handleStreamResponse(stream, options) {\n    const it = (function () {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, _b;\n            const response = yield __await(stream);\n            (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n            yield __await(yield* __asyncDelegator(__asyncValues(response.message)));\n            (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        });\n    })()[Symbol.asyncIterator]();\n    // Create a new iterable to omit throw/return.\n    return {\n        [Symbol.asyncIterator]: () => ({\n            next: () => it.next(),\n        }),\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm9taXNlLWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQUksSUFBSSxTQUFJO0FBQ2pDO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBLGVBQWUsU0FBSSxJQUFJLFNBQUksNEJBQTRCO0FBQ3ZELHdCQUF3QixTQUFJLElBQUksU0FBSTtBQUNwQztBQUNBLGlCQUFpQiw2Q0FBNkMsVUFBVSxzREFBc0QsY0FBYztBQUM1SSwwQkFBMEIsNkJBQTZCLG9CQUFvQix1Q0FBdUMsa0JBQWtCO0FBQ3BJO0FBQ0Esd0JBQXdCLFNBQUksSUFBSSxTQUFJO0FBQ3BDO0FBQ0E7QUFDQSxpQkFBaUIsb0dBQW9HLGNBQWM7QUFDbkksOEJBQThCLHNCQUFzQjtBQUNwRCwwQkFBMEIsWUFBWSxzQkFBc0IscUNBQXFDLDJDQUEyQyxNQUFNO0FBQ2xKLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUN5RDtBQUNUO0FBQ0U7QUFDakI7QUFDa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsNkRBQWE7QUFDeEI7QUFDQSxpQkFBaUIsMERBQVU7QUFDM0I7QUFDQSxpQkFBaUIsMERBQVU7QUFDM0I7QUFDQSxpQkFBaUIsMERBQVU7QUFDM0I7QUFDQSxpQkFBaUIsMERBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ1JBQWdSLGdGQUFtQjtBQUNuUztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHlDQUF5QztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVksNkNBQTZDLDBDQUFJO0FBQ25GO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVksd0VBQXdFLDBDQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvbWlzZS1jbGllbnQuanM/NWE3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fYXN5bmNWYWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNEZWxlZ2F0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNEZWxlZ2F0b3IpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGksIHA7XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufTtcbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuaW1wb3J0IHsgTWVzc2FnZSwgTWV0aG9kS2luZCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IG1ha2VBbnlDbGllbnQgfSBmcm9tIFwiLi9hbnktY2xpZW50LmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlQXN5bmNJdGVyYWJsZSB9IGZyb20gXCIuL3Byb3RvY29sL2FzeW5jLWl0ZXJhYmxlLmpzXCI7XG4vKipcbiAqIENyZWF0ZSBhIENsaWVudCBmb3IgdGhlIGdpdmVuIHNlcnZpY2UsIGludm9raW5nIFJQQ3MgdGhyb3VnaCB0aGVcbiAqIGdpdmVuIHRyYW5zcG9ydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudChzZXJ2aWNlLCB0cmFuc3BvcnQpIHtcbiAgICByZXR1cm4gbWFrZUFueUNsaWVudChzZXJ2aWNlLCAobWV0aG9kKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgTWV0aG9kS2luZC5VbmFyeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVW5hcnlGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCk7XG4gICAgICAgICAgICBjYXNlIE1ldGhvZEtpbmQuU2VydmVyU3RyZWFtaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJTdHJlYW1pbmdGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCk7XG4gICAgICAgICAgICBjYXNlIE1ldGhvZEtpbmQuQ2xpZW50U3RyZWFtaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDbGllbnRTdHJlYW1pbmdGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCk7XG4gICAgICAgICAgICBjYXNlIE1ldGhvZEtpbmQuQmlEaVN0cmVhbWluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQmlEaVN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgc2VydmljZSwgbWV0aG9kKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGNyZWF0ZUNsaWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb21pc2VDbGllbnQoc2VydmljZSwgdHJhbnNwb3J0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzZXJ2aWNlLCB0cmFuc3BvcnQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuYXJ5Rm4odHJhbnNwb3J0LCBzZXJ2aWNlLCBtZXRob2QpIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdHJhbnNwb3J0LnVuYXJ5KHNlcnZpY2UsIG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIGlucHV0LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dFZhbHVlcyk7XG4gICAgICAgIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkhlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgcmVzcG9uc2UuaGVhZGVyKTtcbiAgICAgICAgKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uVHJhaWxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucywgcmVzcG9uc2UudHJhaWxlcik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5tZXNzYWdlO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VydmVyU3RyZWFtaW5nRm4odHJhbnNwb3J0LCBzZXJ2aWNlLCBtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJlYW1SZXNwb25zZSh0cmFuc3BvcnQuc3RyZWFtKHNlcnZpY2UsIG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIGNyZWF0ZUFzeW5jSXRlcmFibGUoW2lucHV0XSksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0VmFsdWVzKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGllbnRTdHJlYW1pbmdGbih0cmFuc3BvcnQsIHNlcnZpY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRyYW5zcG9ydC5zdHJlYW0oc2VydmljZSwgbWV0aG9kLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dE1zLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycywgcmVxdWVzdCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHRWYWx1ZXMpO1xuICAgICAgICAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IZWFkZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKG9wdGlvbnMsIHJlc3BvbnNlLmhlYWRlcik7XG4gICAgICAgIGxldCBzaW5nbGVNZXNzYWdlO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXMocmVzcG9uc2UubWVzc2FnZSksIF9oOyBfaCA9IGF3YWl0IF9nLm5leHQoKSwgX2EgPSBfaC5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gX2M7XG4gICAgICAgICAgICAgICAgc2luZ2xlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gX2cucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaW5nbGVNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKFwicHJvdG9jb2wgZXJyb3I6IG1pc3NpbmcgcmVzcG9uc2UgbWVzc2FnZVwiLCBDb2RlLlVuaW1wbGVtZW50ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoXCJwcm90b2NvbCBlcnJvcjogcmVjZWl2ZWQgZXh0cmEgbWVzc2FnZXMgZm9yIGNsaWVudCBzdHJlYW1pbmcgbWV0aG9kXCIsIENvZGUuVW5pbXBsZW1lbnRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uVHJhaWxlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwob3B0aW9ucywgcmVzcG9uc2UudHJhaWxlcik7XG4gICAgICAgIHJldHVybiBzaW5nbGVNZXNzYWdlO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmlEaVN0cmVhbWluZ0ZuKHRyYW5zcG9ydCwgc2VydmljZSwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJlYW1SZXNwb25zZSh0cmFuc3BvcnQuc3RyZWFtKHNlcnZpY2UsIG1ldGhvZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXRNcywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsIHJlcXVlc3QsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250ZXh0VmFsdWVzKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVN0cmVhbVJlc3BvbnNlKHN0cmVhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgX19hd2FpdChzdHJlYW0pO1xuICAgICAgICAgICAgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uSGVhZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCByZXNwb25zZS5oZWFkZXIpO1xuICAgICAgICAgICAgeWllbGQgX19hd2FpdCh5aWVsZCogX19hc3luY0RlbGVnYXRvcihfX2FzeW5jVmFsdWVzKHJlc3BvbnNlLm1lc3NhZ2UpKSk7XG4gICAgICAgICAgICAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25UcmFpbGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zLCByZXNwb25zZS50cmFpbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfSkoKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAvLyBDcmVhdGUgYSBuZXcgaXRlcmFibGUgdG8gb21pdCB0aHJvdy9yZXR1cm4uXG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKCkgPT4gKHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IGl0Lm5leHQoKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/promise-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codeFromString: () => (/* binding */ codeFromString),\n/* harmony export */   codeToString: () => (/* binding */ codeToString)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * codeToString returns the string representation of a Code.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeToString(value) {\n    const name = _code_js__WEBPACK_IMPORTED_MODULE_0__.Code[value];\n    if (typeof name != \"string\") {\n        return value.toString();\n    }\n    return (name[0].toLowerCase() +\n        name.substring(1).replace(/[A-Z]/g, (c) => \"_\" + c.toLowerCase()));\n}\nlet stringToCode;\n/**\n * codeFromString parses the string representation of a Code in snake_case.\n * For example, the string \"permission_denied\" parses into Code.PermissionDenied.\n *\n * If the given string cannot be parsed, the function returns undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeFromString(value) {\n    if (!stringToCode) {\n        stringToCode = {};\n        for (const value of Object.values(_code_js__WEBPACK_IMPORTED_MODULE_0__.Code)) {\n            if (typeof value == \"string\") {\n                continue;\n            }\n            stringToCode[codeToString(value)] = value;\n        }\n    }\n    return stringToCode[value];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2NvZGUtc3RyaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQiwwQ0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwQ0FBMEMsMENBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC9jb2RlLXN0cmluZy5qcz9jNDY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogY29kZVRvU3RyaW5nIHJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIENvZGUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlVG9TdHJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBuYW1lID0gQ29kZVt2YWx1ZV07XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiAobmFtZVswXS50b0xvd2VyQ2FzZSgpICtcbiAgICAgICAgbmFtZS5zdWJzdHJpbmcoMSkucmVwbGFjZSgvW0EtWl0vZywgKGMpID0+IFwiX1wiICsgYy50b0xvd2VyQ2FzZSgpKSk7XG59XG5sZXQgc3RyaW5nVG9Db2RlO1xuLyoqXG4gKiBjb2RlRnJvbVN0cmluZyBwYXJzZXMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIENvZGUgaW4gc25ha2VfY2FzZS5cbiAqIEZvciBleGFtcGxlLCB0aGUgc3RyaW5nIFwicGVybWlzc2lvbl9kZW5pZWRcIiBwYXJzZXMgaW50byBDb2RlLlBlcm1pc3Npb25EZW5pZWQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlRnJvbVN0cmluZyh2YWx1ZSkge1xuICAgIGlmICghc3RyaW5nVG9Db2RlKSB7XG4gICAgICAgIHN0cmluZ1RvQ29kZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIE9iamVjdC52YWx1ZXMoQ29kZSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nVG9Db2RlW2NvZGVUb1N0cmluZyh2YWx1ZSldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQ29kZVt2YWx1ZV07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   contentTypeRegExp: () => (/* binding */ contentTypeRegExp),\n/* harmony export */   contentTypeStreamJson: () => (/* binding */ contentTypeStreamJson),\n/* harmony export */   contentTypeStreamProto: () => (/* binding */ contentTypeStreamProto),\n/* harmony export */   contentTypeStreamRegExp: () => (/* binding */ contentTypeStreamRegExp),\n/* harmony export */   contentTypeUnaryJson: () => (/* binding */ contentTypeUnaryJson),\n/* harmony export */   contentTypeUnaryProto: () => (/* binding */ contentTypeUnaryProto),\n/* harmony export */   contentTypeUnaryRegExp: () => (/* binding */ contentTypeUnaryRegExp),\n/* harmony export */   parseContentType: () => (/* binding */ parseContentType),\n/* harmony export */   parseEncodingQuery: () => (/* binding */ parseEncodingQuery)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Regular Expression that matches any valid Connect Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst contentTypeRegExp = /^application\\/(connect\\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i;\n/**\n * Regular Expression that matches a Connect unary Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst contentTypeUnaryRegExp = /^application\\/(?:json(?:; ?charset=utf-?8)?|proto)$/i;\n/**\n * Regular Expression that matches a Connect streaming Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst contentTypeStreamRegExp = /^application\\/connect\\+?(?:json(?:; ?charset=utf-?8)?|proto)$/i;\nconst contentTypeUnaryProto = \"application/proto\";\nconst contentTypeUnaryJson = \"application/json\";\nconst contentTypeStreamProto = \"application/connect+proto\";\nconst contentTypeStreamJson = \"application/connect+json\";\nconst encodingProto = \"proto\";\nconst encodingJson = \"json\";\n/**\n * Parse a Connect Content-Type header.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction parseContentType(contentType) {\n    const match = contentType === null || contentType === void 0 ? void 0 : contentType.match(contentTypeRegExp);\n    if (!match) {\n        return undefined;\n    }\n    const stream = !!match[1];\n    const binary = !!match[3];\n    return { stream, binary };\n}\n/**\n * Parse a Connect Get encoding query parameter.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction parseEncodingQuery(encoding) {\n    switch (encoding) {\n        case encodingProto:\n            return { stream: false, binary: true };\n        case encodingJson:\n            return { stream: false, binary: false };\n        default:\n            return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2NvbnRlbnQtdHlwZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtRUFBbUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBEQUEwRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvY29udGVudC10eXBlLmpzPzliZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmVndWxhciBFeHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbnkgdmFsaWQgQ29ubmVjdCBDb250ZW50LVR5cGUgaGVhZGVyIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgY29uc3QgY29udGVudFR5cGVSZWdFeHAgPSAvXmFwcGxpY2F0aW9uXFwvKGNvbm5lY3RcXCspPyg/Oihqc29uKSg/OjsgP2NoYXJzZXQ9dXRmLT84KT98KHByb3RvKSkkL2k7XG4vKipcbiAqIFJlZ3VsYXIgRXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYSBDb25uZWN0IHVuYXJ5IENvbnRlbnQtVHlwZSBoZWFkZXIgdmFsdWUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVVuYXJ5UmVnRXhwID0gL15hcHBsaWNhdGlvblxcLyg/Ompzb24oPzo7ID9jaGFyc2V0PXV0Zi0/OCk/fHByb3RvKSQvaTtcbi8qKlxuICogUmVndWxhciBFeHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIENvbm5lY3Qgc3RyZWFtaW5nIENvbnRlbnQtVHlwZSBoZWFkZXIgdmFsdWUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVN0cmVhbVJlZ0V4cCA9IC9eYXBwbGljYXRpb25cXC9jb25uZWN0XFwrPyg/Ompzb24oPzo7ID9jaGFyc2V0PXV0Zi0/OCk/fHByb3RvKSQvaTtcbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVVuYXJ5UHJvdG8gPSBcImFwcGxpY2F0aW9uL3Byb3RvXCI7XG5leHBvcnQgY29uc3QgY29udGVudFR5cGVVbmFyeUpzb24gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbmV4cG9ydCBjb25zdCBjb250ZW50VHlwZVN0cmVhbVByb3RvID0gXCJhcHBsaWNhdGlvbi9jb25uZWN0K3Byb3RvXCI7XG5leHBvcnQgY29uc3QgY29udGVudFR5cGVTdHJlYW1Kc29uID0gXCJhcHBsaWNhdGlvbi9jb25uZWN0K2pzb25cIjtcbmNvbnN0IGVuY29kaW5nUHJvdG8gPSBcInByb3RvXCI7XG5jb25zdCBlbmNvZGluZ0pzb24gPSBcImpzb25cIjtcbi8qKlxuICogUGFyc2UgYSBDb25uZWN0IENvbnRlbnQtVHlwZSBoZWFkZXIuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBjb250ZW50VHlwZSA9PT0gbnVsbCB8fCBjb250ZW50VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudFR5cGUubWF0Y2goY29udGVudFR5cGVSZWdFeHApO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc3RyZWFtID0gISFtYXRjaFsxXTtcbiAgICBjb25zdCBiaW5hcnkgPSAhIW1hdGNoWzNdO1xuICAgIHJldHVybiB7IHN0cmVhbSwgYmluYXJ5IH07XG59XG4vKipcbiAqIFBhcnNlIGEgQ29ubmVjdCBHZXQgZW5jb2RpbmcgcXVlcnkgcGFyYW1ldGVyLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFbmNvZGluZ1F1ZXJ5KGVuY29kaW5nKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlIGVuY29kaW5nUHJvdG86XG4gICAgICAgICAgICByZXR1cm4geyBzdHJlYW06IGZhbHNlLCBiaW5hcnk6IHRydWUgfTtcbiAgICAgICAgY2FzZSBlbmNvZGluZ0pzb246XG4gICAgICAgICAgICByZXR1cm4geyBzdHJlYW06IGZhbHNlLCBiaW5hcnk6IGZhbHNlIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/end-stream.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/end-stream.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEndStreamSerialization: () => (/* binding */ createEndStreamSerialization),\n/* harmony export */   endStreamFlag: () => (/* binding */ endStreamFlag),\n/* harmony export */   endStreamFromJson: () => (/* binding */ endStreamFromJson),\n/* harmony export */   endStreamToJson: () => (/* binding */ endStreamToJson)\n/* harmony export */ });\n/* harmony import */ var _error_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./error-json.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js\");\n/* harmony import */ var _http_headers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../http-headers.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/http-headers.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * endStreamFlag indicates that the data in a EnvelopedMessage\n * is a EndStreamResponse of the Connect protocol.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst endStreamFlag = 0b00000010;\n/**\n * Parse an EndStreamResponse of the Connect protocol.\n * Throws a ConnectError on malformed input.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction endStreamFromJson(data) {\n    const parseErr = new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"invalid end stream\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Unknown);\n    let jsonValue;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        jsonValue = JSON.parse(typeof data == \"string\" ? data : new TextDecoder().decode(data));\n    }\n    catch (e) {\n        throw parseErr;\n    }\n    if (typeof jsonValue != \"object\" ||\n        jsonValue == null ||\n        Array.isArray(jsonValue)) {\n        throw parseErr;\n    }\n    const metadata = new Headers();\n    if (\"metadata\" in jsonValue) {\n        if (typeof jsonValue.metadata != \"object\" ||\n            jsonValue.metadata == null ||\n            Array.isArray(jsonValue.metadata)) {\n            throw parseErr;\n        }\n        for (const [key, values] of Object.entries(jsonValue.metadata)) {\n            if (!Array.isArray(values) ||\n                values.some((value) => typeof value != \"string\")) {\n                throw parseErr;\n            }\n            for (const value of values) {\n                metadata.append(key, value);\n            }\n        }\n    }\n    const error = \"error\" in jsonValue && jsonValue.error != null\n        ? (0,_error_json_js__WEBPACK_IMPORTED_MODULE_2__.errorFromJson)(jsonValue.error, metadata, parseErr)\n        : undefined;\n    return { metadata, error };\n}\n/**\n * Serialize the given EndStreamResponse to JSON.\n *\n * The JSON serialization options are required to produce the optional\n * human-readable representation of error details if the detail uses\n * google.protobuf.Any.\n *\n * See https://connectrpc.com/docs/protocol#error-end-stream\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction endStreamToJson(metadata, error, jsonWriteOptions) {\n    const es = {};\n    if (error !== undefined) {\n        es.error = (0,_error_json_js__WEBPACK_IMPORTED_MODULE_2__.errorToJson)(error, jsonWriteOptions);\n        metadata = (0,_http_headers_js__WEBPACK_IMPORTED_MODULE_3__.appendHeaders)(metadata, error.metadata);\n    }\n    let hasMetadata = false;\n    const md = {};\n    metadata.forEach((value, key) => {\n        hasMetadata = true;\n        md[key] = [value];\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (hasMetadata) {\n        es.metadata = md;\n    }\n    return es;\n}\n/**\n * Create a Serialization object that serializes a Connect EndStreamResponse.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createEndStreamSerialization(options) {\n    const textEncoder = new TextEncoder();\n    return {\n        serialize(data) {\n            try {\n                const jsonObject = endStreamToJson(data.metadata, data.error, options);\n                const jsonString = JSON.stringify(jsonObject);\n                return textEncoder.encode(jsonString);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`failed to serialize EndStreamResponse: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n            }\n        },\n        parse(data) {\n            try {\n                return endStreamFromJson(data);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`failed to parse EndStreamResponse: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n            }\n        },\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2VuZC1zdHJlYW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUNWO0FBQ0E7QUFDakI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHlCQUF5QiwyREFBWSx1QkFBdUIsMENBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZEQUFhO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQiwyREFBVztBQUM5QixtQkFBbUIsK0RBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFZLDJDQUEyQyxFQUFFLEdBQUcsMENBQUk7QUFDMUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFZLHVDQUF1QyxFQUFFLEdBQUcsMENBQUk7QUFDdEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC9lbmQtc3RyZWFtLmpzPzBjYjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IGVycm9yRnJvbUpzb24sIGVycm9yVG9Kc29uIH0gZnJvbSBcIi4vZXJyb3ItanNvbi5qc1wiO1xuaW1wb3J0IHsgYXBwZW5kSGVhZGVycyB9IGZyb20gXCIuLi9odHRwLWhlYWRlcnMuanNcIjtcbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogZW5kU3RyZWFtRmxhZyBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpbiBhIEVudmVsb3BlZE1lc3NhZ2VcbiAqIGlzIGEgRW5kU3RyZWFtUmVzcG9uc2Ugb2YgdGhlIENvbm5lY3QgcHJvdG9jb2wuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmRTdHJlYW1GbGFnID0gMGIwMDAwMDAxMDtcbi8qKlxuICogUGFyc2UgYW4gRW5kU3RyZWFtUmVzcG9uc2Ugb2YgdGhlIENvbm5lY3QgcHJvdG9jb2wuXG4gKiBUaHJvd3MgYSBDb25uZWN0RXJyb3Igb24gbWFsZm9ybWVkIGlucHV0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5kU3RyZWFtRnJvbUpzb24oZGF0YSkge1xuICAgIGNvbnN0IHBhcnNlRXJyID0gbmV3IENvbm5lY3RFcnJvcihcImludmFsaWQgZW5kIHN0cmVhbVwiLCBDb2RlLlVua25vd24pO1xuICAgIGxldCBqc29uVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgPyBkYXRhIDogbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgcGFyc2VFcnI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YganNvblZhbHVlICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAganNvblZhbHVlID09IG51bGwgfHxcbiAgICAgICAgQXJyYXkuaXNBcnJheShqc29uVmFsdWUpKSB7XG4gICAgICAgIHRocm93IHBhcnNlRXJyO1xuICAgIH1cbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBIZWFkZXJzKCk7XG4gICAgaWYgKFwibWV0YWRhdGFcIiBpbiBqc29uVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uVmFsdWUubWV0YWRhdGEgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAganNvblZhbHVlLm1ldGFkYXRhID09IG51bGwgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoanNvblZhbHVlLm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgcGFyc2VFcnI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25WYWx1ZS5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWVzLnNvbWUoKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwYXJzZUVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gXCJlcnJvclwiIGluIGpzb25WYWx1ZSAmJiBqc29uVmFsdWUuZXJyb3IgIT0gbnVsbFxuICAgICAgICA/IGVycm9yRnJvbUpzb24oanNvblZhbHVlLmVycm9yLCBtZXRhZGF0YSwgcGFyc2VFcnIpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IG1ldGFkYXRhLCBlcnJvciB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIEVuZFN0cmVhbVJlc3BvbnNlIHRvIEpTT04uXG4gKlxuICogVGhlIEpTT04gc2VyaWFsaXphdGlvbiBvcHRpb25zIGFyZSByZXF1aXJlZCB0byBwcm9kdWNlIHRoZSBvcHRpb25hbFxuICogaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgZXJyb3IgZGV0YWlscyBpZiB0aGUgZGV0YWlsIHVzZXNcbiAqIGdvb2dsZS5wcm90b2J1Zi5BbnkuXG4gKlxuICogU2VlIGh0dHBzOi8vY29ubmVjdHJwYy5jb20vZG9jcy9wcm90b2NvbCNlcnJvci1lbmQtc3RyZWFtXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRTdHJlYW1Ub0pzb24obWV0YWRhdGEsIGVycm9yLCBqc29uV3JpdGVPcHRpb25zKSB7XG4gICAgY29uc3QgZXMgPSB7fTtcbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcy5lcnJvciA9IGVycm9yVG9Kc29uKGVycm9yLCBqc29uV3JpdGVPcHRpb25zKTtcbiAgICAgICAgbWV0YWRhdGEgPSBhcHBlbmRIZWFkZXJzKG1ldGFkYXRhLCBlcnJvci5tZXRhZGF0YSk7XG4gICAgfVxuICAgIGxldCBoYXNNZXRhZGF0YSA9IGZhbHNlO1xuICAgIGNvbnN0IG1kID0ge307XG4gICAgbWV0YWRhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoYXNNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIG1kW2tleV0gPSBbdmFsdWVdO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKGhhc01ldGFkYXRhKSB7XG4gICAgICAgIGVzLm1ldGFkYXRhID0gbWQ7XG4gICAgfVxuICAgIHJldHVybiBlcztcbn1cbi8qKlxuICogQ3JlYXRlIGEgU2VyaWFsaXphdGlvbiBvYmplY3QgdGhhdCBzZXJpYWxpemVzIGEgQ29ubmVjdCBFbmRTdHJlYW1SZXNwb25zZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVuZFN0cmVhbVNlcmlhbGl6YXRpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbk9iamVjdCA9IGVuZFN0cmVhbVRvSnNvbihkYXRhLm1ldGFkYXRhLCBkYXRhLmVycm9yLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoanNvbk9iamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZShqc29uU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBmYWlsZWQgdG8gc2VyaWFsaXplIEVuZFN0cmVhbVJlc3BvbnNlOiAke219YCwgQ29kZS5JbnRlcm5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZFN0cmVhbUZyb21Kc29uKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYGZhaWxlZCB0byBwYXJzZSBFbmRTdHJlYW1SZXNwb25zZTogJHttfWAsIENvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/end-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   errorFromJson: () => (/* binding */ errorFromJson),\n/* harmony export */   errorFromJsonBytes: () => (/* binding */ errorFromJsonBytes),\n/* harmony export */   errorToJson: () => (/* binding */ errorToJson),\n/* harmony export */   errorToJsonBytes: () => (/* binding */ errorToJsonBytes)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(ssr)/./node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code-string.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/code-string.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\n/**\n * Parse a Connect error from a JSON value.\n * Will return a ConnectError, and throw the provided fallback if parsing failed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction errorFromJson(jsonValue, metadata, fallback) {\n    var _a;\n    if (metadata) {\n        new Headers(metadata).forEach((value, key) => fallback.metadata.append(key, value));\n    }\n    if (typeof jsonValue !== \"object\" ||\n        jsonValue == null ||\n        Array.isArray(jsonValue)) {\n        throw fallback;\n    }\n    let code = fallback.code;\n    if (\"code\" in jsonValue && typeof jsonValue.code === \"string\") {\n        code = (_a = (0,_code_string_js__WEBPACK_IMPORTED_MODULE_0__.codeFromString)(jsonValue.code)) !== null && _a !== void 0 ? _a : code;\n    }\n    const message = jsonValue.message;\n    if (message != null && typeof message !== \"string\") {\n        throw fallback;\n    }\n    const error = new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(message !== null && message !== void 0 ? message : \"\", code, metadata);\n    if (\"details\" in jsonValue && Array.isArray(jsonValue.details)) {\n        for (const detail of jsonValue.details) {\n            if (detail === null ||\n                typeof detail != \"object\" ||\n                Array.isArray(detail) ||\n                typeof detail.type != \"string\" ||\n                typeof detail.value != \"string\") {\n                throw fallback;\n            }\n            try {\n                error.details.push({\n                    type: detail.type,\n                    value: _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_2__.protoBase64.dec(detail.value),\n                    debug: detail.debug,\n                });\n            }\n            catch (e) {\n                throw fallback;\n            }\n        }\n    }\n    return error;\n}\n/**\n * Parse a Connect error from a serialized JSON value.\n * Will return a ConnectError, and throw the provided fallback if parsing failed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction errorFromJsonBytes(bytes, metadata, fallback) {\n    let jsonValue;\n    try {\n        jsonValue = JSON.parse(new TextDecoder().decode(bytes));\n    }\n    catch (e) {\n        throw fallback;\n    }\n    return errorFromJson(jsonValue, metadata, fallback);\n}\n/**\n * Serialize the given error to JSON.\n *\n * The JSON serialization options are required to produce the optional\n * human-readable representation in the \"debug\" key if the detail uses\n * google.protobuf.Any. If serialization of the \"debug\" value fails, it\n * is silently disregarded.\n *\n * See https://connectrpc.com/docs/protocol#error-end-stream\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction errorToJson(error, jsonWriteOptions) {\n    const o = {\n        code: (0,_code_string_js__WEBPACK_IMPORTED_MODULE_0__.codeToString)(error.code),\n    };\n    if (error.rawMessage.length > 0) {\n        o.message = error.rawMessage;\n    }\n    if (error.details.length > 0) {\n        o.details = error.details\n            .map((value) => {\n            if (\"getType\" in value) {\n                const i = {\n                    type: value.getType().typeName,\n                    value: value.toBinary(),\n                };\n                try {\n                    i.debug = value.toJson(jsonWriteOptions);\n                }\n                catch (e) {\n                    // We deliberately ignore errors that may occur when serializing\n                    // a message to JSON (the message contains an Any).\n                    // The rationale is that we are only trying to provide optional\n                    // debug information.\n                }\n                return i;\n            }\n            return value;\n        })\n            .map((_a) => {\n            var { value } = _a, rest = __rest(_a, [\"value\"]);\n            return (Object.assign(Object.assign({}, rest), { value: _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_2__.protoBase64.enc(value).replace(/=+$/, \"\") }));\n        });\n    }\n    return o;\n}\n/**\n * Serialize the given error to JSON. This calls errorToJson(), but stringifies\n * the result, and converts it into a UInt8Array.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction errorToJsonBytes(error, jsonWriteOptions) {\n    const textEncoder = new TextEncoder();\n    try {\n        const jsonObject = errorToJson(error, jsonWriteOptions);\n        const jsonString = JSON.stringify(jsonObject);\n        return textEncoder.encode(jsonString);\n    }\n    catch (e) {\n        const m = e instanceof Error ? e.message : String(e);\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`failed to serialize Connect Error: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_3__.Code.Internal);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2Vycm9yLWpzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lEO0FBQ2Y7QUFDaUI7QUFDYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkRBQVc7QUFDdEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGNBQWMsNkRBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0RBQWtELFdBQVcsT0FBTywyREFBVyxnQ0FBZ0M7QUFDL0csU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBWSx1Q0FBdUMsRUFBRSxHQUFHLDBDQUFJO0FBQzlFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvZXJyb3ItanNvbi5qcz9kMTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgeyBwcm90b0Jhc2U2NCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgQ29ubmVjdEVycm9yIH0gZnJvbSBcIi4uL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IGNvZGVGcm9tU3RyaW5nLCBjb2RlVG9TdHJpbmcgfSBmcm9tIFwiLi9jb2RlLXN0cmluZy5qc1wiO1xuLyoqXG4gKiBQYXJzZSBhIENvbm5lY3QgZXJyb3IgZnJvbSBhIEpTT04gdmFsdWUuXG4gKiBXaWxsIHJldHVybiBhIENvbm5lY3RFcnJvciwgYW5kIHRocm93IHRoZSBwcm92aWRlZCBmYWxsYmFjayBpZiBwYXJzaW5nIGZhaWxlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yRnJvbUpzb24oanNvblZhbHVlLCBtZXRhZGF0YSwgZmFsbGJhY2spIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIG5ldyBIZWFkZXJzKG1ldGFkYXRhKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBmYWxsYmFjay5tZXRhZGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb25WYWx1ZSAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICBqc29uVmFsdWUgPT0gbnVsbCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgZmFsbGJhY2s7XG4gICAgfVxuICAgIGxldCBjb2RlID0gZmFsbGJhY2suY29kZTtcbiAgICBpZiAoXCJjb2RlXCIgaW4ganNvblZhbHVlICYmIHR5cGVvZiBqc29uVmFsdWUuY29kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb2RlID0gKF9hID0gY29kZUZyb21TdHJpbmcoanNvblZhbHVlLmNvZGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2RlO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0ganNvblZhbHVlLm1lc3NhZ2U7XG4gICAgaWYgKG1lc3NhZ2UgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBmYWxsYmFjaztcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgQ29ubmVjdEVycm9yKG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IFwiXCIsIGNvZGUsIG1ldGFkYXRhKTtcbiAgICBpZiAoXCJkZXRhaWxzXCIgaW4ganNvblZhbHVlICYmIEFycmF5LmlzQXJyYXkoanNvblZhbHVlLmRldGFpbHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGV0YWlsIG9mIGpzb25WYWx1ZS5kZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAoZGV0YWlsID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGRldGFpbCAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkZXRhaWwpIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGRldGFpbC50eXBlICE9IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGV0YWlsLnZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGV0YWlsLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwcm90b0Jhc2U2NC5kZWMoZGV0YWlsLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgZGVidWc6IGRldGFpbC5kZWJ1ZyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLyoqXG4gKiBQYXJzZSBhIENvbm5lY3QgZXJyb3IgZnJvbSBhIHNlcmlhbGl6ZWQgSlNPTiB2YWx1ZS5cbiAqIFdpbGwgcmV0dXJuIGEgQ29ubmVjdEVycm9yLCBhbmQgdGhyb3cgdGhlIHByb3ZpZGVkIGZhbGxiYWNrIGlmIHBhcnNpbmcgZmFpbGVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JGcm9tSnNvbkJ5dGVzKGJ5dGVzLCBtZXRhZGF0YSwgZmFsbGJhY2spIHtcbiAgICBsZXQganNvblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICAgIGpzb25WYWx1ZSA9IEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGZhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JGcm9tSnNvbihqc29uVmFsdWUsIG1ldGFkYXRhLCBmYWxsYmFjayk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gZXJyb3IgdG8gSlNPTi5cbiAqXG4gKiBUaGUgSlNPTiBzZXJpYWxpemF0aW9uIG9wdGlvbnMgYXJlIHJlcXVpcmVkIHRvIHByb2R1Y2UgdGhlIG9wdGlvbmFsXG4gKiBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbiBpbiB0aGUgXCJkZWJ1Z1wiIGtleSBpZiB0aGUgZGV0YWlsIHVzZXNcbiAqIGdvb2dsZS5wcm90b2J1Zi5BbnkuIElmIHNlcmlhbGl6YXRpb24gb2YgdGhlIFwiZGVidWdcIiB2YWx1ZSBmYWlscywgaXRcbiAqIGlzIHNpbGVudGx5IGRpc3JlZ2FyZGVkLlxuICpcbiAqIFNlZSBodHRwczovL2Nvbm5lY3RycGMuY29tL2RvY3MvcHJvdG9jb2wjZXJyb3ItZW5kLXN0cmVhbVxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JUb0pzb24oZXJyb3IsIGpzb25Xcml0ZU9wdGlvbnMpIHtcbiAgICBjb25zdCBvID0ge1xuICAgICAgICBjb2RlOiBjb2RlVG9TdHJpbmcoZXJyb3IuY29kZSksXG4gICAgfTtcbiAgICBpZiAoZXJyb3IucmF3TWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG8ubWVzc2FnZSA9IGVycm9yLnJhd01lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChlcnJvci5kZXRhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgby5kZXRhaWxzID0gZXJyb3IuZGV0YWlsc1xuICAgICAgICAgICAgLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChcImdldFR5cGVcIiBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHZhbHVlLmdldFR5cGUoKS50eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnRvQmluYXJ5KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpLmRlYnVnID0gdmFsdWUudG9Kc29uKGpzb25Xcml0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkZWxpYmVyYXRlbHkgaWdub3JlIGVycm9ycyB0aGF0IG1heSBvY2N1ciB3aGVuIHNlcmlhbGl6aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgbWVzc2FnZSB0byBKU09OICh0aGUgbWVzc2FnZSBjb250YWlucyBhbiBBbnkpLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmF0aW9uYWxlIGlzIHRoYXQgd2UgYXJlIG9ubHkgdHJ5aW5nIHRvIHByb3ZpZGUgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVidWcgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoX2EpID0+IHtcbiAgICAgICAgICAgIHZhciB7IHZhbHVlIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widmFsdWVcIl0pO1xuICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7IHZhbHVlOiBwcm90b0Jhc2U2NC5lbmModmFsdWUpLnJlcGxhY2UoLz0rJC8sIFwiXCIpIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGVycm9yIHRvIEpTT04uIFRoaXMgY2FsbHMgZXJyb3JUb0pzb24oKSwgYnV0IHN0cmluZ2lmaWVzXG4gKiB0aGUgcmVzdWx0LCBhbmQgY29udmVydHMgaXQgaW50byBhIFVJbnQ4QXJyYXkuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvclRvSnNvbkJ5dGVzKGVycm9yLCBqc29uV3JpdGVPcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBqc29uT2JqZWN0ID0gZXJyb3JUb0pzb24oZXJyb3IsIGpzb25Xcml0ZU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoanNvbk9iamVjdCk7XG4gICAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoanNvblN0cmluZyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IG0gPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYGZhaWxlZCB0byBzZXJpYWxpemUgQ29ubmVjdCBFcnJvcjogJHttfWAsIENvZGUuSW50ZXJuYWwpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/error-json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/get-request.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/get-request.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transformConnectPostToGetRequest: () => (/* binding */ transformConnectPostToGetRequest)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(ssr)/./node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js\");\n/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./headers.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\nconst contentTypePrefix = \"application/\";\nfunction encodeMessageForUrl(message, useBase64) {\n    if (useBase64) {\n        // TODO(jchadwick-buf): Three regex replaces seems excessive.\n        // Can we make protoBase64.enc more flexible?\n        return _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_0__.protoBase64\n            .enc(message)\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\")\n            .replace(/=+$/, \"\");\n    }\n    else {\n        return encodeURIComponent(new TextDecoder().decode(message));\n    }\n}\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformConnectPostToGetRequest(request, message, useBase64) {\n    let query = `?connect=v${_version_js__WEBPACK_IMPORTED_MODULE_1__.protocolVersion}`;\n    const contentType = request.header.get(_headers_js__WEBPACK_IMPORTED_MODULE_2__.headerContentType);\n    if ((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(contentTypePrefix)) === 0) {\n        query +=\n            \"&encoding=\" +\n                encodeURIComponent(contentType.slice(contentTypePrefix.length));\n    }\n    const compression = request.header.get(_headers_js__WEBPACK_IMPORTED_MODULE_2__.headerUnaryEncoding);\n    if (compression !== null && compression !== \"identity\") {\n        query += \"&compression=\" + encodeURIComponent(compression);\n        // Force base64 for compressed payloads.\n        useBase64 = true;\n    }\n    if (useBase64) {\n        query += \"&base64=1\";\n    }\n    query += \"&message=\" + encodeMessageForUrl(message, useBase64);\n    const url = request.url + query;\n    // Omit headers that are not used for unary GET requests.\n    const header = new Headers(request.header);\n    [\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerProtocolVersion,\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerContentType,\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerUnaryContentLength,\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerUnaryEncoding,\n        _headers_js__WEBPACK_IMPORTED_MODULE_2__.headerUnaryAcceptEncoding,\n    ].forEach((h) => header.delete(h));\n    return Object.assign(Object.assign({}, request), { init: Object.assign(Object.assign({}, request.init), { method: \"GET\" }), url,\n        header });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2dldC1yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRDtBQUN5RjtBQUNwRztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2Qix3REFBZSxDQUFDO0FBQzdDLDJDQUEyQywwREFBaUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0REFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFxQjtBQUM3QixRQUFRLDBEQUFpQjtBQUN6QixRQUFRLGlFQUF3QjtBQUNoQyxRQUFRLDREQUFtQjtBQUMzQixRQUFRLGtFQUF5QjtBQUNqQztBQUNBLHlDQUF5QyxjQUFjLG9DQUFvQyxtQkFBbUIsZUFBZTtBQUM3SCxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvZ2V0LXJlcXVlc3QuanM/ZGMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWVzc2FnZSwgcHJvdG9CYXNlNjQgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmXCI7XG5pbXBvcnQgeyBoZWFkZXJDb250ZW50VHlwZSwgaGVhZGVyUHJvdG9jb2xWZXJzaW9uLCBoZWFkZXJVbmFyeUFjY2VwdEVuY29kaW5nLCBoZWFkZXJVbmFyeUNvbnRlbnRMZW5ndGgsIGhlYWRlclVuYXJ5RW5jb2RpbmcsIH0gZnJvbSBcIi4vaGVhZGVycy5qc1wiO1xuaW1wb3J0IHsgcHJvdG9jb2xWZXJzaW9uIH0gZnJvbSBcIi4vdmVyc2lvbi5qc1wiO1xuY29uc3QgY29udGVudFR5cGVQcmVmaXggPSBcImFwcGxpY2F0aW9uL1wiO1xuZnVuY3Rpb24gZW5jb2RlTWVzc2FnZUZvclVybChtZXNzYWdlLCB1c2VCYXNlNjQpIHtcbiAgICBpZiAodXNlQmFzZTY0KSB7XG4gICAgICAgIC8vIFRPRE8oamNoYWR3aWNrLWJ1Zik6IFRocmVlIHJlZ2V4IHJlcGxhY2VzIHNlZW1zIGV4Y2Vzc2l2ZS5cbiAgICAgICAgLy8gQ2FuIHdlIG1ha2UgcHJvdG9CYXNlNjQuZW5jIG1vcmUgZmxleGlibGU/XG4gICAgICAgIHJldHVybiBwcm90b0Jhc2U2NFxuICAgICAgICAgICAgLmVuYyhtZXNzYWdlKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCBcIi1cIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgXCJfXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvPSskLywgXCJcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtZXNzYWdlKSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUNvbm5lY3RQb3N0VG9HZXRSZXF1ZXN0KHJlcXVlc3QsIG1lc3NhZ2UsIHVzZUJhc2U2NCkge1xuICAgIGxldCBxdWVyeSA9IGA/Y29ubmVjdD12JHtwcm90b2NvbFZlcnNpb259YDtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVyLmdldChoZWFkZXJDb250ZW50VHlwZSk7XG4gICAgaWYgKChjb250ZW50VHlwZSA9PT0gbnVsbCB8fCBjb250ZW50VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudFR5cGUuaW5kZXhPZihjb250ZW50VHlwZVByZWZpeCkpID09PSAwKSB7XG4gICAgICAgIHF1ZXJ5ICs9XG4gICAgICAgICAgICBcIiZlbmNvZGluZz1cIiArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGNvbnRlbnRUeXBlLnNsaWNlKGNvbnRlbnRUeXBlUHJlZml4Lmxlbmd0aCkpO1xuICAgIH1cbiAgICBjb25zdCBjb21wcmVzc2lvbiA9IHJlcXVlc3QuaGVhZGVyLmdldChoZWFkZXJVbmFyeUVuY29kaW5nKTtcbiAgICBpZiAoY29tcHJlc3Npb24gIT09IG51bGwgJiYgY29tcHJlc3Npb24gIT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgICBxdWVyeSArPSBcIiZjb21wcmVzc2lvbj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChjb21wcmVzc2lvbik7XG4gICAgICAgIC8vIEZvcmNlIGJhc2U2NCBmb3IgY29tcHJlc3NlZCBwYXlsb2Fkcy5cbiAgICAgICAgdXNlQmFzZTY0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVzZUJhc2U2NCkge1xuICAgICAgICBxdWVyeSArPSBcIiZiYXNlNjQ9MVwiO1xuICAgIH1cbiAgICBxdWVyeSArPSBcIiZtZXNzYWdlPVwiICsgZW5jb2RlTWVzc2FnZUZvclVybChtZXNzYWdlLCB1c2VCYXNlNjQpO1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3QudXJsICsgcXVlcnk7XG4gICAgLy8gT21pdCBoZWFkZXJzIHRoYXQgYXJlIG5vdCB1c2VkIGZvciB1bmFyeSBHRVQgcmVxdWVzdHMuXG4gICAgY29uc3QgaGVhZGVyID0gbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXIpO1xuICAgIFtcbiAgICAgICAgaGVhZGVyUHJvdG9jb2xWZXJzaW9uLFxuICAgICAgICBoZWFkZXJDb250ZW50VHlwZSxcbiAgICAgICAgaGVhZGVyVW5hcnlDb250ZW50TGVuZ3RoLFxuICAgICAgICBoZWFkZXJVbmFyeUVuY29kaW5nLFxuICAgICAgICBoZWFkZXJVbmFyeUFjY2VwdEVuY29kaW5nLFxuICAgIF0uZm9yRWFjaCgoaCkgPT4gaGVhZGVyLmRlbGV0ZShoKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaW5pdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0LmluaXQpLCB7IG1ldGhvZDogXCJHRVRcIiB9KSwgdXJsLFxuICAgICAgICBoZWFkZXIgfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/get-request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headerContentType: () => (/* binding */ headerContentType),\n/* harmony export */   headerProtocolVersion: () => (/* binding */ headerProtocolVersion),\n/* harmony export */   headerStreamAcceptEncoding: () => (/* binding */ headerStreamAcceptEncoding),\n/* harmony export */   headerStreamEncoding: () => (/* binding */ headerStreamEncoding),\n/* harmony export */   headerTimeout: () => (/* binding */ headerTimeout),\n/* harmony export */   headerUnaryAcceptEncoding: () => (/* binding */ headerUnaryAcceptEncoding),\n/* harmony export */   headerUnaryContentLength: () => (/* binding */ headerUnaryContentLength),\n/* harmony export */   headerUnaryEncoding: () => (/* binding */ headerUnaryEncoding),\n/* harmony export */   headerUserAgent: () => (/* binding */ headerUserAgent)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nconst headerContentType = \"Content-Type\";\nconst headerUnaryContentLength = \"Content-Length\";\nconst headerUnaryEncoding = \"Content-Encoding\";\nconst headerStreamEncoding = \"Connect-Content-Encoding\";\nconst headerUnaryAcceptEncoding = \"Accept-Encoding\";\nconst headerStreamAcceptEncoding = \"Connect-Accept-Encoding\";\nconst headerTimeout = \"Connect-Timeout-Ms\";\nconst headerProtocolVersion = \"Connect-Protocol-Version\";\nconst headerUserAgent = \"User-Agent\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2hlYWRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvaGVhZGVycy5qcz8zZGNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgY29uc3QgaGVhZGVyQ29udGVudFR5cGUgPSBcIkNvbnRlbnQtVHlwZVwiO1xuZXhwb3J0IGNvbnN0IGhlYWRlclVuYXJ5Q29udGVudExlbmd0aCA9IFwiQ29udGVudC1MZW5ndGhcIjtcbmV4cG9ydCBjb25zdCBoZWFkZXJVbmFyeUVuY29kaW5nID0gXCJDb250ZW50LUVuY29kaW5nXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyU3RyZWFtRW5jb2RpbmcgPSBcIkNvbm5lY3QtQ29udGVudC1FbmNvZGluZ1wiO1xuZXhwb3J0IGNvbnN0IGhlYWRlclVuYXJ5QWNjZXB0RW5jb2RpbmcgPSBcIkFjY2VwdC1FbmNvZGluZ1wiO1xuZXhwb3J0IGNvbnN0IGhlYWRlclN0cmVhbUFjY2VwdEVuY29kaW5nID0gXCJDb25uZWN0LUFjY2VwdC1FbmNvZGluZ1wiO1xuZXhwb3J0IGNvbnN0IGhlYWRlclRpbWVvdXQgPSBcIkNvbm5lY3QtVGltZW91dC1Nc1wiO1xuZXhwb3J0IGNvbnN0IGhlYWRlclByb3RvY29sVmVyc2lvbiA9IFwiQ29ubmVjdC1Qcm90b2NvbC1WZXJzaW9uXCI7XG5leHBvcnQgY29uc3QgaGVhZGVyVXNlckFnZW50ID0gXCJVc2VyLUFnZW50XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/http-status.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/http-status.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codeFromHttpStatus: () => (/* binding */ codeFromHttpStatus),\n/* harmony export */   codeToHttpStatus: () => (/* binding */ codeToHttpStatus)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Determine the Connect error code for the given HTTP status code.\n * See https://connectrpc.com/docs/protocol/#http-to-error-code\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeFromHttpStatus(httpStatus) {\n    switch (httpStatus) {\n        case 400: // Bad Request\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Internal;\n        case 401: // Unauthorized\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unauthenticated;\n        case 403: // Forbidden\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.PermissionDenied;\n        case 404: // Not Found\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unimplemented;\n        case 429: // Too Many Requests\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable;\n        case 502: // Bad Gateway\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable;\n        case 503: // Service Unavailable\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable;\n        case 504: // Gateway Timeout\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable;\n        default:\n            return _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unknown;\n    }\n}\n/**\n * Returns a HTTP status code for the given Connect code.\n * See https://connectrpc.com/docs/protocol#error-codes\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction codeToHttpStatus(code) {\n    switch (code) {\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Canceled:\n            return 499; // Client Closed Request\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unknown:\n            return 500; // Internal Server Error\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.InvalidArgument:\n            return 400; // Bad Request\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.DeadlineExceeded:\n            return 504; // Gateway Timeout\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.NotFound:\n            return 404; // Not Found\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.AlreadyExists:\n            return 409; // Conflict\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.PermissionDenied:\n            return 403; // Forbidden\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.ResourceExhausted:\n            return 429; // Too Many Requests\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.FailedPrecondition:\n            return 400; // Bad Request\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Aborted:\n            return 409; // Conflict\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.OutOfRange:\n            return 400; // Bad Request\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unimplemented:\n            return 501; // Not Implemented\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Internal:\n            return 500; // Internal Server Error\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unavailable:\n            return 503; // Service Unavailable\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.DataLoss:\n            return 500; // Internal Server Error\n        case _code_js__WEBPACK_IMPORTED_MODULE_0__.Code.Unauthenticated:\n            return 401; // Unauthorized\n        default:\n            return 500; // same as CodeUnknown\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L2h0dHAtc3RhdHVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBLG1CQUFtQiwwQ0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCLGFBQWEsMENBQUk7QUFDakIsd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvaHR0cC1zdGF0dXMuanM/M2Q4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG4vKipcbiAqIERldGVybWluZSB0aGUgQ29ubmVjdCBlcnJvciBjb2RlIGZvciB0aGUgZ2l2ZW4gSFRUUCBzdGF0dXMgY29kZS5cbiAqIFNlZSBodHRwczovL2Nvbm5lY3RycGMuY29tL2RvY3MvcHJvdG9jb2wvI2h0dHAtdG8tZXJyb3ItY29kZVxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29kZUZyb21IdHRwU3RhdHVzKGh0dHBTdGF0dXMpIHtcbiAgICBzd2l0Y2ggKGh0dHBTdGF0dXMpIHtcbiAgICAgICAgY2FzZSA0MDA6IC8vIEJhZCBSZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gQ29kZS5JbnRlcm5hbDtcbiAgICAgICAgY2FzZSA0MDE6IC8vIFVuYXV0aG9yaXplZFxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVW5hdXRoZW50aWNhdGVkO1xuICAgICAgICBjYXNlIDQwMzogLy8gRm9yYmlkZGVuXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5QZXJtaXNzaW9uRGVuaWVkO1xuICAgICAgICBjYXNlIDQwNDogLy8gTm90IEZvdW5kXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VbmltcGxlbWVudGVkO1xuICAgICAgICBjYXNlIDQyOTogLy8gVG9vIE1hbnkgUmVxdWVzdHNcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVuYXZhaWxhYmxlO1xuICAgICAgICBjYXNlIDUwMjogLy8gQmFkIEdhdGV3YXlcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVuYXZhaWxhYmxlO1xuICAgICAgICBjYXNlIDUwMzogLy8gU2VydmljZSBVbmF2YWlsYWJsZVxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVW5hdmFpbGFibGU7XG4gICAgICAgIGNhc2UgNTA0OiAvLyBHYXRld2F5IFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlVuYXZhaWxhYmxlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVW5rbm93bjtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBIVFRQIHN0YXR1cyBjb2RlIGZvciB0aGUgZ2l2ZW4gQ29ubmVjdCBjb2RlLlxuICogU2VlIGh0dHBzOi8vY29ubmVjdHJwYy5jb20vZG9jcy9wcm90b2NvbCNlcnJvci1jb2Rlc1xuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29kZVRvSHR0cFN0YXR1cyhjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgQ29kZS5DYW5jZWxlZDpcbiAgICAgICAgICAgIHJldHVybiA0OTk7IC8vIENsaWVudCBDbG9zZWQgUmVxdWVzdFxuICAgICAgICBjYXNlIENvZGUuVW5rbm93bjpcbiAgICAgICAgICAgIHJldHVybiA1MDA7IC8vIEludGVybmFsIFNlcnZlciBFcnJvclxuICAgICAgICBjYXNlIENvZGUuSW52YWxpZEFyZ3VtZW50OlxuICAgICAgICAgICAgcmV0dXJuIDQwMDsgLy8gQmFkIFJlcXVlc3RcbiAgICAgICAgY2FzZSBDb2RlLkRlYWRsaW5lRXhjZWVkZWQ6XG4gICAgICAgICAgICByZXR1cm4gNTA0OyAvLyBHYXRld2F5IFRpbWVvdXRcbiAgICAgICAgY2FzZSBDb2RlLk5vdEZvdW5kOlxuICAgICAgICAgICAgcmV0dXJuIDQwNDsgLy8gTm90IEZvdW5kXG4gICAgICAgIGNhc2UgQ29kZS5BbHJlYWR5RXhpc3RzOlxuICAgICAgICAgICAgcmV0dXJuIDQwOTsgLy8gQ29uZmxpY3RcbiAgICAgICAgY2FzZSBDb2RlLlBlcm1pc3Npb25EZW5pZWQ6XG4gICAgICAgICAgICByZXR1cm4gNDAzOyAvLyBGb3JiaWRkZW5cbiAgICAgICAgY2FzZSBDb2RlLlJlc291cmNlRXhoYXVzdGVkOlxuICAgICAgICAgICAgcmV0dXJuIDQyOTsgLy8gVG9vIE1hbnkgUmVxdWVzdHNcbiAgICAgICAgY2FzZSBDb2RlLkZhaWxlZFByZWNvbmRpdGlvbjpcbiAgICAgICAgICAgIHJldHVybiA0MDA7IC8vIEJhZCBSZXF1ZXN0XG4gICAgICAgIGNhc2UgQ29kZS5BYm9ydGVkOlxuICAgICAgICAgICAgcmV0dXJuIDQwOTsgLy8gQ29uZmxpY3RcbiAgICAgICAgY2FzZSBDb2RlLk91dE9mUmFuZ2U6XG4gICAgICAgICAgICByZXR1cm4gNDAwOyAvLyBCYWQgUmVxdWVzdFxuICAgICAgICBjYXNlIENvZGUuVW5pbXBsZW1lbnRlZDpcbiAgICAgICAgICAgIHJldHVybiA1MDE7IC8vIE5vdCBJbXBsZW1lbnRlZFxuICAgICAgICBjYXNlIENvZGUuSW50ZXJuYWw6XG4gICAgICAgICAgICByZXR1cm4gNTAwOyAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcbiAgICAgICAgY2FzZSBDb2RlLlVuYXZhaWxhYmxlOlxuICAgICAgICAgICAgcmV0dXJuIDUwMzsgLy8gU2VydmljZSBVbmF2YWlsYWJsZVxuICAgICAgICBjYXNlIENvZGUuRGF0YUxvc3M6XG4gICAgICAgICAgICByZXR1cm4gNTAwOyAvLyBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcbiAgICAgICAgY2FzZSBDb2RlLlVuYXV0aGVudGljYXRlZDpcbiAgICAgICAgICAgIHJldHVybiA0MDE7IC8vIFVuYXV0aG9yaXplZFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDUwMDsgLy8gc2FtZSBhcyBDb2RlVW5rbm93blxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/http-status.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/query-params.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/query-params.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   paramBase64: () => (/* binding */ paramBase64),\n/* harmony export */   paramCompression: () => (/* binding */ paramCompression),\n/* harmony export */   paramConnectVersion: () => (/* binding */ paramConnectVersion),\n/* harmony export */   paramEncoding: () => (/* binding */ paramEncoding),\n/* harmony export */   paramMessage: () => (/* binding */ paramMessage)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nconst paramConnectVersion = \"connect\";\nconst paramEncoding = \"encoding\";\nconst paramCompression = \"compression\";\nconst paramBase64 = \"base64\";\nconst paramMessage = \"message\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L3F1ZXJ5LXBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC9xdWVyeS1wYXJhbXMuanM/MWZmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcmFtQ29ubmVjdFZlcnNpb24gPSBcImNvbm5lY3RcIjtcbmV4cG9ydCBjb25zdCBwYXJhbUVuY29kaW5nID0gXCJlbmNvZGluZ1wiO1xuZXhwb3J0IGNvbnN0IHBhcmFtQ29tcHJlc3Npb24gPSBcImNvbXByZXNzaW9uXCI7XG5leHBvcnQgY29uc3QgcGFyYW1CYXNlNjQgPSBcImJhc2U2NFwiO1xuZXhwb3J0IGNvbnN0IHBhcmFtTWVzc2FnZSA9IFwibWVzc2FnZVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/query-params.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/request-header.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/request-header.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requestHeader: () => (/* binding */ requestHeader),\n/* harmony export */   requestHeaderWithCompression: () => (/* binding */ requestHeaderWithCompression)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(ssr)/./node_modules/@bufbuild/protobuf/dist/esm/service-type.js\");\n/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./headers.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js\");\n/* harmony import */ var _content_type_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./content-type.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * Creates headers for a Connect request.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requestHeader(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent) {\n    const result = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});\n    if (timeoutMs !== undefined) {\n        result.set(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerTimeout, `${timeoutMs}`);\n    }\n    result.set(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerContentType, methodKind == _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.MethodKind.Unary\n        ? useBinaryFormat\n            ? _content_type_js__WEBPACK_IMPORTED_MODULE_2__.contentTypeUnaryProto\n            : _content_type_js__WEBPACK_IMPORTED_MODULE_2__.contentTypeUnaryJson\n        : useBinaryFormat\n            ? _content_type_js__WEBPACK_IMPORTED_MODULE_2__.contentTypeStreamProto\n            : _content_type_js__WEBPACK_IMPORTED_MODULE_2__.contentTypeStreamJson);\n    result.set(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerProtocolVersion, _version_js__WEBPACK_IMPORTED_MODULE_3__.protocolVersion);\n    if (setUserAgent && !result.has(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUserAgent)) {\n        result.set(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUserAgent, \"connect-es/1.7.0\");\n    }\n    return result;\n}\n/**\n * Creates headers for a Connect request with compression.\n *\n * Note that we always set the Content-Encoding header for unary methods.\n * It is up to the caller to decide whether to apply compression - and remove\n * the header if compression is not used, for example because the payload is\n * too small to make compression effective.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requestHeaderWithCompression(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, acceptCompression, sendCompression, setUserAgent) {\n    const result = requestHeader(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent);\n    if (sendCompression != null) {\n        const name = methodKind == _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.MethodKind.Unary\n            ? _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUnaryEncoding\n            : _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerStreamEncoding;\n        result.set(name, sendCompression.name);\n    }\n    if (acceptCompression.length > 0) {\n        const name = methodKind == _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_1__.MethodKind.Unary\n            ? _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUnaryAcceptEncoding\n            : _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerStreamAcceptEncoding;\n        result.set(name, acceptCompression.map((c) => c.name).join(\",\"));\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L3JlcXVlc3QtaGVhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dEO0FBQzJKO0FBQzVKO0FBQ2lGO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHdIQUF3SDtBQUN4SDtBQUNBLG1CQUFtQixzREFBYSxLQUFLLFVBQVU7QUFDL0M7QUFDQSxlQUFlLDBEQUFpQixnQkFBZ0IsMERBQVU7QUFDMUQ7QUFDQSxjQUFjLG1FQUFxQjtBQUNuQyxjQUFjLGtFQUFvQjtBQUNsQztBQUNBLGNBQWMsb0VBQXNCO0FBQ3BDLGNBQWMsbUVBQXFCO0FBQ25DLGVBQWUsOERBQXFCLEVBQUUsd0RBQWU7QUFDckQsb0NBQW9DLHdEQUFlO0FBQ25ELG1CQUFtQix3REFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQywwREFBVTtBQUM3QyxjQUFjLDREQUFtQjtBQUNqQyxjQUFjLDZEQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMERBQVU7QUFDN0MsY0FBYyxrRUFBeUI7QUFDdkMsY0FBYyxtRUFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvcmVxdWVzdC1oZWFkZXIuanM/NGI3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWV0aG9kS2luZCB9IGZyb20gXCJAYnVmYnVpbGQvcHJvdG9idWZcIjtcbmltcG9ydCB7IGhlYWRlckNvbnRlbnRUeXBlLCBoZWFkZXJTdHJlYW1BY2NlcHRFbmNvZGluZywgaGVhZGVyU3RyZWFtRW5jb2RpbmcsIGhlYWRlclVuYXJ5QWNjZXB0RW5jb2RpbmcsIGhlYWRlclVuYXJ5RW5jb2RpbmcsIGhlYWRlclRpbWVvdXQsIGhlYWRlclByb3RvY29sVmVyc2lvbiwgaGVhZGVyVXNlckFnZW50LCB9IGZyb20gXCIuL2hlYWRlcnMuanNcIjtcbmltcG9ydCB7IHByb3RvY29sVmVyc2lvbiB9IGZyb20gXCIuL3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IGNvbnRlbnRUeXBlU3RyZWFtSnNvbiwgY29udGVudFR5cGVTdHJlYW1Qcm90bywgY29udGVudFR5cGVVbmFyeUpzb24sIGNvbnRlbnRUeXBlVW5hcnlQcm90bywgfSBmcm9tIFwiLi9jb250ZW50LXR5cGUuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBoZWFkZXJzIGZvciBhIENvbm5lY3QgcmVxdWVzdC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RIZWFkZXIobWV0aG9kS2luZCwgdXNlQmluYXJ5Rm9ybWF0LCB0aW1lb3V0TXMsIHVzZXJQcm92aWRlZEhlYWRlcnMsIHNldFVzZXJBZ2VudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBIZWFkZXJzKHVzZXJQcm92aWRlZEhlYWRlcnMgIT09IG51bGwgJiYgdXNlclByb3ZpZGVkSGVhZGVycyAhPT0gdm9pZCAwID8gdXNlclByb3ZpZGVkSGVhZGVycyA6IHt9KTtcbiAgICBpZiAodGltZW91dE1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnNldChoZWFkZXJUaW1lb3V0LCBgJHt0aW1lb3V0TXN9YCk7XG4gICAgfVxuICAgIHJlc3VsdC5zZXQoaGVhZGVyQ29udGVudFR5cGUsIG1ldGhvZEtpbmQgPT0gTWV0aG9kS2luZC5VbmFyeVxuICAgICAgICA/IHVzZUJpbmFyeUZvcm1hdFxuICAgICAgICAgICAgPyBjb250ZW50VHlwZVVuYXJ5UHJvdG9cbiAgICAgICAgICAgIDogY29udGVudFR5cGVVbmFyeUpzb25cbiAgICAgICAgOiB1c2VCaW5hcnlGb3JtYXRcbiAgICAgICAgICAgID8gY29udGVudFR5cGVTdHJlYW1Qcm90b1xuICAgICAgICAgICAgOiBjb250ZW50VHlwZVN0cmVhbUpzb24pO1xuICAgIHJlc3VsdC5zZXQoaGVhZGVyUHJvdG9jb2xWZXJzaW9uLCBwcm90b2NvbFZlcnNpb24pO1xuICAgIGlmIChzZXRVc2VyQWdlbnQgJiYgIXJlc3VsdC5oYXMoaGVhZGVyVXNlckFnZW50KSkge1xuICAgICAgICByZXN1bHQuc2V0KGhlYWRlclVzZXJBZ2VudCwgXCJjb25uZWN0LWVzLzEuNy4wXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGhlYWRlcnMgZm9yIGEgQ29ubmVjdCByZXF1ZXN0IHdpdGggY29tcHJlc3Npb24uXG4gKlxuICogTm90ZSB0aGF0IHdlIGFsd2F5cyBzZXQgdGhlIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyIGZvciB1bmFyeSBtZXRob2RzLlxuICogSXQgaXMgdXAgdG8gdGhlIGNhbGxlciB0byBkZWNpZGUgd2hldGhlciB0byBhcHBseSBjb21wcmVzc2lvbiAtIGFuZCByZW1vdmVcbiAqIHRoZSBoZWFkZXIgaWYgY29tcHJlc3Npb24gaXMgbm90IHVzZWQsIGZvciBleGFtcGxlIGJlY2F1c2UgdGhlIHBheWxvYWQgaXNcbiAqIHRvbyBzbWFsbCB0byBtYWtlIGNvbXByZXNzaW9uIGVmZmVjdGl2ZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RIZWFkZXJXaXRoQ29tcHJlc3Npb24obWV0aG9kS2luZCwgdXNlQmluYXJ5Rm9ybWF0LCB0aW1lb3V0TXMsIHVzZXJQcm92aWRlZEhlYWRlcnMsIGFjY2VwdENvbXByZXNzaW9uLCBzZW5kQ29tcHJlc3Npb24sIHNldFVzZXJBZ2VudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlcXVlc3RIZWFkZXIobWV0aG9kS2luZCwgdXNlQmluYXJ5Rm9ybWF0LCB0aW1lb3V0TXMsIHVzZXJQcm92aWRlZEhlYWRlcnMsIHNldFVzZXJBZ2VudCk7XG4gICAgaWYgKHNlbmRDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBtZXRob2RLaW5kID09IE1ldGhvZEtpbmQuVW5hcnlcbiAgICAgICAgICAgID8gaGVhZGVyVW5hcnlFbmNvZGluZ1xuICAgICAgICAgICAgOiBoZWFkZXJTdHJlYW1FbmNvZGluZztcbiAgICAgICAgcmVzdWx0LnNldChuYW1lLCBzZW5kQ29tcHJlc3Npb24ubmFtZSk7XG4gICAgfVxuICAgIGlmIChhY2NlcHRDb21wcmVzc2lvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBtZXRob2RLaW5kID09IE1ldGhvZEtpbmQuVW5hcnlcbiAgICAgICAgICAgID8gaGVhZGVyVW5hcnlBY2NlcHRFbmNvZGluZ1xuICAgICAgICAgICAgOiBoZWFkZXJTdHJlYW1BY2NlcHRFbmNvZGluZztcbiAgICAgICAgcmVzdWx0LnNldChuYW1lLCBhY2NlcHRDb21wcmVzc2lvbi5tYXAoKGMpID0+IGMubmFtZSkuam9pbihcIixcIikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/request-header.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trailerDemux: () => (/* binding */ trailerDemux),\n/* harmony export */   trailerMux: () => (/* binding */ trailerMux)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * In unary RPCs, Connect transports trailing metadata as response header\n * fields, prefixed with \"trailer-\".\n *\n * This function demuxes headers and trailers into two separate Headers\n * objects.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction trailerDemux(header) {\n    const h = new Headers(), t = new Headers();\n    header.forEach((value, key) => {\n        if (key.toLowerCase().startsWith(\"trailer-\")) {\n            t.append(key.substring(8), value);\n        }\n        else {\n            h.append(key, value);\n        }\n    });\n    return [h, t];\n}\n/**\n * In unary RPCs, Connect transports trailing metadata as response header\n * fields, prefixed with \"trailer-\".\n *\n * This function muxes a header and a trailer into a single Headers object.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction trailerMux(header, trailer) {\n    const h = new Headers(header);\n    trailer.forEach((value, key) => {\n        h.append(`trailer-${key}`, value);\n    });\n    return h;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L3RyYWlsZXItbXV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC90cmFpbGVyLW11eC5qcz82OWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEluIHVuYXJ5IFJQQ3MsIENvbm5lY3QgdHJhbnNwb3J0cyB0cmFpbGluZyBtZXRhZGF0YSBhcyByZXNwb25zZSBoZWFkZXJcbiAqIGZpZWxkcywgcHJlZml4ZWQgd2l0aCBcInRyYWlsZXItXCIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZW11eGVzIGhlYWRlcnMgYW5kIHRyYWlsZXJzIGludG8gdHdvIHNlcGFyYXRlIEhlYWRlcnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFpbGVyRGVtdXgoaGVhZGVyKSB7XG4gICAgY29uc3QgaCA9IG5ldyBIZWFkZXJzKCksIHQgPSBuZXcgSGVhZGVycygpO1xuICAgIGhlYWRlci5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwidHJhaWxlci1cIikpIHtcbiAgICAgICAgICAgIHQuYXBwZW5kKGtleS5zdWJzdHJpbmcoOCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGguYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtoLCB0XTtcbn1cbi8qKlxuICogSW4gdW5hcnkgUlBDcywgQ29ubmVjdCB0cmFuc3BvcnRzIHRyYWlsaW5nIG1ldGFkYXRhIGFzIHJlc3BvbnNlIGhlYWRlclxuICogZmllbGRzLCBwcmVmaXhlZCB3aXRoIFwidHJhaWxlci1cIi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG11eGVzIGEgaGVhZGVyIGFuZCBhIHRyYWlsZXIgaW50byBhIHNpbmdsZSBIZWFkZXJzIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWlsZXJNdXgoaGVhZGVyLCB0cmFpbGVyKSB7XG4gICAgY29uc3QgaCA9IG5ldyBIZWFkZXJzKGhlYWRlcik7XG4gICAgdHJhaWxlci5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGguYXBwZW5kKGB0cmFpbGVyLSR7a2V5fWAsIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/validate-response.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/validate-response.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateResponse: () => (/* binding */ validateResponse),\n/* harmony export */   validateResponseWithCompression: () => (/* binding */ validateResponseWithCompression)\n/* harmony export */ });\n/* harmony import */ var _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @bufbuild/protobuf */ \"(ssr)/./node_modules/@bufbuild/protobuf/dist/esm/service-type.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _http_status_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./http-status.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/http-status.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _content_type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./content-type.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/content-type.js\");\n/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./headers.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n\n\n/**\n * Validates response status and header for the Connect protocol.\n * Throws a ConnectError if the header indicates an error, or if\n * the content type is unexpected, with the following exception:\n * For unary RPCs with an HTTP error status, this returns an error\n * derived from the HTTP status instead of throwing it, giving an\n * implementation a chance to parse a Connect error from the wire.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction validateResponse(methodKind, useBinaryFormat, status, headers) {\n    const mimeType = headers.get(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerContentType);\n    const parsedType = (0,_content_type_js__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(mimeType);\n    if (status !== 200) {\n        const errorFromStatus = new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(`HTTP ${status}`, (0,_http_status_js__WEBPACK_IMPORTED_MODULE_3__.codeFromHttpStatus)(status), headers);\n        // If parsedType is defined and it is not binary, then this is a unary JSON response\n        if (methodKind == _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_4__.MethodKind.Unary && parsedType && !parsedType.binary) {\n            return { isUnaryError: true, unaryError: errorFromStatus };\n        }\n        throw errorFromStatus;\n    }\n    const allowedContentType = {\n        binary: useBinaryFormat,\n        stream: methodKind !== _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_4__.MethodKind.Unary,\n    };\n    if ((parsedType === null || parsedType === void 0 ? void 0 : parsedType.binary) !== allowedContentType.binary ||\n        parsedType.stream !== allowedContentType.stream) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(`unsupported content type ${mimeType}`, parsedType === undefined ? _code_js__WEBPACK_IMPORTED_MODULE_5__.Code.Unknown : _code_js__WEBPACK_IMPORTED_MODULE_5__.Code.Internal, headers);\n    }\n    return { isUnaryError: false };\n}\n/**\n * Validates response status and header for the Connect protocol.\n * This function is identical to validateResponse(), but also verifies\n * that a given encoding header is acceptable.\n *\n * @private\n */\nfunction validateResponseWithCompression(methodKind, acceptCompression, useBinaryFormat, status, headers) {\n    let compression;\n    const encoding = headers.get(methodKind == _bufbuild_protobuf__WEBPACK_IMPORTED_MODULE_4__.MethodKind.Unary ? _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerUnaryEncoding : _headers_js__WEBPACK_IMPORTED_MODULE_0__.headerStreamEncoding);\n    if (encoding != null && encoding.toLowerCase() !== \"identity\") {\n        compression = acceptCompression.find((c) => c.name === encoding);\n        if (!compression) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_2__.ConnectError(`unsupported response encoding \"${encoding}\"`, _code_js__WEBPACK_IMPORTED_MODULE_5__.Code.Internal, headers);\n        }\n    }\n    return Object.assign({ compression }, validateResponse(methodKind, useBinaryFormat, status, headers));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L3ZhbGlkYXRlLXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDZDtBQUNvQjtBQUNIO0FBQ0U7QUFDd0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlDQUFpQywwREFBaUI7QUFDbEQsdUJBQXVCLGtFQUFnQjtBQUN2QztBQUNBLG9DQUFvQywyREFBWSxTQUFTLE9BQU8sR0FBRyxtRUFBa0I7QUFDckY7QUFDQSwwQkFBMEIsMERBQVU7QUFDcEMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMERBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFZLDZCQUE2QixTQUFTLDhCQUE4QiwwQ0FBSSxXQUFXLDBDQUFJO0FBQ3JIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsK0NBQStDLDBEQUFVLFNBQVMsNERBQW1CLEdBQUcsNkRBQW9CO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBWSxtQ0FBbUMsU0FBUyxJQUFJLDBDQUFJO0FBQ3RGO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wtY29ubmVjdC92YWxpZGF0ZS1yZXNwb25zZS5qcz8wM2FiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXRob2RLaW5kIH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1ZlwiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG5pbXBvcnQgeyBjb2RlRnJvbUh0dHBTdGF0dXMgfSBmcm9tIFwiLi9odHRwLXN0YXR1cy5qc1wiO1xuaW1wb3J0IHsgQ29ubmVjdEVycm9yIH0gZnJvbSBcIi4uL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IHBhcnNlQ29udGVudFR5cGUgfSBmcm9tIFwiLi9jb250ZW50LXR5cGUuanNcIjtcbmltcG9ydCB7IGhlYWRlckNvbnRlbnRUeXBlLCBoZWFkZXJTdHJlYW1FbmNvZGluZywgaGVhZGVyVW5hcnlFbmNvZGluZywgfSBmcm9tIFwiLi9oZWFkZXJzLmpzXCI7XG4vKipcbiAqIFZhbGlkYXRlcyByZXNwb25zZSBzdGF0dXMgYW5kIGhlYWRlciBmb3IgdGhlIENvbm5lY3QgcHJvdG9jb2wuXG4gKiBUaHJvd3MgYSBDb25uZWN0RXJyb3IgaWYgdGhlIGhlYWRlciBpbmRpY2F0ZXMgYW4gZXJyb3IsIG9yIGlmXG4gKiB0aGUgY29udGVudCB0eXBlIGlzIHVuZXhwZWN0ZWQsIHdpdGggdGhlIGZvbGxvd2luZyBleGNlcHRpb246XG4gKiBGb3IgdW5hcnkgUlBDcyB3aXRoIGFuIEhUVFAgZXJyb3Igc3RhdHVzLCB0aGlzIHJldHVybnMgYW4gZXJyb3JcbiAqIGRlcml2ZWQgZnJvbSB0aGUgSFRUUCBzdGF0dXMgaW5zdGVhZCBvZiB0aHJvd2luZyBpdCwgZ2l2aW5nIGFuXG4gKiBpbXBsZW1lbnRhdGlvbiBhIGNoYW5jZSB0byBwYXJzZSBhIENvbm5lY3QgZXJyb3IgZnJvbSB0aGUgd2lyZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2UobWV0aG9kS2luZCwgdXNlQmluYXJ5Rm9ybWF0LCBzdGF0dXMsIGhlYWRlcnMpIHtcbiAgICBjb25zdCBtaW1lVHlwZSA9IGhlYWRlcnMuZ2V0KGhlYWRlckNvbnRlbnRUeXBlKTtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gcGFyc2VDb250ZW50VHlwZShtaW1lVHlwZSk7XG4gICAgaWYgKHN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRnJvbVN0YXR1cyA9IG5ldyBDb25uZWN0RXJyb3IoYEhUVFAgJHtzdGF0dXN9YCwgY29kZUZyb21IdHRwU3RhdHVzKHN0YXR1cyksIGhlYWRlcnMpO1xuICAgICAgICAvLyBJZiBwYXJzZWRUeXBlIGlzIGRlZmluZWQgYW5kIGl0IGlzIG5vdCBiaW5hcnksIHRoZW4gdGhpcyBpcyBhIHVuYXJ5IEpTT04gcmVzcG9uc2VcbiAgICAgICAgaWYgKG1ldGhvZEtpbmQgPT0gTWV0aG9kS2luZC5VbmFyeSAmJiBwYXJzZWRUeXBlICYmICFwYXJzZWRUeXBlLmJpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNVbmFyeUVycm9yOiB0cnVlLCB1bmFyeUVycm9yOiBlcnJvckZyb21TdGF0dXMgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvckZyb21TdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93ZWRDb250ZW50VHlwZSA9IHtcbiAgICAgICAgYmluYXJ5OiB1c2VCaW5hcnlGb3JtYXQsXG4gICAgICAgIHN0cmVhbTogbWV0aG9kS2luZCAhPT0gTWV0aG9kS2luZC5VbmFyeSxcbiAgICB9O1xuICAgIGlmICgocGFyc2VkVHlwZSA9PT0gbnVsbCB8fCBwYXJzZWRUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZWRUeXBlLmJpbmFyeSkgIT09IGFsbG93ZWRDb250ZW50VHlwZS5iaW5hcnkgfHxcbiAgICAgICAgcGFyc2VkVHlwZS5zdHJlYW0gIT09IGFsbG93ZWRDb250ZW50VHlwZS5zdHJlYW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgdW5zdXBwb3J0ZWQgY29udGVudCB0eXBlICR7bWltZVR5cGV9YCwgcGFyc2VkVHlwZSA9PT0gdW5kZWZpbmVkID8gQ29kZS5Vbmtub3duIDogQ29kZS5JbnRlcm5hbCwgaGVhZGVycyk7XG4gICAgfVxuICAgIHJldHVybiB7IGlzVW5hcnlFcnJvcjogZmFsc2UgfTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHJlc3BvbnNlIHN0YXR1cyBhbmQgaGVhZGVyIGZvciB0aGUgQ29ubmVjdCBwcm90b2NvbC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaWRlbnRpY2FsIHRvIHZhbGlkYXRlUmVzcG9uc2UoKSwgYnV0IGFsc28gdmVyaWZpZXNcbiAqIHRoYXQgYSBnaXZlbiBlbmNvZGluZyBoZWFkZXIgaXMgYWNjZXB0YWJsZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVdpdGhDb21wcmVzc2lvbihtZXRob2RLaW5kLCBhY2NlcHRDb21wcmVzc2lvbiwgdXNlQmluYXJ5Rm9ybWF0LCBzdGF0dXMsIGhlYWRlcnMpIHtcbiAgICBsZXQgY29tcHJlc3Npb247XG4gICAgY29uc3QgZW5jb2RpbmcgPSBoZWFkZXJzLmdldChtZXRob2RLaW5kID09IE1ldGhvZEtpbmQuVW5hcnkgPyBoZWFkZXJVbmFyeUVuY29kaW5nIDogaGVhZGVyU3RyZWFtRW5jb2RpbmcpO1xuICAgIGlmIChlbmNvZGluZyAhPSBudWxsICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkgIT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgICBjb21wcmVzc2lvbiA9IGFjY2VwdENvbXByZXNzaW9uLmZpbmQoKGMpID0+IGMubmFtZSA9PT0gZW5jb2RpbmcpO1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGB1bnN1cHBvcnRlZCByZXNwb25zZSBlbmNvZGluZyBcIiR7ZW5jb2Rpbmd9XCJgLCBDb2RlLkludGVybmFsLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGNvbXByZXNzaW9uIH0sIHZhbGlkYXRlUmVzcG9uc2UobWV0aG9kS2luZCwgdXNlQmluYXJ5Rm9ybWF0LCBzdGF0dXMsIGhlYWRlcnMpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/validate-response.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   requireProtocolVersionHeader: () => (/* binding */ requireProtocolVersionHeader),\n/* harmony export */   requireProtocolVersionParam: () => (/* binding */ requireProtocolVersionParam)\n/* harmony export */ });\n/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./headers.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/headers.js\");\n/* harmony import */ var _query_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./query-params.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/query-params.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * The only know value for the header Connect-Protocol-Version.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst protocolVersion = \"1\";\n/**\n * Requires the Connect-Protocol-Version header to be present with the expected\n * value. Raises a ConnectError with Code.InvalidArgument otherwise.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requireProtocolVersionHeader(requestHeader) {\n    const v = requestHeader.get(_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerProtocolVersion);\n    if (v === null) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`missing required header: set ${_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerProtocolVersion} to \"${protocolVersion}\"`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n    }\n    else if (v !== protocolVersion) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`${_headers_js__WEBPACK_IMPORTED_MODULE_0__.headerProtocolVersion} must be \"${protocolVersion}\": got \"${v}\"`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n    }\n}\n/**\n * Requires the connect query parameter to be present with the expected value.\n * Raises a ConnectError with Code.InvalidArgument otherwise.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction requireProtocolVersionParam(queryParams) {\n    const v = queryParams.get(_query_params_js__WEBPACK_IMPORTED_MODULE_3__.paramConnectVersion);\n    if (v === null) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`missing required parameter: set ${_query_params_js__WEBPACK_IMPORTED_MODULE_3__.paramConnectVersion} to \"v${protocolVersion}\"`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n    }\n    else if (v !== `v${protocolVersion}`) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`${_query_params_js__WEBPACK_IMPORTED_MODULE_3__.paramConnectVersion} must be \"v${protocolVersion}\": got \"${v}\"`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC1jb25uZWN0L3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FEO0FBQ0c7QUFDTDtBQUNqQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdDQUFnQyw4REFBcUI7QUFDckQ7QUFDQSxrQkFBa0IsMkRBQVksaUNBQWlDLDhEQUFxQixFQUFFLE1BQU0sZ0JBQWdCLElBQUksMENBQUk7QUFDcEg7QUFDQTtBQUNBLGtCQUFrQiwyREFBWSxJQUFJLDhEQUFxQixFQUFFLFdBQVcsZ0JBQWdCLFVBQVUsRUFBRSxJQUFJLDBDQUFJO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDhCQUE4QixpRUFBbUI7QUFDakQ7QUFDQSxrQkFBa0IsMkRBQVksb0NBQW9DLGlFQUFtQixFQUFFLE9BQU8sZ0JBQWdCLElBQUksMENBQUk7QUFDdEg7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLGtCQUFrQiwyREFBWSxJQUFJLGlFQUFtQixFQUFFLFlBQVksZ0JBQWdCLFVBQVUsRUFBRSxJQUFJLDBDQUFJO0FBQ3ZHO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sLWNvbm5lY3QvdmVyc2lvbi5qcz9mZGQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBoZWFkZXJQcm90b2NvbFZlcnNpb24gfSBmcm9tIFwiLi9oZWFkZXJzLmpzXCI7XG5pbXBvcnQgeyBwYXJhbUNvbm5lY3RWZXJzaW9uIH0gZnJvbSBcIi4vcXVlcnktcGFyYW1zLmpzXCI7XG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG4vKipcbiAqIFRoZSBvbmx5IGtub3cgdmFsdWUgZm9yIHRoZSBoZWFkZXIgQ29ubmVjdC1Qcm90b2NvbC1WZXJzaW9uLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgY29uc3QgcHJvdG9jb2xWZXJzaW9uID0gXCIxXCI7XG4vKipcbiAqIFJlcXVpcmVzIHRoZSBDb25uZWN0LVByb3RvY29sLVZlcnNpb24gaGVhZGVyIHRvIGJlIHByZXNlbnQgd2l0aCB0aGUgZXhwZWN0ZWRcbiAqIHZhbHVlLiBSYWlzZXMgYSBDb25uZWN0RXJyb3Igd2l0aCBDb2RlLkludmFsaWRBcmd1bWVudCBvdGhlcndpc2UuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlUHJvdG9jb2xWZXJzaW9uSGVhZGVyKHJlcXVlc3RIZWFkZXIpIHtcbiAgICBjb25zdCB2ID0gcmVxdWVzdEhlYWRlci5nZXQoaGVhZGVyUHJvdG9jb2xWZXJzaW9uKTtcbiAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBtaXNzaW5nIHJlcXVpcmVkIGhlYWRlcjogc2V0ICR7aGVhZGVyUHJvdG9jb2xWZXJzaW9ufSB0byBcIiR7cHJvdG9jb2xWZXJzaW9ufVwiYCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2ICE9PSBwcm90b2NvbFZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgJHtoZWFkZXJQcm90b2NvbFZlcnNpb259IG11c3QgYmUgXCIke3Byb3RvY29sVmVyc2lvbn1cIjogZ290IFwiJHt2fVwiYCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbn1cbi8qKlxuICogUmVxdWlyZXMgdGhlIGNvbm5lY3QgcXVlcnkgcGFyYW1ldGVyIHRvIGJlIHByZXNlbnQgd2l0aCB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gKiBSYWlzZXMgYSBDb25uZWN0RXJyb3Igd2l0aCBDb2RlLkludmFsaWRBcmd1bWVudCBvdGhlcndpc2UuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlUHJvdG9jb2xWZXJzaW9uUGFyYW0ocXVlcnlQYXJhbXMpIHtcbiAgICBjb25zdCB2ID0gcXVlcnlQYXJhbXMuZ2V0KHBhcmFtQ29ubmVjdFZlcnNpb24pO1xuICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBzZXQgJHtwYXJhbUNvbm5lY3RWZXJzaW9ufSB0byBcInYke3Byb3RvY29sVmVyc2lvbn1cImAsIENvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodiAhPT0gYHYke3Byb3RvY29sVmVyc2lvbn1gKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYCR7cGFyYW1Db25uZWN0VmVyc2lvbn0gbXVzdCBiZSBcInYke3Byb3RvY29sVmVyc2lvbn1cIjogZ290IFwiJHt2fVwiYCwgQ29kZS5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol-connect/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAsyncIterable: () => (/* binding */ createAsyncIterable),\n/* harmony export */   createWritableIterable: () => (/* binding */ createWritableIterable),\n/* harmony export */   makeIterableAbortable: () => (/* binding */ makeIterableAbortable),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   pipeTo: () => (/* binding */ pipeTo),\n/* harmony export */   readAllBytes: () => (/* binding */ readAllBytes),\n/* harmony export */   sinkAll: () => (/* binding */ sinkAll),\n/* harmony export */   sinkAllBytes: () => (/* binding */ sinkAllBytes),\n/* harmony export */   transformAppend: () => (/* binding */ transformAppend),\n/* harmony export */   transformCatch: () => (/* binding */ transformCatch),\n/* harmony export */   transformCatchFinally: () => (/* binding */ transformCatchFinally),\n/* harmony export */   transformCompressEnvelope: () => (/* binding */ transformCompressEnvelope),\n/* harmony export */   transformDecompressEnvelope: () => (/* binding */ transformDecompressEnvelope),\n/* harmony export */   transformJoinEnvelopes: () => (/* binding */ transformJoinEnvelopes),\n/* harmony export */   transformParseEnvelope: () => (/* binding */ transformParseEnvelope),\n/* harmony export */   transformPrepend: () => (/* binding */ transformPrepend),\n/* harmony export */   transformReadAllBytes: () => (/* binding */ transformReadAllBytes),\n/* harmony export */   transformSerializeEnvelope: () => (/* binding */ transformSerializeEnvelope),\n/* harmony export */   transformSplitEnvelope: () => (/* binding */ transformSplitEnvelope),\n/* harmony export */   untilFirst: () => (/* binding */ untilFirst)\n/* harmony export */ });\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _envelope_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./envelope.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js\");\n/* harmony import */ var _limit_io_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./limit-io.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __asyncDelegator = (undefined && undefined.__asyncDelegator) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\n\n\n\n\nfunction pipeTo(source, ...rest) {\n    const [transforms, sink, opt] = pickTransformsAndSink(rest);\n    let iterable = source;\n    let abortable;\n    if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n        iterable = abortable = makeIterableAbortable(iterable);\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    iterable = pipe(iterable, ...transforms, { propagateDownStreamError: false });\n    return sink(iterable).catch((reason) => {\n        if (abortable) {\n            return abortable.abort(reason).then(() => Promise.reject(reason));\n        }\n        return Promise.reject(reason);\n    });\n}\n// pick transforms, the sink, and options from the pipeTo() rest parameter\nfunction pickTransformsAndSink(rest) {\n    let opt;\n    if (typeof rest[rest.length - 1] != \"function\") {\n        opt = rest.pop();\n    }\n    const sink = rest.pop();\n    return [rest, sink, opt];\n}\n/**\n * Creates an AsyncIterableSink that concatenates all elements from the input.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction sinkAll() {\n    return async function (iterable) {\n        var _a, e_1, _b, _c;\n        const all = [];\n        try {\n            for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), _a = iterable_1_1.done, !_a; _d = true) {\n                _c = iterable_1_1.value;\n                _d = false;\n                const chunk = _c;\n                all.push(chunk);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = iterable_1.return)) await _b.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return all;\n    };\n}\n/**\n * Creates an AsyncIterableSink that concatenates all chunks from the input into\n * a single Uint8Array.\n *\n * The iterable raises an error if the more than readMaxBytes are read.\n *\n * An optional length hint can be provided to optimize allocation and validation.\n * If more or less bytes are present in the source that the length hint indicates,\n * and error is raised.\n * If the length hint is larger than readMaxBytes, an error is raised.\n * If the length hint is not a positive integer, it is ignored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction sinkAllBytes(readMaxBytes, lengthHint) {\n    return async function (iterable) {\n        return await readAllBytes(iterable, readMaxBytes, lengthHint);\n    };\n}\nfunction pipe(source, ...rest) {\n    return __asyncGenerator(this, arguments, function* pipe_1() {\n        var _a;\n        const [transforms, opt] = pickTransforms(rest);\n        let abortable;\n        const sourceIt = source[Symbol.asyncIterator]();\n        const cachedSource = {\n            [Symbol.asyncIterator]() {\n                return sourceIt;\n            },\n        };\n        let iterable = cachedSource;\n        if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n            iterable = abortable = makeIterableAbortable(iterable);\n        }\n        for (const t of transforms) {\n            iterable = t(iterable);\n        }\n        const it = iterable[Symbol.asyncIterator]();\n        try {\n            for (;;) {\n                const r = yield __await(it.next());\n                if (r.done === true) {\n                    break;\n                }\n                if (!abortable) {\n                    yield yield __await(r.value);\n                    continue;\n                }\n                try {\n                    yield yield __await(r.value);\n                }\n                catch (e) {\n                    yield __await(abortable.abort(e)); // propagate downstream error to the source\n                    throw e;\n                }\n            }\n        }\n        finally {\n            if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n                // Call return on the source iterable to indicate\n                // that we will no longer consume it and it should\n                // cleanup any allocated resources.\n                (_a = sourceIt.return) === null || _a === void 0 ? void 0 : _a.call(sourceIt).catch(() => {\n                    // return returns a promise, which we don't care about.\n                    //\n                    // Uncaught promises are thrown at sometime/somewhere by the event loop,\n                    // this is to ensure error is caught and ignored.\n                });\n            }\n        }\n    });\n}\nfunction pickTransforms(rest) {\n    let opt;\n    if (typeof rest[rest.length - 1] != \"function\") {\n        opt = rest.pop();\n    }\n    return [rest, opt];\n}\n/**\n * Creates an AsyncIterableTransform that catches any error from the input, and\n * passes it to the given catchError function.\n *\n * The catchError function may return a final value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCatch(catchError) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            // we deliberate avoid a for-await loop because we only want to catch upstream\n            // errors, not downstream errors (yield).\n            const it = iterable[Symbol.asyncIterator]();\n            for (;;) {\n                let r;\n                try {\n                    r = yield __await(it.next());\n                }\n                catch (e) {\n                    const caught = yield __await(catchError(e));\n                    if (caught !== undefined) {\n                        yield yield __await(caught);\n                    }\n                    break;\n                }\n                if (r.done === true) {\n                    break;\n                }\n                yield yield __await(r.value);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that catches any error from the input, and\n * passes it to the given function. Unlike transformCatch(), the given function\n * is also called when no error is raised.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCatchFinally(catchFinally) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            // we deliberate avoid a for-await loop because we only want to catch upstream\n            // errors, not downstream errors (yield).\n            let err;\n            const it = iterable[Symbol.asyncIterator]();\n            for (;;) {\n                let r;\n                try {\n                    r = yield __await(it.next());\n                }\n                catch (e) {\n                    err = e;\n                    break;\n                }\n                if (r.done === true) {\n                    break;\n                }\n                yield yield __await(r.value);\n            }\n            const caught = yield __await(catchFinally(err));\n            if (caught !== undefined) {\n                yield yield __await(caught);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that appends a value.\n *\n * The element to append is provided by a function. If the function returns\n * undefined, no element is appended.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformAppend(provide) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_2, _b, _c;\n            try {\n                for (var _d = true, iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield __await(iterable_2.next()), _a = iterable_2_1.done, !_a; _d = true) {\n                    _c = iterable_2_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_2.return)) yield __await(_b.call(iterable_2));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            const append = yield __await(provide());\n            if (append !== undefined) {\n                yield yield __await(append);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that prepends an element.\n *\n * The element to prepend is provided by a function. If the function returns\n * undefined, no element is appended.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformPrepend(provide) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_3, _b, _c;\n            const prepend = yield __await(provide());\n            if (prepend !== undefined) {\n                yield yield __await(prepend);\n            }\n            try {\n                for (var _d = true, iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield __await(iterable_3.next()), _a = iterable_3_1.done, !_a; _d = true) {\n                    _c = iterable_3_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_3.return)) yield __await(_b.call(iterable_3));\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that reads all bytes from the input, and\n * concatenates them to a single Uint8Array.\n *\n * The iterable raises an error if the more than readMaxBytes are read.\n *\n * An optional length hint can be provided to optimize allocation and validation.\n * If more or less bytes are present in the source that the length hint indicates,\n * and error is raised.\n * If the length hint is larger than readMaxBytes, an error is raised.\n * If the length hint is not a positive integer, it is ignored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformReadAllBytes(readMaxBytes, lengthHint) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            yield yield __await(yield __await(readAllBytes(iterable, readMaxBytes, lengthHint)));\n        });\n    };\n}\nfunction transformSerializeEnvelope(serialization, endStreamFlag, endSerialization) {\n    if (endStreamFlag === undefined || endSerialization === undefined) {\n        return function (iterable) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_4, _b, _c;\n                try {\n                    for (var _d = true, iterable_4 = __asyncValues(iterable), iterable_4_1; iterable_4_1 = yield __await(iterable_4.next()), _a = iterable_4_1.done, !_a; _d = true) {\n                        _c = iterable_4_1.value;\n                        _d = false;\n                        const chunk = _c;\n                        const data = serialization.serialize(chunk);\n                        yield yield __await({ flags: 0, data });\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iterable_4.return)) yield __await(_b.call(iterable_4));\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            });\n        };\n    }\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_5, _b, _c;\n            try {\n                for (var _d = true, iterable_5 = __asyncValues(iterable), iterable_5_1; iterable_5_1 = yield __await(iterable_5.next()), _a = iterable_5_1.done, !_a; _d = true) {\n                    _c = iterable_5_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    let data;\n                    let flags = 0;\n                    if (chunk.end) {\n                        flags = flags | endStreamFlag;\n                        data = endSerialization.serialize(chunk.value);\n                    }\n                    else {\n                        data = serialization.serialize(chunk.value);\n                    }\n                    yield yield __await({ flags, data });\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_5.return)) yield __await(_b.call(iterable_5));\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n        });\n    };\n}\nfunction transformParseEnvelope(serialization, endStreamFlag, endSerialization) {\n    // code path always yields ParsedEnvelopedMessage<T, E>\n    if (endSerialization && endStreamFlag !== undefined) {\n        return function (iterable) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_6, _b, _c;\n                try {\n                    for (var _d = true, iterable_6 = __asyncValues(iterable), iterable_6_1; iterable_6_1 = yield __await(iterable_6.next()), _a = iterable_6_1.done, !_a; _d = true) {\n                        _c = iterable_6_1.value;\n                        _d = false;\n                        const { flags, data } = _c;\n                        if ((flags & endStreamFlag) === endStreamFlag) {\n                            yield yield __await({ value: endSerialization.parse(data), end: true });\n                        }\n                        else {\n                            yield yield __await({ value: serialization.parse(data), end: false });\n                        }\n                    }\n                }\n                catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iterable_6.return)) yield __await(_b.call(iterable_6));\n                    }\n                    finally { if (e_6) throw e_6.error; }\n                }\n            });\n        };\n    }\n    // code path always yields T\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_7, _b, _c;\n            try {\n                for (var _d = true, iterable_7 = __asyncValues(iterable), iterable_7_1; iterable_7_1 = yield __await(iterable_7.next()), _a = iterable_7_1.done, !_a; _d = true) {\n                    _c = iterable_7_1.value;\n                    _d = false;\n                    const { flags, data } = _c;\n                    if (endStreamFlag !== undefined &&\n                        (flags & endStreamFlag) === endStreamFlag) {\n                        if (endSerialization === null) {\n                            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"unexpected end flag\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n                        }\n                        // skips end-of-stream envelope\n                        continue;\n                    }\n                    yield yield __await(serialization.parse(data));\n                }\n            }\n            catch (e_7_1) { e_7 = { error: e_7_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_7.return)) yield __await(_b.call(iterable_7));\n                }\n                finally { if (e_7) throw e_7.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that takes enveloped messages as a source,\n * and compresses them if they are larger than compressMinBytes.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformCompressEnvelope(compression, compressMinBytes) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_8, _b, _c;\n            try {\n                for (var _d = true, iterable_8 = __asyncValues(iterable), iterable_8_1; iterable_8_1 = yield __await(iterable_8.next()), _a = iterable_8_1.done, !_a; _d = true) {\n                    _c = iterable_8_1.value;\n                    _d = false;\n                    const env = _c;\n                    yield yield __await(yield __await((0,_envelope_js__WEBPACK_IMPORTED_MODULE_2__.envelopeCompress)(env, compression, compressMinBytes)));\n                }\n            }\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_8.return)) yield __await(_b.call(iterable_8));\n                }\n                finally { if (e_8) throw e_8.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that takes enveloped messages as a source,\n * and decompresses them using the given compression.\n *\n * The iterable raises an error if the decompressed payload of an enveloped\n * message is larger than readMaxBytes, or if no compression is provided.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformDecompressEnvelope(compression, readMaxBytes) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_9, _b, _c;\n            try {\n                for (var _d = true, iterable_9 = __asyncValues(iterable), iterable_9_1; iterable_9_1 = yield __await(iterable_9.next()), _a = iterable_9_1.done, !_a; _d = true) {\n                    _c = iterable_9_1.value;\n                    _d = false;\n                    const env = _c;\n                    yield yield __await(yield __await((0,_envelope_js__WEBPACK_IMPORTED_MODULE_2__.envelopeDecompress)(env, compression, readMaxBytes)));\n                }\n            }\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_9.return)) yield __await(_b.call(iterable_9));\n                }\n                finally { if (e_9) throw e_9.error; }\n            }\n        });\n    };\n}\n/**\n * Create an AsyncIterableTransform that takes enveloped messages as a source,\n * and joins them into a stream of raw bytes.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformJoinEnvelopes() {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_10, _b, _c;\n            try {\n                for (var _d = true, iterable_10 = __asyncValues(iterable), iterable_10_1; iterable_10_1 = yield __await(iterable_10.next()), _a = iterable_10_1.done, !_a; _d = true) {\n                    _c = iterable_10_1.value;\n                    _d = false;\n                    const { flags, data } = _c;\n                    yield yield __await((0,_envelope_js__WEBPACK_IMPORTED_MODULE_2__.encodeEnvelope)(flags, data));\n                }\n            }\n            catch (e_10_1) { e_10 = { error: e_10_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_10.return)) yield __await(_b.call(iterable_10));\n                }\n                finally { if (e_10) throw e_10.error; }\n            }\n        });\n    };\n}\n/**\n * Create an AsyncIterableTransform that takes raw bytes as a source, and splits\n * them into enveloped messages.\n *\n * The iterable raises an error\n * - if the payload of an enveloped message is larger than readMaxBytes,\n * - if the stream ended before an enveloped message fully arrived,\n * - or if the stream ended with extraneous data.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction transformSplitEnvelope(readMaxBytes) {\n    // append chunk to buffer, returning updated buffer\n    function append(buffer, chunk) {\n        const n = new Uint8Array(buffer.byteLength + chunk.byteLength);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        return n;\n    }\n    // tuple 0: envelope, or undefined if incomplete\n    // tuple 1: remainder of the buffer\n    function shiftEnvelope(buffer, header) {\n        if (buffer.byteLength < 5 + header.length) {\n            return [undefined, buffer];\n        }\n        return [\n            { flags: header.flags, data: buffer.subarray(5, 5 + header.length) },\n            buffer.subarray(5 + header.length),\n        ];\n    }\n    // undefined: header is incomplete\n    function peekHeader(buffer) {\n        if (buffer.byteLength < 5) {\n            return undefined;\n        }\n        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n        const length = view.getUint32(1); // 4 bytes message length\n        const flags = view.getUint8(0); // first byte is flags\n        return { length, flags };\n    }\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_11, _b, _c;\n            let buffer = new Uint8Array(0);\n            try {\n                for (var _d = true, iterable_11 = __asyncValues(iterable), iterable_11_1; iterable_11_1 = yield __await(iterable_11.next()), _a = iterable_11_1.done, !_a; _d = true) {\n                    _c = iterable_11_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    buffer = append(buffer, chunk);\n                    for (;;) {\n                        const header = peekHeader(buffer);\n                        if (!header) {\n                            break;\n                        }\n                        (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_3__.assertReadMaxBytes)(readMaxBytes, header.length, true);\n                        let env;\n                        [env, buffer] = shiftEnvelope(buffer, header);\n                        if (!env) {\n                            break;\n                        }\n                        yield yield __await(env);\n                    }\n                }\n            }\n            catch (e_11_1) { e_11 = { error: e_11_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_11.return)) yield __await(_b.call(iterable_11));\n                }\n                finally { if (e_11) throw e_11.error; }\n            }\n            if (buffer.byteLength > 0) {\n                const header = peekHeader(buffer);\n                let message = \"protocol error: incomplete envelope\";\n                if (header) {\n                    message = `protocol error: promised ${header.length} bytes in enveloped message, got ${buffer.byteLength - 5} bytes`;\n                }\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(message, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n            }\n        });\n    };\n}\n/**\n * Reads all bytes from the source, and concatenates them to a single Uint8Array.\n *\n * Raises an error if:\n * - more than readMaxBytes are read\n * - lengthHint is a positive integer, but larger than readMaxBytes\n * - lengthHint is a positive integer, and the source contains more or less bytes\n *   than promised\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function readAllBytes(iterable, readMaxBytes, lengthHint) {\n    var _a, e_12, _b, _c, _d, e_13, _e, _f;\n    const [ok, hint] = parseLengthHint(lengthHint);\n    if (ok) {\n        if (hint > readMaxBytes) {\n            (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_3__.assertReadMaxBytes)(readMaxBytes, hint, true);\n        }\n        const buffer = new Uint8Array(hint);\n        let offset = 0;\n        try {\n            for (var _g = true, iterable_12 = __asyncValues(iterable), iterable_12_1; iterable_12_1 = await iterable_12.next(), _a = iterable_12_1.done, !_a; _g = true) {\n                _c = iterable_12_1.value;\n                _g = false;\n                const chunk = _c;\n                if (offset + chunk.byteLength > hint) {\n                    throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`protocol error: promised ${hint} bytes, received ${offset + chunk.byteLength}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n                }\n                buffer.set(chunk, offset);\n                offset += chunk.byteLength;\n            }\n        }\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\n        finally {\n            try {\n                if (!_g && !_a && (_b = iterable_12.return)) await _b.call(iterable_12);\n            }\n            finally { if (e_12) throw e_12.error; }\n        }\n        if (offset < hint) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`protocol error: promised ${hint} bytes, received ${offset}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.InvalidArgument);\n        }\n        return buffer;\n    }\n    const chunks = [];\n    let count = 0;\n    try {\n        for (var _h = true, iterable_13 = __asyncValues(iterable), iterable_13_1; iterable_13_1 = await iterable_13.next(), _d = iterable_13_1.done, !_d; _h = true) {\n            _f = iterable_13_1.value;\n            _h = false;\n            const chunk = _f;\n            count += chunk.byteLength;\n            (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_3__.assertReadMaxBytes)(readMaxBytes, count);\n            chunks.push(chunk);\n        }\n    }\n    catch (e_13_1) { e_13 = { error: e_13_1 }; }\n    finally {\n        try {\n            if (!_h && !_d && (_e = iterable_13.return)) await _e.call(iterable_13);\n        }\n        finally { if (e_13) throw e_13.error; }\n    }\n    const all = new Uint8Array(count);\n    let offset = 0;\n    for (let chunk = chunks.shift(); chunk; chunk = chunks.shift()) {\n        all.set(chunk, offset);\n        offset += chunk.byteLength;\n    }\n    return all;\n}\n// parse the lengthHint argument of readAllBytes()\nfunction parseLengthHint(lengthHint) {\n    if (lengthHint === undefined || lengthHint === null) {\n        return [false, 0];\n    }\n    const n = typeof lengthHint == \"string\" ? parseInt(lengthHint, 10) : lengthHint;\n    if (!Number.isSafeInteger(n) || n < 0) {\n        return [false, n];\n    }\n    return [true, n];\n}\n/**\n * Wait for the first element of an iterable without modifying the iterable.\n * This consumes the first element, but pushes it back on the stack.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function untilFirst(iterable) {\n    const it = iterable[Symbol.asyncIterator]();\n    let first = await it.next();\n    return {\n        [Symbol.asyncIterator]() {\n            const w = {\n                async next() {\n                    if (first !== null) {\n                        const n = first;\n                        first = null;\n                        return n;\n                    }\n                    return await it.next();\n                },\n            };\n            if (it.throw !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- can't handle mutated object sensibly\n                w.throw = (e) => it.throw(e);\n            }\n            if (it.return !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-explicit-any -- can't handle mutated object sensibly\n                w.return = (value) => it.return(value);\n            }\n            return w;\n        },\n    };\n}\n/**\n * Wrap the given iterable and return an iterable with an abort() method.\n *\n * This function exists purely for convenience. Where one would typically have\n * to access the iterator directly, advance through all elements, and call\n * AsyncIterator.throw() to notify the upstream iterable, this function allows\n * to use convenient for-await loops and still notify the upstream iterable:\n *\n * ```ts\n * const abortable = makeIterableAbortable(iterable);\n * for await (const ele of abortable) {\n *   await abortable.abort(\"ERR\");\n * }\n * ```\n * There are a couple of limitations of this function:\n * - the given async iterable must implement throw\n * - the async iterable cannot be re-use\n * - if source catches errors and yields values for them, they are ignored, and\n *   the source may still dangle\n *\n * There are four possible ways an async function* can handle yield errors:\n * 1. don't catch errors at all - Abortable.abort() will resolve \"rethrown\"\n * 2. catch errors and rethrow - Abortable.abort() will resolve \"rethrown\"\n * 3. catch errors and return - Abortable.abort() will resolve \"completed\"\n * 4. catch errors and yield a value - Abortable.abort() will resolve \"caught\"\n *\n * Note that catching errors and yielding a value is problematic, and it should\n * be documented that this may leave the source in a dangling state.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction makeIterableAbortable(iterable) {\n    const innerCandidate = iterable[Symbol.asyncIterator]();\n    if (innerCandidate.throw === undefined) {\n        throw new Error(\"AsyncIterable does not implement throw\");\n    }\n    const inner = innerCandidate;\n    let aborted;\n    let resultPromise;\n    let it = {\n        next() {\n            resultPromise = inner.next().finally(() => {\n                resultPromise = undefined;\n            });\n            return resultPromise;\n        },\n        throw(e) {\n            return inner.throw(e);\n        },\n    };\n    if (innerCandidate.return !== undefined) {\n        it = Object.assign(Object.assign({}, it), { return(value) {\n                return inner.return(value);\n            } });\n    }\n    let used = false;\n    return {\n        abort(reason) {\n            if (aborted) {\n                return aborted.state;\n            }\n            const f = () => {\n                return inner.throw(reason).then((r) => (r.done === true ? \"completed\" : \"caught\"), () => \"rethrown\");\n            };\n            if (resultPromise) {\n                aborted = { reason, state: resultPromise.then(f, f) };\n                return aborted.state;\n            }\n            aborted = { reason, state: f() };\n            return aborted.state;\n        },\n        [Symbol.asyncIterator]() {\n            if (used) {\n                throw new Error(\"AsyncIterable cannot be re-used\");\n            }\n            used = true;\n            return it;\n        },\n    };\n}\n/**\n * Create a new WritableIterable.\n */\nfunction createWritableIterable() {\n    // We start with two queues to capture the read and write attempts.\n    //\n    // The writes and reads each check of their counterpart is\n    // already available and either interact/add themselves to the queue.\n    const readQueue = [];\n    const writeQueue = [];\n    let err = undefined;\n    let nextResolve;\n    let nextReject;\n    let nextPromise = new Promise((resolve, reject) => {\n        nextResolve = resolve;\n        nextReject = reject;\n    });\n    let closed = false;\n    // drain the readQueue in case of error/writer is closed by sending a\n    // done result.\n    function drain() {\n        for (const next of readQueue.splice(0, readQueue.length)) {\n            next({ done: true, value: undefined });\n        }\n    }\n    return {\n        close() {\n            closed = true;\n            drain();\n        },\n        async write(payload) {\n            if (closed) {\n                throw err !== null && err !== void 0 ? err : new Error(\"cannot write, WritableIterable already closed\");\n            }\n            const read = readQueue.shift();\n            if (read === undefined) {\n                // We didn't find a pending read so we add the payload to the write queue.\n                writeQueue.push(payload);\n            }\n            else {\n                // We found a pending read so we respond with the payload.\n                read({ done: false, value: payload });\n                if (readQueue.length > 0) {\n                    // If there are more in the read queue we can mark the write as complete.\n                    // as the error reporting is not guaranteed to be sequential and therefore cannot\n                    // to linked to a specific write.\n                    return;\n                }\n            }\n            // We await the next call for as many times as there are items in the queue + 1\n            //\n            // If there are no items in the write queue that means write happened and we just have\n            // to wait for one more call likewise if we are the nth write in the queue we\n            // have to wait for n writes to complete and one more.\n            const limit = writeQueue.length + 1;\n            for (let i = 0; i < limit; i++) {\n                await nextPromise;\n            }\n        },\n        [Symbol.asyncIterator]() {\n            return {\n                next() {\n                    // Resolve the nextPromise to indicate\n                    // pending writes that a read attempt has been made\n                    // after their write.\n                    //\n                    // We also need to reset the promise for future writes.\n                    nextResolve();\n                    nextPromise = new Promise((resolve, reject) => {\n                        nextResolve = resolve;\n                        nextReject = reject;\n                    });\n                    const write = writeQueue.shift();\n                    if (write !== undefined) {\n                        // We found a pending write so response with the payload.\n                        return Promise.resolve({ done: false, value: write });\n                    }\n                    if (closed) {\n                        return Promise.resolve({ done: true, value: undefined });\n                    }\n                    // We return a promise immediately that is either resolved/rejected\n                    // as writes happen.\n                    let readResolve;\n                    const readPromise = new Promise((resolve) => (readResolve = resolve));\n                    readQueue.push(readResolve); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                    return readPromise;\n                },\n                throw(throwErr) {\n                    err = throwErr;\n                    closed = true;\n                    writeQueue.splice(0, writeQueue.length);\n                    nextPromise.catch(() => {\n                        // To make sure that the nextPromise is always resolved.\n                    });\n                    // This will reject all pending writes.\n                    nextReject(err);\n                    drain();\n                    return Promise.resolve({ done: true, value: undefined });\n                },\n                return() {\n                    closed = true;\n                    writeQueue.splice(0, writeQueue.length);\n                    // Resolve once for the write awaiting confirmation.\n                    nextResolve();\n                    // Reject all future writes.\n                    nextPromise = Promise.reject(new Error(\"cannot write, consumer called return\"));\n                    nextPromise.catch(() => {\n                        // To make sure that the nextPromise is always resolved.\n                    });\n                    drain();\n                    return Promise.resolve({ done: true, value: undefined });\n                },\n            };\n        },\n    };\n}\n/**\n * Create an asynchronous iterable from an array.\n *\n * @private Internal code, does not follow semantic versioning.\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nfunction createAsyncIterable(items) {\n    return __asyncGenerator(this, arguments, function* createAsyncIterable_1() {\n        yield __await(yield* __asyncDelegator(__asyncValues(items)));\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9hc3luYy1pdGVyYWJsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFJLElBQUksU0FBSTtBQUNqQztBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQSxlQUFlLFNBQUksSUFBSSxTQUFJLDRCQUE0QjtBQUN2RCx3QkFBd0IsU0FBSSxJQUFJLFNBQUk7QUFDcEM7QUFDQTtBQUNBLGlCQUFpQixvR0FBb0csY0FBYztBQUNuSSw4QkFBOEIsc0JBQXNCO0FBQ3BELDBCQUEwQixZQUFZLHNCQUFzQixxQ0FBcUMsMkNBQTJDLE1BQU07QUFDbEosNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCO0FBQ0Esd0JBQXdCLFNBQUksSUFBSSxTQUFJO0FBQ3BDO0FBQ0EsaUJBQWlCLDZDQUE2QyxVQUFVLHNEQUFzRCxjQUFjO0FBQzVJLDBCQUEwQiw2QkFBNkIsb0JBQW9CLHVDQUF1QyxrQkFBa0I7QUFDcEk7QUFDa0M7QUFDaUI7QUFDbUM7QUFDbkM7QUFDNUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlDQUFpQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YscUVBQXFFO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw4RUFBOEU7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw4RUFBOEU7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDhFQUE4RTtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw4RUFBOEU7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw4RUFBOEU7QUFDMUs7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0Esa0RBQWtELGdEQUFnRDtBQUNsRztBQUNBO0FBQ0Esa0RBQWtELDhDQUE4QztBQUNoRztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw4RUFBOEU7QUFDdEs7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyREFBWSx3QkFBd0IsMENBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Riw4RUFBOEU7QUFDdEs7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDhEQUFnQjtBQUN0RTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsOEVBQThFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnRUFBa0I7QUFDeEU7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGlGQUFpRjtBQUMzSztBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUMsd0NBQXdDLDREQUFjO0FBQ3REO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0VBQWtFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx3Q0FBd0M7QUFDeEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixpRkFBaUY7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZSxrQ0FBa0MsdUJBQXVCO0FBQ2xJO0FBQ0EsMEJBQTBCLDJEQUFZLFVBQVUsMENBQUk7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Ysd0VBQXdFO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJEQUFZLDZCQUE2QixNQUFNLGtCQUFrQiwwQkFBMEIsR0FBRywwQ0FBSTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQiwyREFBWSw2QkFBNkIsTUFBTSxrQkFBa0IsT0FBTyxHQUFHLDBDQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRix3RUFBd0U7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQSxpREFBaUQsOEJBQThCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0UsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0UsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2FzeW5jLWl0ZXJhYmxlLmpzPzUxNzciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2FzeW5jVmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn07XG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xudmFyIF9fYXN5bmNEZWxlZ2F0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNEZWxlZ2F0b3IpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGksIHA7XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufTtcbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgQ29ubmVjdEVycm9yIH0gZnJvbSBcIi4uL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IGVuY29kZUVudmVsb3BlLCBlbnZlbG9wZUNvbXByZXNzLCBlbnZlbG9wZURlY29tcHJlc3MsIH0gZnJvbSBcIi4vZW52ZWxvcGUuanNcIjtcbmltcG9ydCB7IGFzc2VydFJlYWRNYXhCeXRlcyB9IGZyb20gXCIuL2xpbWl0LWlvLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGlwZVRvKHNvdXJjZSwgLi4ucmVzdCkge1xuICAgIGNvbnN0IFt0cmFuc2Zvcm1zLCBzaW5rLCBvcHRdID0gcGlja1RyYW5zZm9ybXNBbmRTaW5rKHJlc3QpO1xuICAgIGxldCBpdGVyYWJsZSA9IHNvdXJjZTtcbiAgICBsZXQgYWJvcnRhYmxlO1xuICAgIGlmICgob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LnByb3BhZ2F0ZURvd25TdHJlYW1FcnJvcikgPT09IHRydWUpIHtcbiAgICAgICAgaXRlcmFibGUgPSBhYm9ydGFibGUgPSBtYWtlSXRlcmFibGVBYm9ydGFibGUoaXRlcmFibGUpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGl0ZXJhYmxlID0gcGlwZShpdGVyYWJsZSwgLi4udHJhbnNmb3JtcywgeyBwcm9wYWdhdGVEb3duU3RyZWFtRXJyb3I6IGZhbHNlIH0pO1xuICAgIHJldHVybiBzaW5rKGl0ZXJhYmxlKS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgIGlmIChhYm9ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydGFibGUuYWJvcnQocmVhc29uKS50aGVuKCgpID0+IFByb21pc2UucmVqZWN0KHJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xufVxuLy8gcGljayB0cmFuc2Zvcm1zLCB0aGUgc2luaywgYW5kIG9wdGlvbnMgZnJvbSB0aGUgcGlwZVRvKCkgcmVzdCBwYXJhbWV0ZXJcbmZ1bmN0aW9uIHBpY2tUcmFuc2Zvcm1zQW5kU2luayhyZXN0KSB7XG4gICAgbGV0IG9wdDtcbiAgICBpZiAodHlwZW9mIHJlc3RbcmVzdC5sZW5ndGggLSAxXSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb3B0ID0gcmVzdC5wb3AoKTtcbiAgICB9XG4gICAgY29uc3Qgc2luayA9IHJlc3QucG9wKCk7XG4gICAgcmV0dXJuIFtyZXN0LCBzaW5rLCBvcHRdO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVTaW5rIHRoYXQgY29uY2F0ZW5hdGVzIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBpbnB1dC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbmtBbGwoKSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBhbGwgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfMSA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xXzE7IGl0ZXJhYmxlXzFfMSA9IGF3YWl0IGl0ZXJhYmxlXzEubmV4dCgpLCBfYSA9IGl0ZXJhYmxlXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICBhbGwucHVzaChjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzEucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChpdGVyYWJsZV8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVNpbmsgdGhhdCBjb25jYXRlbmF0ZXMgYWxsIGNodW5rcyBmcm9tIHRoZSBpbnB1dCBpbnRvXG4gKiBhIHNpbmdsZSBVaW50OEFycmF5LlxuICpcbiAqIFRoZSBpdGVyYWJsZSByYWlzZXMgYW4gZXJyb3IgaWYgdGhlIG1vcmUgdGhhbiByZWFkTWF4Qnl0ZXMgYXJlIHJlYWQuXG4gKlxuICogQW4gb3B0aW9uYWwgbGVuZ3RoIGhpbnQgY2FuIGJlIHByb3ZpZGVkIHRvIG9wdGltaXplIGFsbG9jYXRpb24gYW5kIHZhbGlkYXRpb24uXG4gKiBJZiBtb3JlIG9yIGxlc3MgYnl0ZXMgYXJlIHByZXNlbnQgaW4gdGhlIHNvdXJjZSB0aGF0IHRoZSBsZW5ndGggaGludCBpbmRpY2F0ZXMsXG4gKiBhbmQgZXJyb3IgaXMgcmFpc2VkLlxuICogSWYgdGhlIGxlbmd0aCBoaW50IGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcywgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICogSWYgdGhlIGxlbmd0aCBoaW50IGlzIG5vdCBhIHBvc2l0aXZlIGludGVnZXIsIGl0IGlzIGlnbm9yZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5rQWxsQnl0ZXMocmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KSB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEFsbEJ5dGVzKGl0ZXJhYmxlLCByZWFkTWF4Qnl0ZXMsIGxlbmd0aEhpbnQpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGlwZShzb3VyY2UsIC4uLnJlc3QpIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwaXBlXzEoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgW3RyYW5zZm9ybXMsIG9wdF0gPSBwaWNrVHJhbnNmb3JtcyhyZXN0KTtcbiAgICAgICAgbGV0IGFib3J0YWJsZTtcbiAgICAgICAgY29uc3Qgc291cmNlSXQgPSBzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgIGNvbnN0IGNhY2hlZFNvdXJjZSA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUl0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGl0ZXJhYmxlID0gY2FjaGVkU291cmNlO1xuICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5wcm9wYWdhdGVEb3duU3RyZWFtRXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpdGVyYWJsZSA9IGFib3J0YWJsZSA9IG1ha2VJdGVyYWJsZUFib3J0YWJsZShpdGVyYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gdChpdGVyYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0geWllbGQgX19hd2FpdChpdC5uZXh0KCkpO1xuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYWJvcnRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHIudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfX2F3YWl0KGFib3J0YWJsZS5hYm9ydChlKSk7IC8vIHByb3BhZ2F0ZSBkb3duc3RyZWFtIGVycm9yIHRvIHRoZSBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5wcm9wYWdhdGVEb3duU3RyZWFtRXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCByZXR1cm4gb24gdGhlIHNvdXJjZSBpdGVyYWJsZSB0byBpbmRpY2F0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2Ugd2lsbCBubyBsb25nZXIgY29uc3VtZSBpdCBhbmQgaXQgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBhbnkgYWxsb2NhdGVkIHJlc291cmNlcy5cbiAgICAgICAgICAgICAgICAoX2EgPSBzb3VyY2VJdC5yZXR1cm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHNvdXJjZUl0KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXR1cm5zIGEgcHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY2FyZSBhYm91dC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVW5jYXVnaHQgcHJvbWlzZXMgYXJlIHRocm93biBhdCBzb21ldGltZS9zb21ld2hlcmUgYnkgdGhlIGV2ZW50IGxvb3AsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gZW5zdXJlIGVycm9yIGlzIGNhdWdodCBhbmQgaWdub3JlZC5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcGlja1RyYW5zZm9ybXMocmVzdCkge1xuICAgIGxldCBvcHQ7XG4gICAgaWYgKHR5cGVvZiByZXN0W3Jlc3QubGVuZ3RoIC0gMV0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdCA9IHJlc3QucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBbcmVzdCwgb3B0XTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgY2F0Y2hlcyBhbnkgZXJyb3IgZnJvbSB0aGUgaW5wdXQsIGFuZFxuICogcGFzc2VzIGl0IHRvIHRoZSBnaXZlbiBjYXRjaEVycm9yIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBjYXRjaEVycm9yIGZ1bmN0aW9uIG1heSByZXR1cm4gYSBmaW5hbCB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUNhdGNoKGNhdGNoRXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHdlIGRlbGliZXJhdGUgYXZvaWQgYSBmb3ItYXdhaXQgbG9vcCBiZWNhdXNlIHdlIG9ubHkgd2FudCB0byBjYXRjaCB1cHN0cmVhbVxuICAgICAgICAgICAgLy8gZXJyb3JzLCBub3QgZG93bnN0cmVhbSBlcnJvcnMgKHlpZWxkKS5cbiAgICAgICAgICAgIGNvbnN0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHlpZWxkIF9fYXdhaXQoaXQubmV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F1Z2h0ID0geWllbGQgX19hd2FpdChjYXRjaEVycm9yKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhdWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNhdWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IGNhdGNoZXMgYW55IGVycm9yIGZyb20gdGhlIGlucHV0LCBhbmRcbiAqIHBhc3NlcyBpdCB0byB0aGUgZ2l2ZW4gZnVuY3Rpb24uIFVubGlrZSB0cmFuc2Zvcm1DYXRjaCgpLCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAqIGlzIGFsc28gY2FsbGVkIHdoZW4gbm8gZXJyb3IgaXMgcmFpc2VkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQ2F0Y2hGaW5hbGx5KGNhdGNoRmluYWxseSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gd2UgZGVsaWJlcmF0ZSBhdm9pZCBhIGZvci1hd2FpdCBsb29wIGJlY2F1c2Ugd2Ugb25seSB3YW50IHRvIGNhdGNoIHVwc3RyZWFtXG4gICAgICAgICAgICAvLyBlcnJvcnMsIG5vdCBkb3duc3RyZWFtIGVycm9ycyAoeWllbGQpLlxuICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgIGNvbnN0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHlpZWxkIF9fYXdhaXQoaXQubmV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYXVnaHQgPSB5aWVsZCBfX2F3YWl0KGNhdGNoRmluYWxseShlcnIpKTtcbiAgICAgICAgICAgIGlmIChjYXVnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2F1Z2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgYXBwZW5kcyBhIHZhbHVlLlxuICpcbiAqIFRoZSBlbGVtZW50IHRvIGFwcGVuZCBpcyBwcm92aWRlZCBieSBhIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogdW5kZWZpbmVkLCBubyBlbGVtZW50IGlzIGFwcGVuZGVkLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQXBwZW5kKHByb3ZpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfMiA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8yXzE7IGl0ZXJhYmxlXzJfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfMi5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzJfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzIucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBwZW5kID0geWllbGQgX19hd2FpdChwcm92aWRlKCkpO1xuICAgICAgICAgICAgaWYgKGFwcGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChhcHBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCBwcmVwZW5kcyBhbiBlbGVtZW50LlxuICpcbiAqIFRoZSBlbGVtZW50IHRvIHByZXBlbmQgaXMgcHJvdmlkZWQgYnkgYSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqIHVuZGVmaW5lZCwgbm8gZWxlbWVudCBpcyBhcHBlbmRlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVByZXBlbmQocHJvdmlkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHByZXBlbmQgPSB5aWVsZCBfX2F3YWl0KHByb3ZpZGUoKSk7XG4gICAgICAgICAgICBpZiAocHJlcGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChwcmVwZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV8zID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzNfMTsgaXRlcmFibGVfM18xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV8zLm5leHQoKSksIF9hID0gaXRlcmFibGVfM18xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfM18xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmFibGVfMy5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfMykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IHJlYWRzIGFsbCBieXRlcyBmcm9tIHRoZSBpbnB1dCwgYW5kXG4gKiBjb25jYXRlbmF0ZXMgdGhlbSB0byBhIHNpbmdsZSBVaW50OEFycmF5LlxuICpcbiAqIFRoZSBpdGVyYWJsZSByYWlzZXMgYW4gZXJyb3IgaWYgdGhlIG1vcmUgdGhhbiByZWFkTWF4Qnl0ZXMgYXJlIHJlYWQuXG4gKlxuICogQW4gb3B0aW9uYWwgbGVuZ3RoIGhpbnQgY2FuIGJlIHByb3ZpZGVkIHRvIG9wdGltaXplIGFsbG9jYXRpb24gYW5kIHZhbGlkYXRpb24uXG4gKiBJZiBtb3JlIG9yIGxlc3MgYnl0ZXMgYXJlIHByZXNlbnQgaW4gdGhlIHNvdXJjZSB0aGF0IHRoZSBsZW5ndGggaGludCBpbmRpY2F0ZXMsXG4gKiBhbmQgZXJyb3IgaXMgcmFpc2VkLlxuICogSWYgdGhlIGxlbmd0aCBoaW50IGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcywgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICogSWYgdGhlIGxlbmd0aCBoaW50IGlzIG5vdCBhIHBvc2l0aXZlIGludGVnZXIsIGl0IGlzIGlnbm9yZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1SZWFkQWxsQnl0ZXMocmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHlpZWxkIF9fYXdhaXQocmVhZEFsbEJ5dGVzKGl0ZXJhYmxlLCByZWFkTWF4Qnl0ZXMsIGxlbmd0aEhpbnQpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtU2VyaWFsaXplRW52ZWxvcGUoc2VyaWFsaXphdGlvbiwgZW5kU3RyZWFtRmxhZywgZW5kU2VyaWFsaXphdGlvbikge1xuICAgIGlmIChlbmRTdHJlYW1GbGFnID09PSB1bmRlZmluZWQgfHwgZW5kU2VyaWFsaXphdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfNCwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcmFibGVfNCA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV80XzE7IGl0ZXJhYmxlXzRfMSA9IHlpZWxkIF9fYXdhaXQoaXRlcmFibGVfNC5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzRfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV80XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBzZXJpYWxpemF0aW9uLnNlcmlhbGl6ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHsgZmxhZ3M6IDAsIGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzQucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzUsIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV81ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzVfMTsgaXRlcmFibGVfNV8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV81Lm5leHQoKSksIF9hID0gaXRlcmFibGVfNV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfNV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgPSBmbGFncyB8IGVuZFN0cmVhbUZsYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZW5kU2VyaWFsaXphdGlvbi5zZXJpYWxpemUoY2h1bmsudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHNlcmlhbGl6YXRpb24uc2VyaWFsaXplKGNodW5rLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHsgZmxhZ3MsIGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfNV8xKSB7IGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzUucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVBhcnNlRW52ZWxvcGUoc2VyaWFsaXphdGlvbiwgZW5kU3RyZWFtRmxhZywgZW5kU2VyaWFsaXphdGlvbikge1xuICAgIC8vIGNvZGUgcGF0aCBhbHdheXMgeWllbGRzIFBhcnNlZEVudmVsb3BlZE1lc3NhZ2U8VCwgRT5cbiAgICBpZiAoZW5kU2VyaWFsaXphdGlvbiAmJiBlbmRTdHJlYW1GbGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgZV82LCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV82ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzZfMTsgaXRlcmFibGVfNl8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV82Lm5leHQoKSksIF9hID0gaXRlcmFibGVfNl8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzZfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsYWdzLCBkYXRhIH0gPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBlbmRTdHJlYW1GbGFnKSA9PT0gZW5kU3RyZWFtRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoeyB2YWx1ZTogZW5kU2VyaWFsaXphdGlvbi5wYXJzZShkYXRhKSwgZW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh7IHZhbHVlOiBzZXJpYWxpemF0aW9uLnBhcnNlKGRhdGEpLCBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV82LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV82KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBjb2RlIHBhdGggYWx3YXlzIHlpZWxkcyBUXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfNywgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzcgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfN18xOyBpdGVyYWJsZV83XzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzcubmV4dCgpKSwgX2EgPSBpdGVyYWJsZV83XzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV83XzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxhZ3MsIGRhdGEgfSA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kU3RyZWFtRmxhZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiBlbmRTdHJlYW1GbGFnKSA9PT0gZW5kU3RyZWFtRmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFNlcmlhbGl6YXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKFwidW5leHBlY3RlZCBlbmQgZmxhZ1wiLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwcyBlbmQtb2Ytc3RyZWFtIGVudmVsb3BlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHNlcmlhbGl6YXRpb24ucGFyc2UoZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzdfMSkgeyBlXzcgPSB7IGVycm9yOiBlXzdfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyYWJsZV83LnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV83KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBBc3luY0l0ZXJhYmxlVHJhbnNmb3JtIHRoYXQgdGFrZXMgZW52ZWxvcGVkIG1lc3NhZ2VzIGFzIGEgc291cmNlLFxuICogYW5kIGNvbXByZXNzZXMgdGhlbSBpZiB0aGV5IGFyZSBsYXJnZXIgdGhhbiBjb21wcmVzc01pbkJ5dGVzLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQ29tcHJlc3NFbnZlbG9wZShjb21wcmVzc2lvbiwgY29tcHJlc3NNaW5CeXRlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzgsIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV84ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzhfMTsgaXRlcmFibGVfOF8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV84Lm5leHQoKSksIF9hID0gaXRlcmFibGVfOF8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfOF8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh5aWVsZCBfX2F3YWl0KGVudmVsb3BlQ29tcHJlc3MoZW52LCBjb21wcmVzc2lvbiwgY29tcHJlc3NNaW5CeXRlcykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV84XzEpIHsgZV84ID0geyBlcnJvcjogZV84XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gaXRlcmFibGVfOC5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9iLmNhbGwoaXRlcmFibGVfOCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IHRha2VzIGVudmVsb3BlZCBtZXNzYWdlcyBhcyBhIHNvdXJjZSxcbiAqIGFuZCBkZWNvbXByZXNzZXMgdGhlbSB1c2luZyB0aGUgZ2l2ZW4gY29tcHJlc3Npb24uXG4gKlxuICogVGhlIGl0ZXJhYmxlIHJhaXNlcyBhbiBlcnJvciBpZiB0aGUgZGVjb21wcmVzc2VkIHBheWxvYWQgb2YgYW4gZW52ZWxvcGVkXG4gKiBtZXNzYWdlIGlzIGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlcywgb3IgaWYgbm8gY29tcHJlc3Npb24gaXMgcHJvdmlkZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1EZWNvbXByZXNzRW52ZWxvcGUoY29tcHJlc3Npb24sIHJlYWRNYXhCeXRlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlXzksIF9iLCBfYztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV85ID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzlfMTsgaXRlcmFibGVfOV8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV85Lm5leHQoKSksIF9hID0gaXRlcmFibGVfOV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcmFibGVfOV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh5aWVsZCBfX2F3YWl0KGVudmVsb3BlRGVjb21wcmVzcyhlbnYsIGNvbXByZXNzaW9uLCByZWFkTWF4Qnl0ZXMpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfOV8xKSB7IGVfOSA9IHsgZXJyb3I6IGVfOV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzkucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGl0ZXJhYmxlXzkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzkpIHRocm93IGVfOS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gQXN5bmNJdGVyYWJsZVRyYW5zZm9ybSB0aGF0IHRha2VzIGVudmVsb3BlZCBtZXNzYWdlcyBhcyBhIHNvdXJjZSxcbiAqIGFuZCBqb2lucyB0aGVtIGludG8gYSBzdHJlYW0gb2YgcmF3IGJ5dGVzLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtSm9pbkVudmVsb3BlcygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8xMCwgX2IsIF9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGl0ZXJhYmxlXzEwID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzEwXzE7IGl0ZXJhYmxlXzEwXzEgPSB5aWVsZCBfX2F3YWl0KGl0ZXJhYmxlXzEwLm5leHQoKSksIF9hID0gaXRlcmFibGVfMTBfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJhYmxlXzEwXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxhZ3MsIGRhdGEgfSA9IF9jO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGVuY29kZUVudmVsb3BlKGZsYWdzLCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMTBfMSkgeyBlXzEwID0geyBlcnJvcjogZV8xMF8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzEwLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV8xMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTApIHRocm93IGVfMTAuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIEFzeW5jSXRlcmFibGVUcmFuc2Zvcm0gdGhhdCB0YWtlcyByYXcgYnl0ZXMgYXMgYSBzb3VyY2UsIGFuZCBzcGxpdHNcbiAqIHRoZW0gaW50byBlbnZlbG9wZWQgbWVzc2FnZXMuXG4gKlxuICogVGhlIGl0ZXJhYmxlIHJhaXNlcyBhbiBlcnJvclxuICogLSBpZiB0aGUgcGF5bG9hZCBvZiBhbiBlbnZlbG9wZWQgbWVzc2FnZSBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMsXG4gKiAtIGlmIHRoZSBzdHJlYW0gZW5kZWQgYmVmb3JlIGFuIGVudmVsb3BlZCBtZXNzYWdlIGZ1bGx5IGFycml2ZWQsXG4gKiAtIG9yIGlmIHRoZSBzdHJlYW0gZW5kZWQgd2l0aCBleHRyYW5lb3VzIGRhdGEuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1TcGxpdEVudmVsb3BlKHJlYWRNYXhCeXRlcykge1xuICAgIC8vIGFwcGVuZCBjaHVuayB0byBidWZmZXIsIHJldHVybmluZyB1cGRhdGVkIGJ1ZmZlclxuICAgIGZ1bmN0aW9uIGFwcGVuZChidWZmZXIsIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IG4gPSBuZXcgVWludDhBcnJheShidWZmZXIuYnl0ZUxlbmd0aCArIGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBuLnNldChidWZmZXIpO1xuICAgICAgICBuLnNldChjaHVuaywgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICAvLyB0dXBsZSAwOiBlbnZlbG9wZSwgb3IgdW5kZWZpbmVkIGlmIGluY29tcGxldGVcbiAgICAvLyB0dXBsZSAxOiByZW1haW5kZXIgb2YgdGhlIGJ1ZmZlclxuICAgIGZ1bmN0aW9uIHNoaWZ0RW52ZWxvcGUoYnVmZmVyLCBoZWFkZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoIDwgNSArIGhlYWRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBidWZmZXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IGZsYWdzOiBoZWFkZXIuZmxhZ3MsIGRhdGE6IGJ1ZmZlci5zdWJhcnJheSg1LCA1ICsgaGVhZGVyLmxlbmd0aCkgfSxcbiAgICAgICAgICAgIGJ1ZmZlci5zdWJhcnJheSg1ICsgaGVhZGVyLmxlbmd0aCksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIHVuZGVmaW5lZDogaGVhZGVyIGlzIGluY29tcGxldGVcbiAgICBmdW5jdGlvbiBwZWVrSGVhZGVyKGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmlldy5nZXRVaW50MzIoMSk7IC8vIDQgYnl0ZXMgbWVzc2FnZSBsZW5ndGhcbiAgICAgICAgY29uc3QgZmxhZ3MgPSB2aWV3LmdldFVpbnQ4KDApOyAvLyBmaXJzdCBieXRlIGlzIGZsYWdzXG4gICAgICAgIHJldHVybiB7IGxlbmd0aCwgZmxhZ3MgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfMTEsIF9iLCBfYztcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyYWJsZV8xMSA9IF9fYXN5bmNWYWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xMV8xOyBpdGVyYWJsZV8xMV8xID0geWllbGQgX19hd2FpdChpdGVyYWJsZV8xMS5uZXh0KCkpLCBfYSA9IGl0ZXJhYmxlXzExXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV8xMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBhcHBlbmQoYnVmZmVyLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHBlZWtIZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRSZWFkTWF4Qnl0ZXMocmVhZE1heEJ5dGVzLCBoZWFkZXIubGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbnY7XG4gICAgICAgICAgICAgICAgICAgICAgICBbZW52LCBidWZmZXJdID0gc2hpZnRFbnZlbG9wZShidWZmZXIsIGhlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVudikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChlbnYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMTFfMSkgeyBlXzExID0geyBlcnJvcjogZV8xMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzExLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChpdGVyYWJsZV8xMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTEpIHRocm93IGVfMTEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBwZWVrSGVhZGVyKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcInByb3RvY29sIGVycm9yOiBpbmNvbXBsZXRlIGVudmVsb3BlXCI7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYHByb3RvY29sIGVycm9yOiBwcm9taXNlZCAke2hlYWRlci5sZW5ndGh9IGJ5dGVzIGluIGVudmVsb3BlZCBtZXNzYWdlLCBnb3QgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIDV9IGJ5dGVzYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihtZXNzYWdlLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIFJlYWRzIGFsbCBieXRlcyBmcm9tIHRoZSBzb3VyY2UsIGFuZCBjb25jYXRlbmF0ZXMgdGhlbSB0byBhIHNpbmdsZSBVaW50OEFycmF5LlxuICpcbiAqIFJhaXNlcyBhbiBlcnJvciBpZjpcbiAqIC0gbW9yZSB0aGFuIHJlYWRNYXhCeXRlcyBhcmUgcmVhZFxuICogLSBsZW5ndGhIaW50IGlzIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGxhcmdlciB0aGFuIHJlYWRNYXhCeXRlc1xuICogLSBsZW5ndGhIaW50IGlzIGEgcG9zaXRpdmUgaW50ZWdlciwgYW5kIHRoZSBzb3VyY2UgY29udGFpbnMgbW9yZSBvciBsZXNzIGJ5dGVzXG4gKiAgIHRoYW4gcHJvbWlzZWRcbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRBbGxCeXRlcyhpdGVyYWJsZSwgcmVhZE1heEJ5dGVzLCBsZW5ndGhIaW50KSB7XG4gICAgdmFyIF9hLCBlXzEyLCBfYiwgX2MsIF9kLCBlXzEzLCBfZSwgX2Y7XG4gICAgY29uc3QgW29rLCBoaW50XSA9IHBhcnNlTGVuZ3RoSGludChsZW5ndGhIaW50KTtcbiAgICBpZiAob2spIHtcbiAgICAgICAgaWYgKGhpbnQgPiByZWFkTWF4Qnl0ZXMpIHtcbiAgICAgICAgICAgIGFzc2VydFJlYWRNYXhCeXRlcyhyZWFkTWF4Qnl0ZXMsIGhpbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGhpbnQpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9nID0gdHJ1ZSwgaXRlcmFibGVfMTIgPSBfX2FzeW5jVmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMTJfMTsgaXRlcmFibGVfMTJfMSA9IGF3YWl0IGl0ZXJhYmxlXzEyLm5leHQoKSwgX2EgPSBpdGVyYWJsZV8xMl8xLmRvbmUsICFfYTsgX2cgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX2MgPSBpdGVyYWJsZV8xMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIF9nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgY2h1bmsuYnl0ZUxlbmd0aCA+IGhpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgcHJvdG9jb2wgZXJyb3I6IHByb21pc2VkICR7aGludH0gYnl0ZXMsIHJlY2VpdmVkICR7b2Zmc2V0ICsgY2h1bmsuYnl0ZUxlbmd0aH1gLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMTJfMSkgeyBlXzEyID0geyBlcnJvcjogZV8xMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2cgJiYgIV9hICYmIChfYiA9IGl0ZXJhYmxlXzEyLnJldHVybikpIGF3YWl0IF9iLmNhbGwoaXRlcmFibGVfMTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEyKSB0aHJvdyBlXzEyLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8IGhpbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHByb3RvY29sIGVycm9yOiBwcm9taXNlZCAke2hpbnR9IGJ5dGVzLCByZWNlaXZlZCAke29mZnNldH1gLCBDb2RlLkludmFsaWRBcmd1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaCA9IHRydWUsIGl0ZXJhYmxlXzEzID0gX19hc3luY1ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzEzXzE7IGl0ZXJhYmxlXzEzXzEgPSBhd2FpdCBpdGVyYWJsZV8xMy5uZXh0KCksIF9kID0gaXRlcmFibGVfMTNfMS5kb25lLCAhX2Q7IF9oID0gdHJ1ZSkge1xuICAgICAgICAgICAgX2YgPSBpdGVyYWJsZV8xM18xLnZhbHVlO1xuICAgICAgICAgICAgX2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2Y7XG4gICAgICAgICAgICBjb3VudCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgYXNzZXJ0UmVhZE1heEJ5dGVzKHJlYWRNYXhCeXRlcywgY291bnQpO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzEzXzEpIHsgZV8xMyA9IHsgZXJyb3I6IGVfMTNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9oICYmICFfZCAmJiAoX2UgPSBpdGVyYWJsZV8xMy5yZXR1cm4pKSBhd2FpdCBfZS5jYWxsKGl0ZXJhYmxlXzEzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTMpIHRocm93IGVfMTMuZXJyb3I7IH1cbiAgICB9XG4gICAgY29uc3QgYWxsID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGNodW5rID0gY2h1bmtzLnNoaWZ0KCk7IGNodW5rOyBjaHVuayA9IGNodW5rcy5zaGlmdCgpKSB7XG4gICAgICAgIGFsbC5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYWxsO1xufVxuLy8gcGFyc2UgdGhlIGxlbmd0aEhpbnQgYXJndW1lbnQgb2YgcmVhZEFsbEJ5dGVzKClcbmZ1bmN0aW9uIHBhcnNlTGVuZ3RoSGludChsZW5ndGhIaW50KSB7XG4gICAgaWYgKGxlbmd0aEhpbnQgPT09IHVuZGVmaW5lZCB8fCBsZW5ndGhIaW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgIH1cbiAgICBjb25zdCBuID0gdHlwZW9mIGxlbmd0aEhpbnQgPT0gXCJzdHJpbmdcIiA/IHBhcnNlSW50KGxlbmd0aEhpbnQsIDEwKSA6IGxlbmd0aEhpbnQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgICAgICByZXR1cm4gW2ZhbHNlLCBuXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0cnVlLCBuXTtcbn1cbi8qKlxuICogV2FpdCBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gaXRlcmFibGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGl0ZXJhYmxlLlxuICogVGhpcyBjb25zdW1lcyB0aGUgZmlyc3QgZWxlbWVudCwgYnV0IHB1c2hlcyBpdCBiYWNrIG9uIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVudGlsRmlyc3QoaXRlcmFibGUpIHtcbiAgICBjb25zdCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGxldCBmaXJzdCA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgY29uc3QgdyA9IHtcbiAgICAgICAgICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXQudGhyb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uIC0tIGNhbid0IGhhbmRsZSBtdXRhdGVkIG9iamVjdCBzZW5zaWJseVxuICAgICAgICAgICAgICAgIHcudGhyb3cgPSAoZSkgPT4gaXQudGhyb3coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQucmV0dXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIGNhbid0IGhhbmRsZSBtdXRhdGVkIG9iamVjdCBzZW5zaWJseVxuICAgICAgICAgICAgICAgIHcucmV0dXJuID0gKHZhbHVlKSA9PiBpdC5yZXR1cm4odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gaXRlcmFibGUgYW5kIHJldHVybiBhbiBpdGVyYWJsZSB3aXRoIGFuIGFib3J0KCkgbWV0aG9kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZXhpc3RzIHB1cmVseSBmb3IgY29udmVuaWVuY2UuIFdoZXJlIG9uZSB3b3VsZCB0eXBpY2FsbHkgaGF2ZVxuICogdG8gYWNjZXNzIHRoZSBpdGVyYXRvciBkaXJlY3RseSwgYWR2YW5jZSB0aHJvdWdoIGFsbCBlbGVtZW50cywgYW5kIGNhbGxcbiAqIEFzeW5jSXRlcmF0b3IudGhyb3coKSB0byBub3RpZnkgdGhlIHVwc3RyZWFtIGl0ZXJhYmxlLCB0aGlzIGZ1bmN0aW9uIGFsbG93c1xuICogdG8gdXNlIGNvbnZlbmllbnQgZm9yLWF3YWl0IGxvb3BzIGFuZCBzdGlsbCBub3RpZnkgdGhlIHVwc3RyZWFtIGl0ZXJhYmxlOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBhYm9ydGFibGUgPSBtYWtlSXRlcmFibGVBYm9ydGFibGUoaXRlcmFibGUpO1xuICogZm9yIGF3YWl0IChjb25zdCBlbGUgb2YgYWJvcnRhYmxlKSB7XG4gKiAgIGF3YWl0IGFib3J0YWJsZS5hYm9ydChcIkVSUlwiKTtcbiAqIH1cbiAqIGBgYFxuICogVGhlcmUgYXJlIGEgY291cGxlIG9mIGxpbWl0YXRpb25zIG9mIHRoaXMgZnVuY3Rpb246XG4gKiAtIHRoZSBnaXZlbiBhc3luYyBpdGVyYWJsZSBtdXN0IGltcGxlbWVudCB0aHJvd1xuICogLSB0aGUgYXN5bmMgaXRlcmFibGUgY2Fubm90IGJlIHJlLXVzZVxuICogLSBpZiBzb3VyY2UgY2F0Y2hlcyBlcnJvcnMgYW5kIHlpZWxkcyB2YWx1ZXMgZm9yIHRoZW0sIHRoZXkgYXJlIGlnbm9yZWQsIGFuZFxuICogICB0aGUgc291cmNlIG1heSBzdGlsbCBkYW5nbGVcbiAqXG4gKiBUaGVyZSBhcmUgZm91ciBwb3NzaWJsZSB3YXlzIGFuIGFzeW5jIGZ1bmN0aW9uKiBjYW4gaGFuZGxlIHlpZWxkIGVycm9yczpcbiAqIDEuIGRvbid0IGNhdGNoIGVycm9ycyBhdCBhbGwgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJyZXRocm93blwiXG4gKiAyLiBjYXRjaCBlcnJvcnMgYW5kIHJldGhyb3cgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJyZXRocm93blwiXG4gKiAzLiBjYXRjaCBlcnJvcnMgYW5kIHJldHVybiAtIEFib3J0YWJsZS5hYm9ydCgpIHdpbGwgcmVzb2x2ZSBcImNvbXBsZXRlZFwiXG4gKiA0LiBjYXRjaCBlcnJvcnMgYW5kIHlpZWxkIGEgdmFsdWUgLSBBYm9ydGFibGUuYWJvcnQoKSB3aWxsIHJlc29sdmUgXCJjYXVnaHRcIlxuICpcbiAqIE5vdGUgdGhhdCBjYXRjaGluZyBlcnJvcnMgYW5kIHlpZWxkaW5nIGEgdmFsdWUgaXMgcHJvYmxlbWF0aWMsIGFuZCBpdCBzaG91bGRcbiAqIGJlIGRvY3VtZW50ZWQgdGhhdCB0aGlzIG1heSBsZWF2ZSB0aGUgc291cmNlIGluIGEgZGFuZ2xpbmcgc3RhdGUuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSXRlcmFibGVBYm9ydGFibGUoaXRlcmFibGUpIHtcbiAgICBjb25zdCBpbm5lckNhbmRpZGF0ZSA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGlmIChpbm5lckNhbmRpZGF0ZS50aHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jSXRlcmFibGUgZG9lcyBub3QgaW1wbGVtZW50IHRocm93XCIpO1xuICAgIH1cbiAgICBjb25zdCBpbm5lciA9IGlubmVyQ2FuZGlkYXRlO1xuICAgIGxldCBhYm9ydGVkO1xuICAgIGxldCByZXN1bHRQcm9taXNlO1xuICAgIGxldCBpdCA9IHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSBpbm5lci5uZXh0KCkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHRocm93KGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbm5lci50aHJvdyhlKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmIChpbm5lckNhbmRpZGF0ZS5yZXR1cm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXQpLCB7IHJldHVybih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lci5yZXR1cm4odmFsdWUpO1xuICAgICAgICAgICAgfSB9KTtcbiAgICB9XG4gICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChhYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0ZWQuc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lci50aHJvdyhyZWFzb24pLnRoZW4oKHIpID0+IChyLmRvbmUgPT09IHRydWUgPyBcImNvbXBsZXRlZFwiIDogXCJjYXVnaHRcIiksICgpID0+IFwicmV0aHJvd25cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlc3VsdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBhYm9ydGVkID0geyByZWFzb24sIHN0YXRlOiByZXN1bHRQcm9taXNlLnRoZW4oZiwgZikgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWJvcnRlZC5zdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFib3J0ZWQgPSB7IHJlYXNvbiwgc3RhdGU6IGYoKSB9O1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0ZWQuc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICBpZiAodXNlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jSXRlcmFibGUgY2Fubm90IGJlIHJlLXVzZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgV3JpdGFibGVJdGVyYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVdyaXRhYmxlSXRlcmFibGUoKSB7XG4gICAgLy8gV2Ugc3RhcnQgd2l0aCB0d28gcXVldWVzIHRvIGNhcHR1cmUgdGhlIHJlYWQgYW5kIHdyaXRlIGF0dGVtcHRzLlxuICAgIC8vXG4gICAgLy8gVGhlIHdyaXRlcyBhbmQgcmVhZHMgZWFjaCBjaGVjayBvZiB0aGVpciBjb3VudGVycGFydCBpc1xuICAgIC8vIGFscmVhZHkgYXZhaWxhYmxlIGFuZCBlaXRoZXIgaW50ZXJhY3QvYWRkIHRoZW1zZWx2ZXMgdG8gdGhlIHF1ZXVlLlxuICAgIGNvbnN0IHJlYWRRdWV1ZSA9IFtdO1xuICAgIGNvbnN0IHdyaXRlUXVldWUgPSBbXTtcbiAgICBsZXQgZXJyID0gdW5kZWZpbmVkO1xuICAgIGxldCBuZXh0UmVzb2x2ZTtcbiAgICBsZXQgbmV4dFJlamVjdDtcbiAgICBsZXQgbmV4dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIG5leHRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgbmV4dFJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gICAgLy8gZHJhaW4gdGhlIHJlYWRRdWV1ZSBpbiBjYXNlIG9mIGVycm9yL3dyaXRlciBpcyBjbG9zZWQgYnkgc2VuZGluZyBhXG4gICAgLy8gZG9uZSByZXN1bHQuXG4gICAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmV4dCBvZiByZWFkUXVldWUuc3BsaWNlKDAsIHJlYWRRdWV1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICBuZXh0KHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBkcmFpbigpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB3cml0ZShwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyICE9PSBudWxsICYmIGVyciAhPT0gdm9pZCAwID8gZXJyIDogbmV3IEVycm9yKFwiY2Fubm90IHdyaXRlLCBXcml0YWJsZUl0ZXJhYmxlIGFscmVhZHkgY2xvc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZCA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHJlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRpZG4ndCBmaW5kIGEgcGVuZGluZyByZWFkIHNvIHdlIGFkZCB0aGUgcGF5bG9hZCB0byB0aGUgd3JpdGUgcXVldWUuXG4gICAgICAgICAgICAgICAgd3JpdGVRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBwZW5kaW5nIHJlYWQgc28gd2UgcmVzcG9uZCB3aXRoIHRoZSBwYXlsb2FkLlxuICAgICAgICAgICAgICAgIHJlYWQoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHBheWxvYWQgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIGluIHRoZSByZWFkIHF1ZXVlIHdlIGNhbiBtYXJrIHRoZSB3cml0ZSBhcyBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGVycm9yIHJlcG9ydGluZyBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBzZXF1ZW50aWFsIGFuZCB0aGVyZWZvcmUgY2Fubm90XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGxpbmtlZCB0byBhIHNwZWNpZmljIHdyaXRlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXdhaXQgdGhlIG5leHQgY2FsbCBmb3IgYXMgbWFueSB0aW1lcyBhcyB0aGVyZSBhcmUgaXRlbXMgaW4gdGhlIHF1ZXVlICsgMVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBpdGVtcyBpbiB0aGUgd3JpdGUgcXVldWUgdGhhdCBtZWFucyB3cml0ZSBoYXBwZW5lZCBhbmQgd2UganVzdCBoYXZlXG4gICAgICAgICAgICAvLyB0byB3YWl0IGZvciBvbmUgbW9yZSBjYWxsIGxpa2V3aXNlIGlmIHdlIGFyZSB0aGUgbnRoIHdyaXRlIGluIHRoZSBxdWV1ZSB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSB0byB3YWl0IGZvciBuIHdyaXRlcyB0byBjb21wbGV0ZSBhbmQgb25lIG1vcmUuXG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHdyaXRlUXVldWUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5leHRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSBuZXh0UHJvbWlzZSB0byBpbmRpY2F0ZVxuICAgICAgICAgICAgICAgICAgICAvLyBwZW5kaW5nIHdyaXRlcyB0aGF0IGEgcmVhZCBhdHRlbXB0IGhhcyBiZWVuIG1hZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlaXIgd3JpdGUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byByZXNldCB0aGUgcHJvbWlzZSBmb3IgZnV0dXJlIHdyaXRlcy5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGUgPSB3cml0ZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3cml0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHBlbmRpbmcgd3JpdGUgc28gcmVzcG9uc2Ugd2l0aCB0aGUgcGF5bG9hZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHdyaXRlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHJldHVybiBhIHByb21pc2UgaW1tZWRpYXRlbHkgdGhhdCBpcyBlaXRoZXIgcmVzb2x2ZWQvcmVqZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgd3JpdGVzIGhhcHBlbi5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWRSZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAocmVhZFJlc29sdmUgPSByZXNvbHZlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRRdWV1ZS5wdXNoKHJlYWRSZXNvbHZlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRocm93KHRocm93RXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IHRocm93RXJyO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZVF1ZXVlLnNwbGljZSgwLCB3cml0ZVF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBuZXh0UHJvbWlzZSBpcyBhbHdheXMgcmVzb2x2ZWQuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVqZWN0IGFsbCBwZW5kaW5nIHdyaXRlcy5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBkcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJldHVybigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVRdWV1ZS5zcGxpY2UoMCwgd3JpdGVRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIG9uY2UgZm9yIHRoZSB3cml0ZSBhd2FpdGluZyBjb25maXJtYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCBhbGwgZnV0dXJlIHdyaXRlcy5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJjYW5ub3Qgd3JpdGUsIGNvbnN1bWVyIGNhbGxlZCByZXR1cm5cIikpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB0aGUgbmV4dFByb21pc2UgaXMgYWx3YXlzIHJlc29sdmVkLlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFzeW5jaHJvbm91cyBpdGVyYWJsZSBmcm9tIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3luY0l0ZXJhYmxlKGl0ZW1zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogY3JlYXRlQXN5bmNJdGVyYWJsZV8xKCkge1xuICAgICAgICB5aWVsZCBfX2F3YWl0KHlpZWxkKiBfX2FzeW5jRGVsZWdhdG9yKF9fYXN5bmNWYWx1ZXMoaXRlbXMpKSk7XG4gICAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/async-iterable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compressedFlag: () => (/* binding */ compressedFlag),\n/* harmony export */   compressionNegotiate: () => (/* binding */ compressionNegotiate)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * compressedFlag indicates that the data in a EnvelopedMessage is\n * compressed. It has the same meaning in the gRPC-Web, gRPC-HTTP2,\n * and Connect protocols.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nconst compressedFlag = 0b00000001;\n/**\n * Validates the request encoding and determines the accepted response encoding.\n *\n * Returns the request and response compression to use. If the client requested\n * an encoding that is not available, the returned object contains an error that\n * must be used for the response.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction compressionNegotiate(available, requested, // e.g. the value of the Grpc-Encoding header\naccepted, // e.g. the value of the Grpc-Accept-Encoding header\nheaderNameAcceptEncoding) {\n    let request = null;\n    let response = null;\n    let error = undefined;\n    if (requested !== null && requested !== \"identity\") {\n        const found = available.find((c) => c.name === requested);\n        if (found) {\n            request = found;\n        }\n        else {\n            // To comply with https://github.com/grpc/grpc/blob/master/doc/compression.md\n            // and the Connect protocol, we return code \"unimplemented\" and specify\n            // acceptable compression(s).\n            const acceptable = available.map((c) => c.name).join(\",\");\n            error = new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`unknown compression \"${requested}\": supported encodings are ${acceptable}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Unimplemented, {\n                [headerNameAcceptEncoding]: acceptable,\n            });\n        }\n    }\n    if (accepted === null || accepted === \"\") {\n        // Support asymmetric compression. This logic follows\n        // https://github.com/grpc/grpc/blob/master/doc/compression.md and common\n        // sense.\n        response = request;\n    }\n    else {\n        const acceptNames = accepted.split(\",\").map((n) => n.trim());\n        for (const name of acceptNames) {\n            const found = available.find((c) => c.name === name);\n            if (found) {\n                response = found;\n                break;\n            }\n        }\n    }\n    return { request, response, error };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9jb21wcmVzc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDakI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFZLHlCQUF5QixVQUFVLDZCQUE2QixXQUFXLEdBQUcsMENBQUk7QUFDdEg7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY28vZXRob3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9jb21wcmVzc2lvbi5qcz80ODc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG4vKipcbiAqIGNvbXByZXNzZWRGbGFnIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGluIGEgRW52ZWxvcGVkTWVzc2FnZSBpc1xuICogY29tcHJlc3NlZC4gSXQgaGFzIHRoZSBzYW1lIG1lYW5pbmcgaW4gdGhlIGdSUEMtV2ViLCBnUlBDLUhUVFAyLFxuICogYW5kIENvbm5lY3QgcHJvdG9jb2xzLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgY29uc3QgY29tcHJlc3NlZEZsYWcgPSAwYjAwMDAwMDAxO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHJlcXVlc3QgZW5jb2RpbmcgYW5kIGRldGVybWluZXMgdGhlIGFjY2VwdGVkIHJlc3BvbnNlIGVuY29kaW5nLlxuICpcbiAqIFJldHVybnMgdGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGNvbXByZXNzaW9uIHRvIHVzZS4gSWYgdGhlIGNsaWVudCByZXF1ZXN0ZWRcbiAqIGFuIGVuY29kaW5nIHRoYXQgaXMgbm90IGF2YWlsYWJsZSwgdGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyBhbiBlcnJvciB0aGF0XG4gKiBtdXN0IGJlIHVzZWQgZm9yIHRoZSByZXNwb25zZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXByZXNzaW9uTmVnb3RpYXRlKGF2YWlsYWJsZSwgcmVxdWVzdGVkLCAvLyBlLmcuIHRoZSB2YWx1ZSBvZiB0aGUgR3JwYy1FbmNvZGluZyBoZWFkZXJcbmFjY2VwdGVkLCAvLyBlLmcuIHRoZSB2YWx1ZSBvZiB0aGUgR3JwYy1BY2NlcHQtRW5jb2RpbmcgaGVhZGVyXG5oZWFkZXJOYW1lQWNjZXB0RW5jb2RpbmcpIHtcbiAgICBsZXQgcmVxdWVzdCA9IG51bGw7XG4gICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICBsZXQgZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHJlcXVlc3RlZCAhPT0gbnVsbCAmJiByZXF1ZXN0ZWQgIT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgICBjb25zdCBmb3VuZCA9IGF2YWlsYWJsZS5maW5kKChjKSA9PiBjLm5hbWUgPT09IHJlcXVlc3RlZCk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgcmVxdWVzdCA9IGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVG8gY29tcGx5IHdpdGggaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2MvY29tcHJlc3Npb24ubWRcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgQ29ubmVjdCBwcm90b2NvbCwgd2UgcmV0dXJuIGNvZGUgXCJ1bmltcGxlbWVudGVkXCIgYW5kIHNwZWNpZnlcbiAgICAgICAgICAgIC8vIGFjY2VwdGFibGUgY29tcHJlc3Npb24ocykuXG4gICAgICAgICAgICBjb25zdCBhY2NlcHRhYmxlID0gYXZhaWxhYmxlLm1hcCgoYykgPT4gYy5uYW1lKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IENvbm5lY3RFcnJvcihgdW5rbm93biBjb21wcmVzc2lvbiBcIiR7cmVxdWVzdGVkfVwiOiBzdXBwb3J0ZWQgZW5jb2RpbmdzIGFyZSAke2FjY2VwdGFibGV9YCwgQ29kZS5VbmltcGxlbWVudGVkLCB7XG4gICAgICAgICAgICAgICAgW2hlYWRlck5hbWVBY2NlcHRFbmNvZGluZ106IGFjY2VwdGFibGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWNjZXB0ZWQgPT09IG51bGwgfHwgYWNjZXB0ZWQgPT09IFwiXCIpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBhc3ltbWV0cmljIGNvbXByZXNzaW9uLiBUaGlzIGxvZ2ljIGZvbGxvd3NcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2MvY29tcHJlc3Npb24ubWQgYW5kIGNvbW1vblxuICAgICAgICAvLyBzZW5zZS5cbiAgICAgICAgcmVzcG9uc2UgPSByZXF1ZXN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgYWNjZXB0TmFtZXMgPSBhY2NlcHRlZC5zcGxpdChcIixcIikubWFwKChuKSA9PiBuLnRyaW0oKSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhY2NlcHROYW1lcykge1xuICAgICAgICAgICAgY29uc3QgZm91bmQgPSBhdmFpbGFibGUuZmluZCgoYykgPT4gYy5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMethodUrl: () => (/* binding */ createMethodUrl)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a URL for the given RPC. This simply adds the qualified\n * service name, a slash, and the method name to the path of the given\n * baseUrl.\n *\n * For example, the baseUri https://example.com and method \"Say\" from\n * the service example.ElizaService results in:\n * https://example.com/example.ElizaService/Say\n *\n * This format is used by the protocols Connect, gRPC and Twirp.\n *\n * Note that this function also accepts a protocol-relative baseUrl.\n * If given an empty string or \"/\" as a baseUrl, it returns just the\n * path.\n */\nfunction createMethodUrl(baseUrl, service, method) {\n    const s = typeof service == \"string\" ? service : service.typeName;\n    const m = typeof method == \"string\" ? method : method.name;\n    return baseUrl.toString().replace(/\\/?$/, `/${s}/${m}`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9jcmVhdGUtbWV0aG9kLXVybC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSxHQUFHLEVBQUU7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2NyZWF0ZS1tZXRob2QtdXJsLmpzPzcyMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ3JlYXRlIGEgVVJMIGZvciB0aGUgZ2l2ZW4gUlBDLiBUaGlzIHNpbXBseSBhZGRzIHRoZSBxdWFsaWZpZWRcbiAqIHNlcnZpY2UgbmFtZSwgYSBzbGFzaCwgYW5kIHRoZSBtZXRob2QgbmFtZSB0byB0aGUgcGF0aCBvZiB0aGUgZ2l2ZW5cbiAqIGJhc2VVcmwuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoZSBiYXNlVXJpIGh0dHBzOi8vZXhhbXBsZS5jb20gYW5kIG1ldGhvZCBcIlNheVwiIGZyb21cbiAqIHRoZSBzZXJ2aWNlIGV4YW1wbGUuRWxpemFTZXJ2aWNlIHJlc3VsdHMgaW46XG4gKiBodHRwczovL2V4YW1wbGUuY29tL2V4YW1wbGUuRWxpemFTZXJ2aWNlL1NheVxuICpcbiAqIFRoaXMgZm9ybWF0IGlzIHVzZWQgYnkgdGhlIHByb3RvY29scyBDb25uZWN0LCBnUlBDIGFuZCBUd2lycC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhbHNvIGFjY2VwdHMgYSBwcm90b2NvbC1yZWxhdGl2ZSBiYXNlVXJsLlxuICogSWYgZ2l2ZW4gYW4gZW1wdHkgc3RyaW5nIG9yIFwiL1wiIGFzIGEgYmFzZVVybCwgaXQgcmV0dXJucyBqdXN0IHRoZVxuICogcGF0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZFVybChiYXNlVXJsLCBzZXJ2aWNlLCBtZXRob2QpIHtcbiAgICBjb25zdCBzID0gdHlwZW9mIHNlcnZpY2UgPT0gXCJzdHJpbmdcIiA/IHNlcnZpY2UgOiBzZXJ2aWNlLnR5cGVOYW1lO1xuICAgIGNvbnN0IG0gPSB0eXBlb2YgbWV0aG9kID09IFwic3RyaW5nXCIgPyBtZXRob2QgOiBtZXRob2QubmFtZTtcbiAgICByZXR1cm4gYmFzZVVybC50b1N0cmluZygpLnJlcGxhY2UoL1xcLz8kLywgYC8ke3N9LyR7bX1gKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/create-method-url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js":
/*!************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEnvelopeReadableStream: () => (/* binding */ createEnvelopeReadableStream),\n/* harmony export */   encodeEnvelope: () => (/* binding */ encodeEnvelope),\n/* harmony export */   encodeEnvelopes: () => (/* binding */ encodeEnvelopes),\n/* harmony export */   envelopeCompress: () => (/* binding */ envelopeCompress),\n/* harmony export */   envelopeDecompress: () => (/* binding */ envelopeDecompress)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _compression_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/compression.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Create a WHATWG ReadableStream of enveloped messages from a ReadableStream\n * of bytes.\n *\n * Ideally, this would simply be a TransformStream, but ReadableStream.pipeThrough\n * does not have the necessary availability at this time.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createEnvelopeReadableStream(stream) {\n    let reader;\n    let buffer = new Uint8Array(0);\n    function append(chunk) {\n        const n = new Uint8Array(buffer.length + chunk.length);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        buffer = n;\n    }\n    return new ReadableStream({\n        start() {\n            reader = stream.getReader();\n        },\n        async pull(controller) {\n            let header = undefined;\n            for (;;) {\n                if (header === undefined && buffer.byteLength >= 5) {\n                    let length = 0;\n                    for (let i = 1; i < 5; i++) {\n                        length = (length << 8) + buffer[i];\n                    }\n                    header = { flags: buffer[0], length };\n                }\n                if (header !== undefined && buffer.byteLength >= header.length + 5) {\n                    break;\n                }\n                const result = await reader.read();\n                if (result.done) {\n                    break;\n                }\n                append(result.value);\n            }\n            if (header === undefined) {\n                if (buffer.byteLength == 0) {\n                    controller.close();\n                    return;\n                }\n                controller.error(new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"premature end of stream\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.DataLoss));\n                return;\n            }\n            const data = buffer.subarray(5, 5 + header.length);\n            buffer = buffer.subarray(5 + header.length);\n            controller.enqueue({\n                flags: header.flags,\n                data,\n            });\n        },\n    });\n}\n/**\n * Compress an EnvelopedMessage.\n *\n * Raises Internal if an enveloped message is already compressed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function envelopeCompress(envelope, compression, compressMinBytes) {\n    let { flags, data } = envelope;\n    if ((flags & _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag) === _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"invalid envelope, already compressed\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n    }\n    if (compression && data.byteLength >= compressMinBytes) {\n        data = await compression.compress(data);\n        flags = flags | _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag;\n    }\n    return { data, flags };\n}\n/**\n * Decompress an EnvelopedMessage.\n *\n * Raises InvalidArgument if an envelope is compressed, but compression is null.\n *\n * Relies on the provided Compression to raise ResourceExhausted if the\n * *decompressed* message size is larger than readMaxBytes. If the envelope is\n * not compressed, readMaxBytes is not honored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nasync function envelopeDecompress(envelope, compression, readMaxBytes) {\n    let { flags, data } = envelope;\n    if ((flags & _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag) === _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag) {\n        if (!compression) {\n            throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"received compressed envelope, but do not know how to decompress\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n        }\n        data = await compression.decompress(data, readMaxBytes);\n        flags = flags ^ _compression_js__WEBPACK_IMPORTED_MODULE_2__.compressedFlag;\n    }\n    return { data, flags };\n}\n/**\n * Encode a single enveloped message.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction encodeEnvelope(flags, data) {\n    const bytes = new Uint8Array(data.length + 5);\n    bytes.set(data, 5);\n    const v = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    v.setUint8(0, flags); // first byte is flags\n    v.setUint32(1, data.length); // 4 bytes message length\n    return bytes;\n}\n/**\n * Encode a set of enveloped messages.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction encodeEnvelopes(...envelopes) {\n    const len = envelopes.reduce((previousValue, currentValue) => previousValue + currentValue.data.length + 5, 0);\n    const bytes = new Uint8Array(len);\n    const v = new DataView(bytes.buffer);\n    let offset = 0;\n    for (const e of envelopes) {\n        v.setUint8(offset, e.flags); // first byte is flags\n        v.setUint32(offset + 1, e.data.length); // 4 bytes message length\n        bytes.set(e.data, offset + 5);\n        offset += e.data.length + 5;\n    }\n    return bytes;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9lbnZlbG9wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21EO0FBQ2pCO0FBQ2dCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyREFBWSw0QkFBNEIsMENBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxVQUFVLGNBQWM7QUFDeEIsaUJBQWlCLDJEQUFjLE1BQU0sMkRBQWM7QUFDbkQsa0JBQWtCLDJEQUFZLHlDQUF5QywwQ0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQWM7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxVQUFVLGNBQWM7QUFDeEIsaUJBQWlCLDJEQUFjLE1BQU0sMkRBQWM7QUFDbkQ7QUFDQSxzQkFBc0IsMkRBQVksb0VBQW9FLDBDQUFJO0FBQzFHO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQWM7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY28vZXRob3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9lbnZlbG9wZS5qcz8yNjZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG5pbXBvcnQgeyBjb21wcmVzc2VkRmxhZyB9IGZyb20gXCIuL2NvbXByZXNzaW9uLmpzXCI7XG4vKipcbiAqIENyZWF0ZSBhIFdIQVRXRyBSZWFkYWJsZVN0cmVhbSBvZiBlbnZlbG9wZWQgbWVzc2FnZXMgZnJvbSBhIFJlYWRhYmxlU3RyZWFtXG4gKiBvZiBieXRlcy5cbiAqXG4gKiBJZGVhbGx5LCB0aGlzIHdvdWxkIHNpbXBseSBiZSBhIFRyYW5zZm9ybVN0cmVhbSwgYnV0IFJlYWRhYmxlU3RyZWFtLnBpcGVUaHJvdWdoXG4gKiBkb2VzIG5vdCBoYXZlIHRoZSBuZWNlc3NhcnkgYXZhaWxhYmlsaXR5IGF0IHRoaXMgdGltZS5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVudmVsb3BlUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgbGV0IHJlYWRlcjtcbiAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgZnVuY3Rpb24gYXBwZW5kKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IG4gPSBuZXcgVWludDhBcnJheShidWZmZXIubGVuZ3RoICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgbi5zZXQoYnVmZmVyKTtcbiAgICAgICAgbi5zZXQoY2h1bmssIGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBidWZmZXIgPSBuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgbGV0IGhlYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQgJiYgYnVmZmVyLmJ5dGVMZW5ndGggPj0gNSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggPDwgOCkgKyBidWZmZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0geyBmbGFnczogYnVmZmVyWzBdLCBsZW5ndGggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlciAhPT0gdW5kZWZpbmVkICYmIGJ1ZmZlci5ieXRlTGVuZ3RoID49IGhlYWRlci5sZW5ndGggKyA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwZW5kKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgQ29ubmVjdEVycm9yKFwicHJlbWF0dXJlIGVuZCBvZiBzdHJlYW1cIiwgQ29kZS5EYXRhTG9zcykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuc3ViYXJyYXkoNSwgNSArIGhlYWRlci5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KDUgKyBoZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgZmxhZ3M6IGhlYWRlci5mbGFncyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENvbXByZXNzIGFuIEVudmVsb3BlZE1lc3NhZ2UuXG4gKlxuICogUmFpc2VzIEludGVybmFsIGlmIGFuIGVudmVsb3BlZCBtZXNzYWdlIGlzIGFscmVhZHkgY29tcHJlc3NlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVudmVsb3BlQ29tcHJlc3MoZW52ZWxvcGUsIGNvbXByZXNzaW9uLCBjb21wcmVzc01pbkJ5dGVzKSB7XG4gICAgbGV0IHsgZmxhZ3MsIGRhdGEgfSA9IGVudmVsb3BlO1xuICAgIGlmICgoZmxhZ3MgJiBjb21wcmVzc2VkRmxhZykgPT09IGNvbXByZXNzZWRGbGFnKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoXCJpbnZhbGlkIGVudmVsb3BlLCBhbHJlYWR5IGNvbXByZXNzZWRcIiwgQ29kZS5JbnRlcm5hbCk7XG4gICAgfVxuICAgIGlmIChjb21wcmVzc2lvbiAmJiBkYXRhLmJ5dGVMZW5ndGggPj0gY29tcHJlc3NNaW5CeXRlcykge1xuICAgICAgICBkYXRhID0gYXdhaXQgY29tcHJlc3Npb24uY29tcHJlc3MoZGF0YSk7XG4gICAgICAgIGZsYWdzID0gZmxhZ3MgfCBjb21wcmVzc2VkRmxhZztcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YSwgZmxhZ3MgfTtcbn1cbi8qKlxuICogRGVjb21wcmVzcyBhbiBFbnZlbG9wZWRNZXNzYWdlLlxuICpcbiAqIFJhaXNlcyBJbnZhbGlkQXJndW1lbnQgaWYgYW4gZW52ZWxvcGUgaXMgY29tcHJlc3NlZCwgYnV0IGNvbXByZXNzaW9uIGlzIG51bGwuXG4gKlxuICogUmVsaWVzIG9uIHRoZSBwcm92aWRlZCBDb21wcmVzc2lvbiB0byByYWlzZSBSZXNvdXJjZUV4aGF1c3RlZCBpZiB0aGVcbiAqICpkZWNvbXByZXNzZWQqIG1lc3NhZ2Ugc2l6ZSBpcyBsYXJnZXIgdGhhbiByZWFkTWF4Qnl0ZXMuIElmIHRoZSBlbnZlbG9wZSBpc1xuICogbm90IGNvbXByZXNzZWQsIHJlYWRNYXhCeXRlcyBpcyBub3QgaG9ub3JlZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVudmVsb3BlRGVjb21wcmVzcyhlbnZlbG9wZSwgY29tcHJlc3Npb24sIHJlYWRNYXhCeXRlcykge1xuICAgIGxldCB7IGZsYWdzLCBkYXRhIH0gPSBlbnZlbG9wZTtcbiAgICBpZiAoKGZsYWdzICYgY29tcHJlc3NlZEZsYWcpID09PSBjb21wcmVzc2VkRmxhZykge1xuICAgICAgICBpZiAoIWNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKFwicmVjZWl2ZWQgY29tcHJlc3NlZCBlbnZlbG9wZSwgYnV0IGRvIG5vdCBrbm93IGhvdyB0byBkZWNvbXByZXNzXCIsIENvZGUuSW50ZXJuYWwpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBhd2FpdCBjb21wcmVzc2lvbi5kZWNvbXByZXNzKGRhdGEsIHJlYWRNYXhCeXRlcyk7XG4gICAgICAgIGZsYWdzID0gZmxhZ3MgXiBjb21wcmVzc2VkRmxhZztcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YSwgZmxhZ3MgfTtcbn1cbi8qKlxuICogRW5jb2RlIGEgc2luZ2xlIGVudmVsb3BlZCBtZXNzYWdlLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRW52ZWxvcGUoZmxhZ3MsIGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgNSk7XG4gICAgYnl0ZXMuc2V0KGRhdGEsIDUpO1xuICAgIGNvbnN0IHYgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICB2LnNldFVpbnQ4KDAsIGZsYWdzKTsgLy8gZmlyc3QgYnl0ZSBpcyBmbGFnc1xuICAgIHYuc2V0VWludDMyKDEsIGRhdGEubGVuZ3RoKTsgLy8gNCBieXRlcyBtZXNzYWdlIGxlbmd0aFxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogRW5jb2RlIGEgc2V0IG9mIGVudmVsb3BlZCBtZXNzYWdlcy5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUVudmVsb3BlcyguLi5lbnZlbG9wZXMpIHtcbiAgICBjb25zdCBsZW4gPSBlbnZlbG9wZXMucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHByZXZpb3VzVmFsdWUgKyBjdXJyZW50VmFsdWUuZGF0YS5sZW5ndGggKyA1LCAwKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgY29uc3QgdiA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgZSBvZiBlbnZlbG9wZXMpIHtcbiAgICAgICAgdi5zZXRVaW50OChvZmZzZXQsIGUuZmxhZ3MpOyAvLyBmaXJzdCBieXRlIGlzIGZsYWdzXG4gICAgICAgIHYuc2V0VWludDMyKG9mZnNldCArIDEsIGUuZGF0YS5sZW5ndGgpOyAvLyA0IGJ5dGVzIG1lc3NhZ2UgbGVuZ3RoXG4gICAgICAgIGJ5dGVzLnNldChlLmRhdGEsIG9mZnNldCArIDUpO1xuICAgICAgICBvZmZzZXQgKz0gZS5kYXRhLmxlbmd0aCArIDU7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/envelope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js":
/*!************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertReadMaxBytes: () => (/* binding */ assertReadMaxBytes),\n/* harmony export */   assertWriteMaxBytes: () => (/* binding */ assertWriteMaxBytes),\n/* harmony export */   validateReadWriteMaxBytes: () => (/* binding */ validateReadWriteMaxBytes)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * At most, allow ~4GiB to be received or sent per message.\n * zlib used by Node.js caps maxOutputLength at this value. It also happens to\n * be the maximum theoretical message size supported by protobuf-es.\n */\nconst maxReadMaxBytes = 0xffffffff;\nconst maxWriteMaxBytes = maxReadMaxBytes;\n/**\n * The default value for the compressMinBytes option. The CPU cost of compressing\n * very small messages usually isn't worth the small reduction in network I/O, so\n * the default value is 1 kibibyte.\n */\nconst defaultCompressMinBytes = 1024;\n/**\n * Asserts that the options writeMaxBytes, readMaxBytes, and compressMinBytes\n * are within sane limits, and returns default values where no value is\n * provided.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction validateReadWriteMaxBytes(readMaxBytes, writeMaxBytes, compressMinBytes) {\n    writeMaxBytes !== null && writeMaxBytes !== void 0 ? writeMaxBytes : (writeMaxBytes = maxWriteMaxBytes);\n    readMaxBytes !== null && readMaxBytes !== void 0 ? readMaxBytes : (readMaxBytes = maxReadMaxBytes);\n    compressMinBytes !== null && compressMinBytes !== void 0 ? compressMinBytes : (compressMinBytes = defaultCompressMinBytes);\n    if (writeMaxBytes < 1 || writeMaxBytes > maxWriteMaxBytes) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`writeMaxBytes ${writeMaxBytes} must be >= 1 and <= ${maxWriteMaxBytes}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n    }\n    if (readMaxBytes < 1 || readMaxBytes > maxReadMaxBytes) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`readMaxBytes ${readMaxBytes} must be >= 1 and <= ${maxReadMaxBytes}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.Internal);\n    }\n    return {\n        readMaxBytes,\n        writeMaxBytes,\n        compressMinBytes,\n    };\n}\n/**\n * Raise an error ResourceExhausted if more than writeMaxByte are written.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction assertWriteMaxBytes(writeMaxBytes, bytesWritten) {\n    if (bytesWritten > writeMaxBytes) {\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(`message size ${bytesWritten} is larger than configured writeMaxBytes ${writeMaxBytes}`, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.ResourceExhausted);\n    }\n}\n/**\n * Raise an error ResourceExhausted if more than readMaxBytes are read.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction assertReadMaxBytes(readMaxBytes, bytesRead, totalSizeKnown = false) {\n    if (bytesRead > readMaxBytes) {\n        let message = `message size is larger than configured readMaxBytes ${readMaxBytes}`;\n        if (totalSizeKnown) {\n            message = `message size ${bytesRead} is larger than configured readMaxBytes ${readMaxBytes}`;\n        }\n        throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(message, _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.ResourceExhausted);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9saW1pdC1pby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21EO0FBQ2pCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFZLGtCQUFrQixlQUFlLHNCQUFzQixpQkFBaUIsR0FBRywwQ0FBSTtBQUM3RztBQUNBO0FBQ0Esa0JBQWtCLDJEQUFZLGlCQUFpQixjQUFjLHNCQUFzQixnQkFBZ0IsR0FBRywwQ0FBSTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLDJEQUFZLGlCQUFpQixjQUFjLDBDQUEwQyxjQUFjLEdBQUcsMENBQUk7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNkVBQTZFLGFBQWE7QUFDMUY7QUFDQSxzQ0FBc0MsV0FBVyx5Q0FBeUMsYUFBYTtBQUN2RztBQUNBLGtCQUFrQiwyREFBWSxVQUFVLDBDQUFJO0FBQzVDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL2xpbWl0LWlvLmpzPzBiOGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBUaGUgQ29ubmVjdCBBdXRob3JzXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IENvbm5lY3RFcnJvciB9IGZyb20gXCIuLi9jb25uZWN0LWVycm9yLmpzXCI7XG5pbXBvcnQgeyBDb2RlIH0gZnJvbSBcIi4uL2NvZGUuanNcIjtcbi8qKlxuICogQXQgbW9zdCwgYWxsb3cgfjRHaUIgdG8gYmUgcmVjZWl2ZWQgb3Igc2VudCBwZXIgbWVzc2FnZS5cbiAqIHpsaWIgdXNlZCBieSBOb2RlLmpzIGNhcHMgbWF4T3V0cHV0TGVuZ3RoIGF0IHRoaXMgdmFsdWUuIEl0IGFsc28gaGFwcGVucyB0b1xuICogYmUgdGhlIG1heGltdW0gdGhlb3JldGljYWwgbWVzc2FnZSBzaXplIHN1cHBvcnRlZCBieSBwcm90b2J1Zi1lcy5cbiAqL1xuY29uc3QgbWF4UmVhZE1heEJ5dGVzID0gMHhmZmZmZmZmZjtcbmNvbnN0IG1heFdyaXRlTWF4Qnl0ZXMgPSBtYXhSZWFkTWF4Qnl0ZXM7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgY29tcHJlc3NNaW5CeXRlcyBvcHRpb24uIFRoZSBDUFUgY29zdCBvZiBjb21wcmVzc2luZ1xuICogdmVyeSBzbWFsbCBtZXNzYWdlcyB1c3VhbGx5IGlzbid0IHdvcnRoIHRoZSBzbWFsbCByZWR1Y3Rpb24gaW4gbmV0d29yayBJL08sIHNvXG4gKiB0aGUgZGVmYXVsdCB2YWx1ZSBpcyAxIGtpYmlieXRlLlxuICovXG5jb25zdCBkZWZhdWx0Q29tcHJlc3NNaW5CeXRlcyA9IDEwMjQ7XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgb3B0aW9ucyB3cml0ZU1heEJ5dGVzLCByZWFkTWF4Qnl0ZXMsIGFuZCBjb21wcmVzc01pbkJ5dGVzXG4gKiBhcmUgd2l0aGluIHNhbmUgbGltaXRzLCBhbmQgcmV0dXJucyBkZWZhdWx0IHZhbHVlcyB3aGVyZSBubyB2YWx1ZSBpc1xuICogcHJvdmlkZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJlYWRXcml0ZU1heEJ5dGVzKHJlYWRNYXhCeXRlcywgd3JpdGVNYXhCeXRlcywgY29tcHJlc3NNaW5CeXRlcykge1xuICAgIHdyaXRlTWF4Qnl0ZXMgIT09IG51bGwgJiYgd3JpdGVNYXhCeXRlcyAhPT0gdm9pZCAwID8gd3JpdGVNYXhCeXRlcyA6ICh3cml0ZU1heEJ5dGVzID0gbWF4V3JpdGVNYXhCeXRlcyk7XG4gICAgcmVhZE1heEJ5dGVzICE9PSBudWxsICYmIHJlYWRNYXhCeXRlcyAhPT0gdm9pZCAwID8gcmVhZE1heEJ5dGVzIDogKHJlYWRNYXhCeXRlcyA9IG1heFJlYWRNYXhCeXRlcyk7XG4gICAgY29tcHJlc3NNaW5CeXRlcyAhPT0gbnVsbCAmJiBjb21wcmVzc01pbkJ5dGVzICE9PSB2b2lkIDAgPyBjb21wcmVzc01pbkJ5dGVzIDogKGNvbXByZXNzTWluQnl0ZXMgPSBkZWZhdWx0Q29tcHJlc3NNaW5CeXRlcyk7XG4gICAgaWYgKHdyaXRlTWF4Qnl0ZXMgPCAxIHx8IHdyaXRlTWF4Qnl0ZXMgPiBtYXhXcml0ZU1heEJ5dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHdyaXRlTWF4Qnl0ZXMgJHt3cml0ZU1heEJ5dGVzfSBtdXN0IGJlID49IDEgYW5kIDw9ICR7bWF4V3JpdGVNYXhCeXRlc31gLCBDb2RlLkludGVybmFsKTtcbiAgICB9XG4gICAgaWYgKHJlYWRNYXhCeXRlcyA8IDEgfHwgcmVhZE1heEJ5dGVzID4gbWF4UmVhZE1heEJ5dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYHJlYWRNYXhCeXRlcyAke3JlYWRNYXhCeXRlc30gbXVzdCBiZSA+PSAxIGFuZCA8PSAke21heFJlYWRNYXhCeXRlc31gLCBDb2RlLkludGVybmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVhZE1heEJ5dGVzLFxuICAgICAgICB3cml0ZU1heEJ5dGVzLFxuICAgICAgICBjb21wcmVzc01pbkJ5dGVzLFxuICAgIH07XG59XG4vKipcbiAqIFJhaXNlIGFuIGVycm9yIFJlc291cmNlRXhoYXVzdGVkIGlmIG1vcmUgdGhhbiB3cml0ZU1heEJ5dGUgYXJlIHdyaXR0ZW4uXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRXcml0ZU1heEJ5dGVzKHdyaXRlTWF4Qnl0ZXMsIGJ5dGVzV3JpdHRlbikge1xuICAgIGlmIChieXRlc1dyaXR0ZW4gPiB3cml0ZU1heEJ5dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IoYG1lc3NhZ2Ugc2l6ZSAke2J5dGVzV3JpdHRlbn0gaXMgbGFyZ2VyIHRoYW4gY29uZmlndXJlZCB3cml0ZU1heEJ5dGVzICR7d3JpdGVNYXhCeXRlc31gLCBDb2RlLlJlc291cmNlRXhoYXVzdGVkKTtcbiAgICB9XG59XG4vKipcbiAqIFJhaXNlIGFuIGVycm9yIFJlc291cmNlRXhoYXVzdGVkIGlmIG1vcmUgdGhhbiByZWFkTWF4Qnl0ZXMgYXJlIHJlYWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRSZWFkTWF4Qnl0ZXMocmVhZE1heEJ5dGVzLCBieXRlc1JlYWQsIHRvdGFsU2l6ZUtub3duID0gZmFsc2UpIHtcbiAgICBpZiAoYnl0ZXNSZWFkID4gcmVhZE1heEJ5dGVzKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gYG1lc3NhZ2Ugc2l6ZSBpcyBsYXJnZXIgdGhhbiBjb25maWd1cmVkIHJlYWRNYXhCeXRlcyAke3JlYWRNYXhCeXRlc31gO1xuICAgICAgICBpZiAodG90YWxTaXplS25vd24pIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgbWVzc2FnZSBzaXplICR7Ynl0ZXNSZWFkfSBpcyBsYXJnZXIgdGhhbiBjb25maWd1cmVkIHJlYWRNYXhCeXRlcyAke3JlYWRNYXhCeXRlc31gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0RXJyb3IobWVzc2FnZSwgQ29kZS5SZXNvdXJjZUV4aGF1c3RlZCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeIterable: () => (/* binding */ normalizeIterable)\n/* harmony export */ });\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n *  Takes a partial protobuf messages of the\n *  specified message type as input, and returns full instances.\n */\nfunction normalize(type, message) {\n    return message instanceof type\n        ? message\n        : new type(message);\n}\n/**\n * Takes an AsyncIterable of partial protobuf messages of the\n * specified message type as input, and yields full instances.\n */\nfunction normalizeIterable(messageType, input) {\n    function transform(result) {\n        if (result.done === true) {\n            return result;\n        }\n        return {\n            done: result.done,\n            value: normalize(messageType, result.value),\n        };\n    }\n    return {\n        [Symbol.asyncIterator]() {\n            const it = input[Symbol.asyncIterator]();\n            const res = {\n                next: () => it.next().then(transform),\n            };\n            if (it.throw !== undefined) {\n                res.throw = (e) => it.throw(e).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            if (it.return !== undefined) {\n                res.return = (v) => it.return(v).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            return res;\n        },\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9ub3JtYWxpemUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL25vcm1hbGl6ZS5qcz8yMWZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1ZlwiO1xuLyoqXG4gKiAgVGFrZXMgYSBwYXJ0aWFsIHByb3RvYnVmIG1lc3NhZ2VzIG9mIHRoZVxuICogIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUgYXMgaW5wdXQsIGFuZCByZXR1cm5zIGZ1bGwgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZSBpbnN0YW5jZW9mIHR5cGVcbiAgICAgICAgPyBtZXNzYWdlXG4gICAgICAgIDogbmV3IHR5cGUobWVzc2FnZSk7XG59XG4vKipcbiAqIFRha2VzIGFuIEFzeW5jSXRlcmFibGUgb2YgcGFydGlhbCBwcm90b2J1ZiBtZXNzYWdlcyBvZiB0aGVcbiAqIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUgYXMgaW5wdXQsIGFuZCB5aWVsZHMgZnVsbCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVJdGVyYWJsZShtZXNzYWdlVHlwZSwgaW5wdXQpIHtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogcmVzdWx0LmRvbmUsXG4gICAgICAgICAgICB2YWx1ZTogbm9ybWFsaXplKG1lc3NhZ2VUeXBlLCByZXN1bHQudmFsdWUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgY29uc3QgaXQgPSBpbnB1dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiAoKSA9PiBpdC5uZXh0KCkudGhlbih0cmFuc2Zvcm0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpdC50aHJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzLnRocm93ID0gKGUpID0+IGl0LnRocm93KGUpLnRoZW4odHJhbnNmb3JtKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQucmV0dXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMucmV0dXJuID0gKHYpID0+IGl0LnJldHVybih2KS50aGVuKHRyYW5zZm9ybSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js":
/*!************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   runStreamingCall: () => (/* binding */ runStreamingCall),\n/* harmony export */   runUnaryCall: () => (/* binding */ runUnaryCall)\n/* harmony export */ });\n/* harmony import */ var _interceptor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interceptor.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/interceptor.js\");\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _signals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signals.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js\");\n/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalize.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/normalize.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n\n/**\n * Runs a unary method with the given interceptors. Note that this function\n * is only used when implementing a Transport.\n */\nfunction runUnaryCall(opt) {\n    const next = (0,_interceptor_js__WEBPACK_IMPORTED_MODULE_0__.applyInterceptors)(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), { message: (0,_normalize_js__WEBPACK_IMPORTED_MODULE_1__.normalize)(opt.req.method.I, opt.req.message), signal });\n    return next(req).then((res) => {\n        done();\n        return res;\n    }, abort);\n}\n/**\n * Runs a server-streaming method with the given interceptors. Note that this\n * function is only used when implementing a Transport.\n */\nfunction runStreamingCall(opt) {\n    const next = (0,_interceptor_js__WEBPACK_IMPORTED_MODULE_0__.applyInterceptors)(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), { message: (0,_normalize_js__WEBPACK_IMPORTED_MODULE_1__.normalizeIterable)(opt.req.method.I, opt.req.message), signal });\n    let doneCalled = false;\n    // Call return on the request iterable to indicate\n    // that we will no longer consume it and it should\n    // cleanup any allocated resources.\n    signal.addEventListener(\"abort\", function () {\n        var _a, _b;\n        const it = opt.req.message[Symbol.asyncIterator]();\n        // If the signal is aborted due to an error, we want to throw\n        // the error to the request iterator.\n        if (!doneCalled) {\n            (_a = it.throw) === null || _a === void 0 ? void 0 : _a.call(it, this.reason).catch(() => {\n                // throw returns a promise, which we don't care about.\n                //\n                // Uncaught promises are thrown at sometime/somewhere by the event loop,\n                // this is to ensure error is caught and ignored.\n            });\n        }\n        (_b = it.return) === null || _b === void 0 ? void 0 : _b.call(it).catch(() => {\n            // return returns a promise, which we don't care about.\n            //\n            // Uncaught promises are thrown at sometime/somewhere by the event loop,\n            // this is to ensure error is caught and ignored.\n        });\n    });\n    return next(req).then((res) => {\n        return Object.assign(Object.assign({}, res), { message: {\n                [Symbol.asyncIterator]() {\n                    const it = res.message[Symbol.asyncIterator]();\n                    return {\n                        next() {\n                            return it.next().then((r) => {\n                                if (r.done == true) {\n                                    doneCalled = true;\n                                    done();\n                                }\n                                return r;\n                            }, abort);\n                        },\n                        // We deliberately omit throw/return.\n                    };\n                },\n            } });\n    }, abort);\n}\n/**\n * Create an AbortSignal for Transport implementations. The signal is available\n * in UnaryRequest and StreamingRequest, and is triggered when the call is\n * aborted (via a timeout or explicit cancellation), errored (e.g. when reading\n * an error from the server from the wire), or finished successfully.\n *\n * Transport implementations can pass the signal to HTTP clients to ensure that\n * there are no unused connections leak.\n *\n * Returns a tuple:\n * [0]: The signal, which is also aborted if the optional deadline is reached.\n * [1]: Function to call if the Transport encountered an error.\n * [2]: Function to call if the Transport finished without an error.\n */\nfunction setupSignal(opt) {\n    const { signal, cleanup } = (0,_signals_js__WEBPACK_IMPORTED_MODULE_2__.createDeadlineSignal)(opt.timeoutMs);\n    const controller = (0,_signals_js__WEBPACK_IMPORTED_MODULE_2__.createLinkedAbortController)(opt.signal, signal);\n    return [\n        controller.signal,\n        function abort(reason) {\n            // We peek at the deadline signal because fetch() will throw an error on\n            // abort that discards the signal reason.\n            const e = _connect_error_js__WEBPACK_IMPORTED_MODULE_3__.ConnectError.from(signal.aborted ? (0,_signals_js__WEBPACK_IMPORTED_MODULE_2__.getAbortSignalReason)(signal) : reason);\n            controller.abort(e);\n            cleanup();\n            return Promise.reject(e);\n        },\n        function done() {\n            cleanup();\n            controller.abort();\n        },\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9ydW4tY2FsbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDtBQUNIO0FBQ3FEO0FBQzFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsa0VBQWlCO0FBQ2xDO0FBQ0EsOENBQThDLGNBQWMsU0FBUyx3REFBUyw2Q0FBNkM7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixrRUFBaUI7QUFDbEM7QUFDQSw4Q0FBOEMsY0FBYyxTQUFTLGdFQUFpQiw2Q0FBNkM7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0IsRUFBRSxpRUFBb0I7QUFDcEQsdUJBQXVCLHdFQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFZLHVCQUF1QixpRUFBb0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY28vZXRob3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9ydW4tY2FsbC5qcz8zMjg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBhcHBseUludGVyY2VwdG9ycyB9IGZyb20gXCIuLi9pbnRlcmNlcHRvci5qc1wiO1xuaW1wb3J0IHsgQ29ubmVjdEVycm9yIH0gZnJvbSBcIi4uL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IGNyZWF0ZURlYWRsaW5lU2lnbmFsLCBjcmVhdGVMaW5rZWRBYm9ydENvbnRyb2xsZXIsIGdldEFib3J0U2lnbmFsUmVhc29uLCB9IGZyb20gXCIuL3NpZ25hbHMuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZSwgbm9ybWFsaXplSXRlcmFibGUgfSBmcm9tIFwiLi9ub3JtYWxpemUuanNcIjtcbi8qKlxuICogUnVucyBhIHVuYXJ5IG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBpbnRlcmNlcHRvcnMuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uXG4gKiBpcyBvbmx5IHVzZWQgd2hlbiBpbXBsZW1lbnRpbmcgYSBUcmFuc3BvcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5VbmFyeUNhbGwob3B0KSB7XG4gICAgY29uc3QgbmV4dCA9IGFwcGx5SW50ZXJjZXB0b3JzKG9wdC5uZXh0LCBvcHQuaW50ZXJjZXB0b3JzKTtcbiAgICBjb25zdCBbc2lnbmFsLCBhYm9ydCwgZG9uZV0gPSBzZXR1cFNpZ25hbChvcHQpO1xuICAgIGNvbnN0IHJlcSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0LnJlcSksIHsgbWVzc2FnZTogbm9ybWFsaXplKG9wdC5yZXEubWV0aG9kLkksIG9wdC5yZXEubWVzc2FnZSksIHNpZ25hbCB9KTtcbiAgICByZXR1cm4gbmV4dChyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgYWJvcnQpO1xufVxuLyoqXG4gKiBSdW5zIGEgc2VydmVyLXN0cmVhbWluZyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJjZXB0b3JzLiBOb3RlIHRoYXQgdGhpc1xuICogZnVuY3Rpb24gaXMgb25seSB1c2VkIHdoZW4gaW1wbGVtZW50aW5nIGEgVHJhbnNwb3J0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuU3RyZWFtaW5nQ2FsbChvcHQpIHtcbiAgICBjb25zdCBuZXh0ID0gYXBwbHlJbnRlcmNlcHRvcnMob3B0Lm5leHQsIG9wdC5pbnRlcmNlcHRvcnMpO1xuICAgIGNvbnN0IFtzaWduYWwsIGFib3J0LCBkb25lXSA9IHNldHVwU2lnbmFsKG9wdCk7XG4gICAgY29uc3QgcmVxID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHQucmVxKSwgeyBtZXNzYWdlOiBub3JtYWxpemVJdGVyYWJsZShvcHQucmVxLm1ldGhvZC5JLCBvcHQucmVxLm1lc3NhZ2UpLCBzaWduYWwgfSk7XG4gICAgbGV0IGRvbmVDYWxsZWQgPSBmYWxzZTtcbiAgICAvLyBDYWxsIHJldHVybiBvbiB0aGUgcmVxdWVzdCBpdGVyYWJsZSB0byBpbmRpY2F0ZVxuICAgIC8vIHRoYXQgd2Ugd2lsbCBubyBsb25nZXIgY29uc3VtZSBpdCBhbmQgaXQgc2hvdWxkXG4gICAgLy8gY2xlYW51cCBhbnkgYWxsb2NhdGVkIHJlc291cmNlcy5cbiAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgaXQgPSBvcHQucmVxLm1lc3NhZ2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgIC8vIElmIHRoZSBzaWduYWwgaXMgYWJvcnRlZCBkdWUgdG8gYW4gZXJyb3IsIHdlIHdhbnQgdG8gdGhyb3dcbiAgICAgICAgLy8gdGhlIGVycm9yIHRvIHRoZSByZXF1ZXN0IGl0ZXJhdG9yLlxuICAgICAgICBpZiAoIWRvbmVDYWxsZWQpIHtcbiAgICAgICAgICAgIChfYSA9IGl0LnRocm93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpdCwgdGhpcy5yZWFzb24pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyByZXR1cm5zIGEgcHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY2FyZSBhYm91dC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFVuY2F1Z2h0IHByb21pc2VzIGFyZSB0aHJvd24gYXQgc29tZXRpbWUvc29tZXdoZXJlIGJ5IHRoZSBldmVudCBsb29wLFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gZW5zdXJlIGVycm9yIGlzIGNhdWdodCBhbmQgaWdub3JlZC5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IGl0LnJldHVybikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoaXQpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHJldHVybiByZXR1cm5zIGEgcHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY2FyZSBhYm91dC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBVbmNhdWdodCBwcm9taXNlcyBhcmUgdGhyb3duIGF0IHNvbWV0aW1lL3NvbWV3aGVyZSBieSB0aGUgZXZlbnQgbG9vcCxcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gZW5zdXJlIGVycm9yIGlzIGNhdWdodCBhbmQgaWdub3JlZC5cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQocmVxKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzKSwgeyBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSByZXMubWVzc2FnZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0Lm5leHQoKS50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmRvbmUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgYWJvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRlbGliZXJhdGVseSBvbWl0IHRocm93L3JldHVybi5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSB9KTtcbiAgICB9LCBhYm9ydCk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBBYm9ydFNpZ25hbCBmb3IgVHJhbnNwb3J0IGltcGxlbWVudGF0aW9ucy4gVGhlIHNpZ25hbCBpcyBhdmFpbGFibGVcbiAqIGluIFVuYXJ5UmVxdWVzdCBhbmQgU3RyZWFtaW5nUmVxdWVzdCwgYW5kIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjYWxsIGlzXG4gKiBhYm9ydGVkICh2aWEgYSB0aW1lb3V0IG9yIGV4cGxpY2l0IGNhbmNlbGxhdGlvbiksIGVycm9yZWQgKGUuZy4gd2hlbiByZWFkaW5nXG4gKiBhbiBlcnJvciBmcm9tIHRoZSBzZXJ2ZXIgZnJvbSB0aGUgd2lyZSksIG9yIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseS5cbiAqXG4gKiBUcmFuc3BvcnQgaW1wbGVtZW50YXRpb25zIGNhbiBwYXNzIHRoZSBzaWduYWwgdG8gSFRUUCBjbGllbnRzIHRvIGVuc3VyZSB0aGF0XG4gKiB0aGVyZSBhcmUgbm8gdW51c2VkIGNvbm5lY3Rpb25zIGxlYWsuXG4gKlxuICogUmV0dXJucyBhIHR1cGxlOlxuICogWzBdOiBUaGUgc2lnbmFsLCB3aGljaCBpcyBhbHNvIGFib3J0ZWQgaWYgdGhlIG9wdGlvbmFsIGRlYWRsaW5lIGlzIHJlYWNoZWQuXG4gKiBbMV06IEZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhlIFRyYW5zcG9ydCBlbmNvdW50ZXJlZCBhbiBlcnJvci5cbiAqIFsyXTogRnVuY3Rpb24gdG8gY2FsbCBpZiB0aGUgVHJhbnNwb3J0IGZpbmlzaGVkIHdpdGhvdXQgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHNldHVwU2lnbmFsKG9wdCkge1xuICAgIGNvbnN0IHsgc2lnbmFsLCBjbGVhbnVwIH0gPSBjcmVhdGVEZWFkbGluZVNpZ25hbChvcHQudGltZW91dE1zKTtcbiAgICBjb25zdCBjb250cm9sbGVyID0gY3JlYXRlTGlua2VkQWJvcnRDb250cm9sbGVyKG9wdC5zaWduYWwsIHNpZ25hbCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgICAgLy8gV2UgcGVlayBhdCB0aGUgZGVhZGxpbmUgc2lnbmFsIGJlY2F1c2UgZmV0Y2goKSB3aWxsIHRocm93IGFuIGVycm9yIG9uXG4gICAgICAgICAgICAvLyBhYm9ydCB0aGF0IGRpc2NhcmRzIHRoZSBzaWduYWwgcmVhc29uLlxuICAgICAgICAgICAgY29uc3QgZSA9IENvbm5lY3RFcnJvci5mcm9tKHNpZ25hbC5hYm9ydGVkID8gZ2V0QWJvcnRTaWduYWxSZWFzb24oc2lnbmFsKSA6IHJlYXNvbik7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KGUpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9LFxuICAgIF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/run-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBinarySerialization: () => (/* binding */ createBinarySerialization),\n/* harmony export */   createClientMethodSerializers: () => (/* binding */ createClientMethodSerializers),\n/* harmony export */   createJsonSerialization: () => (/* binding */ createJsonSerialization),\n/* harmony export */   createMethodSerializationLookup: () => (/* binding */ createMethodSerializationLookup),\n/* harmony export */   getJsonOptions: () => (/* binding */ getJsonOptions),\n/* harmony export */   limitSerialization: () => (/* binding */ limitSerialization)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n/* harmony import */ var _limit_io_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./limit-io.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/limit-io.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n/**\n * Sets default JSON serialization options for connect-es.\n *\n * With standard protobuf JSON serialization, unknown JSON fields are\n * rejected by default. In connect-es, unknown JSON fields are ignored\n * by default.\n */\nfunction getJsonOptions(options) {\n    var _a;\n    const o = Object.assign({}, options);\n    (_a = o.ignoreUnknownFields) !== null && _a !== void 0 ? _a : (o.ignoreUnknownFields = true);\n    return o;\n}\n/**\n * Create an object that provides convenient access to request and response\n * message serialization for a given method.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createMethodSerializationLookup(method, binaryOptions, jsonOptions, limitOptions) {\n    const inputBinary = limitSerialization(createBinarySerialization(method.I, binaryOptions), limitOptions);\n    const inputJson = limitSerialization(createJsonSerialization(method.I, jsonOptions), limitOptions);\n    const outputBinary = limitSerialization(createBinarySerialization(method.O, binaryOptions), limitOptions);\n    const outputJson = limitSerialization(createJsonSerialization(method.O, jsonOptions), limitOptions);\n    return {\n        getI(useBinaryFormat) {\n            return useBinaryFormat ? inputBinary : inputJson;\n        },\n        getO(useBinaryFormat) {\n            return useBinaryFormat ? outputBinary : outputJson;\n        },\n    };\n}\n/**\n * Returns functions to normalize and serialize the input message\n * of an RPC, and to parse the output message of an RPC.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createClientMethodSerializers(method, useBinaryFormat, jsonOptions, binaryOptions) {\n    const input = useBinaryFormat\n        ? createBinarySerialization(method.I, binaryOptions)\n        : createJsonSerialization(method.I, jsonOptions);\n    const output = useBinaryFormat\n        ? createBinarySerialization(method.O, binaryOptions)\n        : createJsonSerialization(method.O, jsonOptions);\n    return { parse: output.parse, serialize: input.serialize };\n}\n/**\n * Apply I/O limits to a Serialization object, returning a new object.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction limitSerialization(serialization, limitOptions) {\n    return {\n        serialize(data) {\n            const bytes = serialization.serialize(data);\n            (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_0__.assertWriteMaxBytes)(limitOptions.writeMaxBytes, bytes.byteLength);\n            return bytes;\n        },\n        parse(data) {\n            (0,_limit_io_js__WEBPACK_IMPORTED_MODULE_0__.assertReadMaxBytes)(limitOptions.readMaxBytes, data.byteLength, true);\n            return serialization.parse(data);\n        },\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf binary format.\n */\nfunction createBinarySerialization(messageType, options) {\n    return {\n        parse(data) {\n            try {\n                return messageType.fromBinary(data, options);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`parse binary: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.Internal);\n            }\n        },\n        serialize(data) {\n            try {\n                return data.toBinary(options);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError(`serialize binary: ${m}`, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.Internal);\n            }\n        },\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf canonical JSON encoding.\n *\n * By default, unknown fields are ignored.\n */\nfunction createJsonSerialization(messageType, options) {\n    var _a, _b;\n    const textEncoder = (_a = options === null || options === void 0 ? void 0 : options.textEncoder) !== null && _a !== void 0 ? _a : new TextEncoder();\n    const textDecoder = (_b = options === null || options === void 0 ? void 0 : options.textDecoder) !== null && _b !== void 0 ? _b : new TextDecoder();\n    const o = getJsonOptions(options);\n    return {\n        parse(data) {\n            try {\n                const json = textDecoder.decode(data);\n                return messageType.fromJsonString(json, o);\n            }\n            catch (e) {\n                throw _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError.from(e, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.InvalidArgument);\n            }\n        },\n        serialize(data) {\n            try {\n                const json = data.toJsonString(o);\n                return textEncoder.encode(json);\n            }\n            catch (e) {\n                throw _connect_error_js__WEBPACK_IMPORTED_MODULE_1__.ConnectError.from(e, _code_js__WEBPACK_IMPORTED_MODULE_2__.Code.Internal);\n            }\n        },\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9zZXJpYWxpemF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21EO0FBQ2pCO0FBQ3NDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBbUI7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxZQUFZLGdFQUFrQjtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFZLGtCQUFrQixFQUFFLEdBQUcsMENBQUk7QUFDakU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFZLHNCQUFzQixFQUFFLEdBQUcsMENBQUk7QUFDckU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBWSxTQUFTLDBDQUFJO0FBQy9DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBWSxTQUFTLDBDQUFJO0FBQy9DO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29ubmVjdHJwYy9jb25uZWN0L2Rpc3QvZXNtL3Byb3RvY29sL3NlcmlhbGl6YXRpb24uanM/OTFkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IFRoZSBDb25uZWN0IEF1dGhvcnNcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgQ29ubmVjdEVycm9yIH0gZnJvbSBcIi4uL2Nvbm5lY3QtZXJyb3IuanNcIjtcbmltcG9ydCB7IENvZGUgfSBmcm9tIFwiLi4vY29kZS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0UmVhZE1heEJ5dGVzLCBhc3NlcnRXcml0ZU1heEJ5dGVzIH0gZnJvbSBcIi4vbGltaXQtaW8uanNcIjtcbi8qKlxuICogU2V0cyBkZWZhdWx0IEpTT04gc2VyaWFsaXphdGlvbiBvcHRpb25zIGZvciBjb25uZWN0LWVzLlxuICpcbiAqIFdpdGggc3RhbmRhcmQgcHJvdG9idWYgSlNPTiBzZXJpYWxpemF0aW9uLCB1bmtub3duIEpTT04gZmllbGRzIGFyZVxuICogcmVqZWN0ZWQgYnkgZGVmYXVsdC4gSW4gY29ubmVjdC1lcywgdW5rbm93biBKU09OIGZpZWxkcyBhcmUgaWdub3JlZFxuICogYnkgZGVmYXVsdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEpzb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIChfYSA9IG8uaWdub3JlVW5rbm93bkZpZWxkcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKG8uaWdub3JlVW5rbm93bkZpZWxkcyA9IHRydWUpO1xuICAgIHJldHVybiBvO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgY29udmVuaWVudCBhY2Nlc3MgdG8gcmVxdWVzdCBhbmQgcmVzcG9uc2VcbiAqIG1lc3NhZ2Ugc2VyaWFsaXphdGlvbiBmb3IgYSBnaXZlbiBtZXRob2QuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZXRob2RTZXJpYWxpemF0aW9uTG9va3VwKG1ldGhvZCwgYmluYXJ5T3B0aW9ucywganNvbk9wdGlvbnMsIGxpbWl0T3B0aW9ucykge1xuICAgIGNvbnN0IGlucHV0QmluYXJ5ID0gbGltaXRTZXJpYWxpemF0aW9uKGNyZWF0ZUJpbmFyeVNlcmlhbGl6YXRpb24obWV0aG9kLkksIGJpbmFyeU9wdGlvbnMpLCBsaW1pdE9wdGlvbnMpO1xuICAgIGNvbnN0IGlucHV0SnNvbiA9IGxpbWl0U2VyaWFsaXphdGlvbihjcmVhdGVKc29uU2VyaWFsaXphdGlvbihtZXRob2QuSSwganNvbk9wdGlvbnMpLCBsaW1pdE9wdGlvbnMpO1xuICAgIGNvbnN0IG91dHB1dEJpbmFyeSA9IGxpbWl0U2VyaWFsaXphdGlvbihjcmVhdGVCaW5hcnlTZXJpYWxpemF0aW9uKG1ldGhvZC5PLCBiaW5hcnlPcHRpb25zKSwgbGltaXRPcHRpb25zKTtcbiAgICBjb25zdCBvdXRwdXRKc29uID0gbGltaXRTZXJpYWxpemF0aW9uKGNyZWF0ZUpzb25TZXJpYWxpemF0aW9uKG1ldGhvZC5PLCBqc29uT3B0aW9ucyksIGxpbWl0T3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0SSh1c2VCaW5hcnlGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VCaW5hcnlGb3JtYXQgPyBpbnB1dEJpbmFyeSA6IGlucHV0SnNvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Tyh1c2VCaW5hcnlGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VCaW5hcnlGb3JtYXQgPyBvdXRwdXRCaW5hcnkgOiBvdXRwdXRKc29uO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgZnVuY3Rpb25zIHRvIG5vcm1hbGl6ZSBhbmQgc2VyaWFsaXplIHRoZSBpbnB1dCBtZXNzYWdlXG4gKiBvZiBhbiBSUEMsIGFuZCB0byBwYXJzZSB0aGUgb3V0cHV0IG1lc3NhZ2Ugb2YgYW4gUlBDLlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50TWV0aG9kU2VyaWFsaXplcnMobWV0aG9kLCB1c2VCaW5hcnlGb3JtYXQsIGpzb25PcHRpb25zLCBiaW5hcnlPcHRpb25zKSB7XG4gICAgY29uc3QgaW5wdXQgPSB1c2VCaW5hcnlGb3JtYXRcbiAgICAgICAgPyBjcmVhdGVCaW5hcnlTZXJpYWxpemF0aW9uKG1ldGhvZC5JLCBiaW5hcnlPcHRpb25zKVxuICAgICAgICA6IGNyZWF0ZUpzb25TZXJpYWxpemF0aW9uKG1ldGhvZC5JLCBqc29uT3B0aW9ucyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gdXNlQmluYXJ5Rm9ybWF0XG4gICAgICAgID8gY3JlYXRlQmluYXJ5U2VyaWFsaXphdGlvbihtZXRob2QuTywgYmluYXJ5T3B0aW9ucylcbiAgICAgICAgOiBjcmVhdGVKc29uU2VyaWFsaXphdGlvbihtZXRob2QuTywganNvbk9wdGlvbnMpO1xuICAgIHJldHVybiB7IHBhcnNlOiBvdXRwdXQucGFyc2UsIHNlcmlhbGl6ZTogaW5wdXQuc2VyaWFsaXplIH07XG59XG4vKipcbiAqIEFwcGx5IEkvTyBsaW1pdHMgdG8gYSBTZXJpYWxpemF0aW9uIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbWl0U2VyaWFsaXphdGlvbihzZXJpYWxpemF0aW9uLCBsaW1pdE9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBzZXJpYWxpemF0aW9uLnNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgICAgIGFzc2VydFdyaXRlTWF4Qnl0ZXMobGltaXRPcHRpb25zLndyaXRlTWF4Qnl0ZXMsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZShkYXRhKSB7XG4gICAgICAgICAgICBhc3NlcnRSZWFkTWF4Qnl0ZXMobGltaXRPcHRpb25zLnJlYWRNYXhCeXRlcywgZGF0YS5ieXRlTGVuZ3RoLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uLnBhcnNlKGRhdGEpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBTZXJpYWxpemF0aW9uIG9iamVjdCBmb3Igc2VyaWFsaXppbmcgdGhlIGdpdmVuIHByb3RvYnVmIG1lc3NhZ2VcbiAqIHdpdGggdGhlIHByb3RvYnVmIGJpbmFyeSBmb3JtYXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCaW5hcnlTZXJpYWxpemF0aW9uKG1lc3NhZ2VUeXBlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyc2UoZGF0YSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVR5cGUuZnJvbUJpbmFyeShkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdEVycm9yKGBwYXJzZSBiaW5hcnk6ICR7bX1gLCBDb2RlLkludGVybmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudG9CaW5hcnkob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3RFcnJvcihgc2VyaWFsaXplIGJpbmFyeTogJHttfWAsIENvZGUuSW50ZXJuYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBTZXJpYWxpemF0aW9uIG9iamVjdCBmb3Igc2VyaWFsaXppbmcgdGhlIGdpdmVuIHByb3RvYnVmIG1lc3NhZ2VcbiAqIHdpdGggdGhlIHByb3RvYnVmIGNhbm9uaWNhbCBKU09OIGVuY29kaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHVua25vd24gZmllbGRzIGFyZSBpZ25vcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSnNvblNlcmlhbGl6YXRpb24obWVzc2FnZVR5cGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHRleHRFbmNvZGVyID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRleHRFbmNvZGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCB0ZXh0RGVjb2RlciA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXh0RGVjb2RlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFRleHREZWNvZGVyKCk7XG4gICAgY29uc3QgbyA9IGdldEpzb25PcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IHRleHREZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVR5cGUuZnJvbUpzb25TdHJpbmcoanNvbiwgbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IENvbm5lY3RFcnJvci5mcm9tKGUsIENvZGUuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IGRhdGEudG9Kc29uU3RyaW5nKG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IENvbm5lY3RFcnJvci5mcm9tKGUsIENvZGUuSW50ZXJuYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/serialization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeadlineSignal: () => (/* binding */ createDeadlineSignal),\n/* harmony export */   createLinkedAbortController: () => (/* binding */ createLinkedAbortController),\n/* harmony export */   getAbortSignalReason: () => (/* binding */ getAbortSignalReason)\n/* harmony export */ });\n/* harmony import */ var _connect_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connect-error.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/connect-error.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../code.js */ \"(ssr)/./node_modules/@connectrpc/connect/dist/esm/code.js\");\n// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * Create an AbortController that is automatically aborted if one of the given\n * signals is aborted.\n *\n * For convenience, the linked AbortSignals can be undefined.\n *\n * If the controller or any of the signals is aborted, all event listeners are\n * removed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createLinkedAbortController(...signals) {\n    const controller = new AbortController();\n    const sa = signals.filter((s) => s !== undefined).concat(controller.signal);\n    for (const signal of sa) {\n        if (signal.aborted) {\n            onAbort.apply(signal);\n            break;\n        }\n        signal.addEventListener(\"abort\", onAbort);\n    }\n    function onAbort() {\n        if (!controller.signal.aborted) {\n            controller.abort(getAbortSignalReason(this));\n        }\n        for (const signal of sa) {\n            signal.removeEventListener(\"abort\", onAbort);\n        }\n    }\n    return controller;\n}\n/**\n * Create a deadline signal. The returned object contains an AbortSignal, but\n * also a cleanup function to stop the timer, which must be called once the\n * calling code is no longer interested in the signal.\n *\n * Ideally, we would simply use AbortSignal.timeout(), but it is not widely\n * available yet.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction createDeadlineSignal(timeoutMs) {\n    const controller = new AbortController();\n    const listener = () => {\n        controller.abort(new _connect_error_js__WEBPACK_IMPORTED_MODULE_0__.ConnectError(\"the operation timed out\", _code_js__WEBPACK_IMPORTED_MODULE_1__.Code.DeadlineExceeded));\n    };\n    let timeoutId;\n    if (timeoutMs !== undefined) {\n        if (timeoutMs <= 0)\n            listener();\n        else\n            timeoutId = setTimeout(listener, timeoutMs);\n    }\n    return {\n        signal: controller.signal,\n        cleanup: () => clearTimeout(timeoutId),\n    };\n}\n/**\n * Returns the reason why an AbortSignal was aborted. Returns undefined if the\n * signal has not been aborted.\n *\n * The property AbortSignal.reason is not widely available. This function\n * returns an AbortError if the signal is aborted, but reason is undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nfunction getAbortSignalReason(signal) {\n    if (!signal.aborted) {\n        return undefined;\n    }\n    if (signal.reason !== undefined) {\n        return signal.reason;\n    }\n    // AbortSignal.reason is available in Node.js v16, v18, and later,\n    // and in all browsers since early 2022.\n    const e = new Error(\"This operation was aborted\");\n    e.name = \"AbortError\";\n    return e;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbm5lY3RycGMvY29ubmVjdC9kaXN0L2VzbS9wcm90b2NvbC9zaWduYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDakI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZCQUE2QiwyREFBWSw0QkFBNEIsMENBQUk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb25uZWN0cnBjL2Nvbm5lY3QvZGlzdC9lc20vcHJvdG9jb2wvc2lnbmFscy5qcz81NTU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgVGhlIENvbm5lY3QgQXV0aG9yc1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBDb25uZWN0RXJyb3IgfSBmcm9tIFwiLi4vY29ubmVjdC1lcnJvci5qc1wiO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gXCIuLi9jb2RlLmpzXCI7XG4vKipcbiAqIENyZWF0ZSBhbiBBYm9ydENvbnRyb2xsZXIgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGFib3J0ZWQgaWYgb25lIG9mIHRoZSBnaXZlblxuICogc2lnbmFscyBpcyBhYm9ydGVkLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgdGhlIGxpbmtlZCBBYm9ydFNpZ25hbHMgY2FuIGJlIHVuZGVmaW5lZC5cbiAqXG4gKiBJZiB0aGUgY29udHJvbGxlciBvciBhbnkgb2YgdGhlIHNpZ25hbHMgaXMgYWJvcnRlZCwgYWxsIGV2ZW50IGxpc3RlbmVycyBhcmVcbiAqIHJlbW92ZWQuXG4gKlxuICogQHByaXZhdGUgSW50ZXJuYWwgY29kZSwgZG9lcyBub3QgZm9sbG93IHNlbWFudGljIHZlcnNpb25pbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5rZWRBYm9ydENvbnRyb2xsZXIoLi4uc2lnbmFscykge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2EgPSBzaWduYWxzLmZpbHRlcigocykgPT4gcyAhPT0gdW5kZWZpbmVkKS5jb25jYXQoY29udHJvbGxlci5zaWduYWwpO1xuICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNhKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgb25BYm9ydC5hcHBseShzaWduYWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25BYm9ydCgpIHtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KGdldEFib3J0U2lnbmFsUmVhc29uKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHNpZ25hbCBvZiBzYSkge1xuICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlcjtcbn1cbi8qKlxuICogQ3JlYXRlIGEgZGVhZGxpbmUgc2lnbmFsLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIGFuIEFib3J0U2lnbmFsLCBidXRcbiAqIGFsc28gYSBjbGVhbnVwIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHRpbWVyLCB3aGljaCBtdXN0IGJlIGNhbGxlZCBvbmNlIHRoZVxuICogY2FsbGluZyBjb2RlIGlzIG5vIGxvbmdlciBpbnRlcmVzdGVkIGluIHRoZSBzaWduYWwuXG4gKlxuICogSWRlYWxseSwgd2Ugd291bGQgc2ltcGx5IHVzZSBBYm9ydFNpZ25hbC50aW1lb3V0KCksIGJ1dCBpdCBpcyBub3Qgd2lkZWx5XG4gKiBhdmFpbGFibGUgeWV0LlxuICpcbiAqIEBwcml2YXRlIEludGVybmFsIGNvZGUsIGRvZXMgbm90IGZvbGxvdyBzZW1hbnRpYyB2ZXJzaW9uaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVhZGxpbmVTaWduYWwodGltZW91dE1zKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydChuZXcgQ29ubmVjdEVycm9yKFwidGhlIG9wZXJhdGlvbiB0aW1lZCBvdXRcIiwgQ29kZS5EZWFkbGluZUV4Y2VlZGVkKSk7XG4gICAgfTtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGlmICh0aW1lb3V0TXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGltZW91dE1zIDw9IDApXG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGxpc3RlbmVyLCB0aW1lb3V0TXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBjbGVhbnVwOiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWFzb24gd2h5IGFuIEFib3J0U2lnbmFsIHdhcyBhYm9ydGVkLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVcbiAqIHNpZ25hbCBoYXMgbm90IGJlZW4gYWJvcnRlZC5cbiAqXG4gKiBUaGUgcHJvcGVydHkgQWJvcnRTaWduYWwucmVhc29uIGlzIG5vdCB3aWRlbHkgYXZhaWxhYmxlLiBUaGlzIGZ1bmN0aW9uXG4gKiByZXR1cm5zIGFuIEFib3J0RXJyb3IgaWYgdGhlIHNpZ25hbCBpcyBhYm9ydGVkLCBidXQgcmVhc29uIGlzIHVuZGVmaW5lZC5cbiAqXG4gKiBAcHJpdmF0ZSBJbnRlcm5hbCBjb2RlLCBkb2VzIG5vdCBmb2xsb3cgc2VtYW50aWMgdmVyc2lvbmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFib3J0U2lnbmFsUmVhc29uKHNpZ25hbCkge1xuICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHNpZ25hbC5yZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2lnbmFsLnJlYXNvbjtcbiAgICB9XG4gICAgLy8gQWJvcnRTaWduYWwucmVhc29uIGlzIGF2YWlsYWJsZSBpbiBOb2RlLmpzIHYxNiwgdjE4LCBhbmQgbGF0ZXIsXG4gICAgLy8gYW5kIGluIGFsbCBicm93c2VycyBzaW5jZSBlYXJseSAyMDIyLlxuICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXCJUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZFwiKTtcbiAgICBlLm5hbWUgPSBcIkFib3J0RXJyb3JcIjtcbiAgICByZXR1cm4gZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@connectrpc/connect/dist/esm/protocol/signals.js\n");

/***/ })

};
;