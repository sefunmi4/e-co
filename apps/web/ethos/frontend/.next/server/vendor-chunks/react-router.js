"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/development/chunk-65XJMMLO.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/react-router/dist/development/chunk-65XJMMLO.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RSCDefaultRootErrorBoundary: () => (/* binding */ RSCDefaultRootErrorBoundary),\n/* harmony export */   RSCHydratedRouter: () => (/* binding */ RSCHydratedRouter),\n/* harmony export */   RSCStaticRouter: () => (/* binding */ RSCStaticRouter),\n/* harmony export */   ServerMode: () => (/* binding */ ServerMode),\n/* harmony export */   ServerRouter: () => (/* binding */ ServerRouter),\n/* harmony export */   createCallServer: () => (/* binding */ createCallServer),\n/* harmony export */   createCookie: () => (/* binding */ createCookie),\n/* harmony export */   createCookieSessionStorage: () => (/* binding */ createCookieSessionStorage),\n/* harmony export */   createMemorySessionStorage: () => (/* binding */ createMemorySessionStorage),\n/* harmony export */   createRequestHandler: () => (/* binding */ createRequestHandler),\n/* harmony export */   createRoutesStub: () => (/* binding */ createRoutesStub),\n/* harmony export */   createSession: () => (/* binding */ createSession),\n/* harmony export */   createSessionStorage: () => (/* binding */ createSessionStorage),\n/* harmony export */   deserializeErrors: () => (/* binding */ deserializeErrors),\n/* harmony export */   getHydrationData: () => (/* binding */ getHydrationData),\n/* harmony export */   getRSCStream: () => (/* binding */ getRSCStream),\n/* harmony export */   href: () => (/* binding */ href),\n/* harmony export */   isCookie: () => (/* binding */ isCookie),\n/* harmony export */   isSession: () => (/* binding */ isSession),\n/* harmony export */   routeRSCServerRequest: () => (/* binding */ routeRSCServerRequest),\n/* harmony export */   setDevServerHooks: () => (/* binding */ setDevServerHooks)\n/* harmony export */ });\n/* harmony import */ var _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-NISHYRIK.mjs */ \"(ssr)/./node_modules/react-router/dist/development/chunk-NISHYRIK.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cookie */ \"(ssr)/./node_modules/cookie/dist/index.js\");\n/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! set-cookie-parser */ \"(ssr)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/**\n * react-router v7.9.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\n\n// lib/dom/ssr/server.tsx\n\nfunction ServerRouter({\n  context,\n  url,\n  nonce\n}) {\n  if (typeof url === \"string\") {\n    url = new URL(url);\n  }\n  let { manifest, routeModules, criticalCss, serverHandoffString } = context;\n  let routes = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createServerRoutes)(\n    manifest.routes,\n    routeModules,\n    context.future,\n    context.isSpaMode\n  );\n  context.staticHandlerContext.loaderData = {\n    ...context.staticHandlerContext.loaderData\n  };\n  for (let match of context.staticHandlerContext.matches) {\n    let routeId = match.route.id;\n    let route = routeModules[routeId];\n    let manifestRoute = context.manifest.routes[routeId];\n    if (route && manifestRoute && (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.shouldHydrateRouteLoader)(\n      routeId,\n      route.clientLoader,\n      manifestRoute.hasLoader,\n      context.isSpaMode\n    ) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n      delete context.staticHandlerContext.loaderData[routeId];\n    }\n  }\n  let router = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createStaticRouter)(routes, context.staticHandlerContext);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.FrameworkContext.Provider,\n    {\n      value: {\n        manifest,\n        routeModules,\n        criticalCss,\n        serverHandoffString,\n        future: context.future,\n        ssr: context.ssr,\n        isSpaMode: context.isSpaMode,\n        routeDiscovery: context.routeDiscovery,\n        serializeError: context.serializeError,\n        renderMeta: context.renderMeta\n      }\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.RemixErrorBoundary, { location: router.state.location }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.StaticRouterProvider,\n      {\n        router,\n        context: context.staticHandlerContext,\n        hydrate: false\n      }\n    ))\n  ), context.serverHandoffStream ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.StreamTransfer,\n    {\n      context,\n      identifier: 0,\n      reader: context.serverHandoffStream.getReader(),\n      textDecoder: new TextDecoder(),\n      nonce\n    }\n  )) : null);\n}\n\n// lib/dom/ssr/routes-test-stub.tsx\n\nfunction createRoutesStub(routes, _context) {\n  return function RoutesTestStub({\n    initialEntries,\n    initialIndex,\n    hydrationData,\n    future\n  }) {\n    let routerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    let frameworkContextRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (routerRef.current == null) {\n      frameworkContextRef.current = {\n        future: {\n          unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,\n          v8_middleware: future?.v8_middleware === true\n        },\n        manifest: {\n          routes: {},\n          entry: { imports: [], module: \"\" },\n          url: \"\",\n          version: \"\"\n        },\n        routeModules: {},\n        ssr: false,\n        isSpaMode: false,\n        routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" }\n      };\n      let patched = processRoutes(\n        // @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`\n        // types compared to `AgnosticRouteObject`\n        (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.convertRoutesToDataRoutes)(routes, (r) => r),\n        _context !== void 0 ? _context : future?.v8_middleware ? new _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterContextProvider() : {},\n        frameworkContextRef.current.manifest,\n        frameworkContextRef.current.routeModules\n      );\n      routerRef.current = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createMemoryRouter)(patched, {\n        initialEntries,\n        initialIndex,\n        hydrationData\n      });\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.FrameworkContext.Provider, { value: frameworkContextRef.current }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterProvider, { router: routerRef.current }));\n  };\n}\nfunction processRoutes(routes, context, manifest, routeModules, parentId) {\n  return routes.map((route) => {\n    if (!route.id) {\n      throw new Error(\n        \"Expected a route.id in react-router processRoutes() function\"\n      );\n    }\n    let newRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      Component: route.Component ? (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.withComponentProps)(route.Component) : void 0,\n      HydrateFallback: route.HydrateFallback ? (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.withHydrateFallbackProps)(route.HydrateFallback) : void 0,\n      ErrorBoundary: route.ErrorBoundary ? (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.withErrorBoundaryProps)(route.ErrorBoundary) : void 0,\n      action: route.action ? (args) => route.action({ ...args, context }) : void 0,\n      loader: route.loader ? (args) => route.loader({ ...args, context }) : void 0,\n      middleware: route.middleware ? route.middleware.map(\n        (mw) => (...args) => mw(\n          { ...args[0], context },\n          args[1]\n        )\n      ) : void 0,\n      handle: route.handle,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    let entryRoute = {\n      id: route.id,\n      path: route.path,\n      index: route.index,\n      parentId,\n      hasAction: route.action != null,\n      hasLoader: route.loader != null,\n      // When testing routes, you should be stubbing loader/action/middleware,\n      // not trying to re-implement the full loader/clientLoader/SSR/hydration\n      // flow. That is better tested via E2E tests.\n      hasClientAction: false,\n      hasClientLoader: false,\n      hasClientMiddleware: false,\n      hasErrorBoundary: route.ErrorBoundary != null,\n      // any need for these?\n      module: \"build/stub-path-to-module.js\",\n      clientActionModule: void 0,\n      clientLoaderModule: void 0,\n      clientMiddlewareModule: void 0,\n      hydrateFallbackModule: void 0\n    };\n    manifest.routes[newRoute.id] = entryRoute;\n    routeModules[route.id] = {\n      default: newRoute.Component || _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.Outlet,\n      ErrorBoundary: newRoute.ErrorBoundary || void 0,\n      handle: route.handle,\n      links: route.links,\n      meta: route.meta,\n      shouldRevalidate: route.shouldRevalidate\n    };\n    if (route.children) {\n      newRoute.children = processRoutes(\n        route.children,\n        context,\n        manifest,\n        routeModules,\n        newRoute.id\n      );\n    }\n    return newRoute;\n  });\n}\n\n// lib/server-runtime/cookies.ts\n\n\n// lib/server-runtime/crypto.ts\nvar encoder = /* @__PURE__ */ new TextEncoder();\nvar sign = async (value, secret) => {\n  let data2 = encoder.encode(value);\n  let key = await createKey(secret, [\"sign\"]);\n  let signature = await crypto.subtle.sign(\"HMAC\", key, data2);\n  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(\n    /=+$/,\n    \"\"\n  );\n  return value + \".\" + hash;\n};\nvar unsign = async (cookie, secret) => {\n  let index = cookie.lastIndexOf(\".\");\n  let value = cookie.slice(0, index);\n  let hash = cookie.slice(index + 1);\n  let data2 = encoder.encode(value);\n  let key = await createKey(secret, [\"verify\"]);\n  try {\n    let signature = byteStringToUint8Array(atob(hash));\n    let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data2);\n    return valid ? value : false;\n  } catch (error) {\n    return false;\n  }\n};\nvar createKey = async (secret, usages) => crypto.subtle.importKey(\n  \"raw\",\n  encoder.encode(secret),\n  { name: \"HMAC\", hash: \"SHA-256\" },\n  false,\n  usages\n);\nfunction byteStringToUint8Array(byteString) {\n  let array = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n  return array;\n}\n\n// lib/server-runtime/cookies.ts\nvar createCookie = (name, cookieOptions = {}) => {\n  let { secrets = [], ...options } = {\n    path: \"/\",\n    sameSite: \"lax\",\n    ...cookieOptions\n  };\n  warnOnceAboutExpiresCookie(name, options.expires);\n  return {\n    get name() {\n      return name;\n    },\n    get isSigned() {\n      return secrets.length > 0;\n    },\n    get expires() {\n      return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;\n    },\n    async parse(cookieHeader, parseOptions) {\n      if (!cookieHeader) return null;\n      let cookies = (0,cookie__WEBPACK_IMPORTED_MODULE_2__.parse)(cookieHeader, { ...options, ...parseOptions });\n      if (name in cookies) {\n        let value = cookies[name];\n        if (typeof value === \"string\" && value !== \"\") {\n          let decoded = await decodeCookieValue(value, secrets);\n          return decoded;\n        } else {\n          return \"\";\n        }\n      } else {\n        return null;\n      }\n    },\n    async serialize(value, serializeOptions) {\n      return (0,cookie__WEBPACK_IMPORTED_MODULE_2__.serialize)(\n        name,\n        value === \"\" ? \"\" : await encodeCookieValue(value, secrets),\n        {\n          ...options,\n          ...serializeOptions\n        }\n      );\n    }\n  };\n};\nvar isCookie = (object) => {\n  return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(value, secrets) {\n  let encoded = encodeData(value);\n  if (secrets.length > 0) {\n    encoded = await sign(encoded, secrets[0]);\n  }\n  return encoded;\n}\nasync function decodeCookieValue(value, secrets) {\n  if (secrets.length > 0) {\n    for (let secret of secrets) {\n      let unsignedValue = await unsign(value, secret);\n      if (unsignedValue !== false) {\n        return decodeData(unsignedValue);\n      }\n    }\n    return null;\n  }\n  return decodeData(value);\n}\nfunction encodeData(value) {\n  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n  try {\n    return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n  } catch (error) {\n    return {};\n  }\n}\nfunction myEscape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, code;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (/[\\w*+\\-./@]/.exec(chr)) {\n      result += chr;\n    } else {\n      code = chr.charCodeAt(0);\n      if (code < 256) {\n        result += \"%\" + hex(code, 2);\n      } else {\n        result += \"%u\" + hex(code, 4).toUpperCase();\n      }\n    }\n  }\n  return result;\n}\nfunction hex(code, length) {\n  let result = code.toString(16);\n  while (result.length < length) result = \"0\" + result;\n  return result;\n}\nfunction myUnescape(value) {\n  let str = value.toString();\n  let result = \"\";\n  let index = 0;\n  let chr, part;\n  while (index < str.length) {\n    chr = str.charAt(index++);\n    if (chr === \"%\") {\n      if (str.charAt(index) === \"u\") {\n        part = str.slice(index + 1, index + 5);\n        if (/^[\\da-f]{4}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 5;\n          continue;\n        }\n      } else {\n        part = str.slice(index, index + 2);\n        if (/^[\\da-f]{2}$/i.exec(part)) {\n          result += String.fromCharCode(parseInt(part, 16));\n          index += 2;\n          continue;\n        }\n      }\n    }\n    result += chr;\n  }\n  return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n  (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.warnOnce)(\n    !expires,\n    `The \"${name}\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \\`commitSession(session, { expires })\\` if using a session storage object, or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`\n  );\n}\n\n// lib/server-runtime/entry.ts\nfunction createEntryRouteModules(manifest) {\n  return Object.keys(manifest).reduce((memo, routeId) => {\n    let route = manifest[routeId];\n    if (route) {\n      memo[routeId] = route.module;\n    }\n    return memo;\n  }, {});\n}\n\n// lib/server-runtime/mode.ts\nvar ServerMode = /* @__PURE__ */ ((ServerMode2) => {\n  ServerMode2[\"Development\"] = \"development\";\n  ServerMode2[\"Production\"] = \"production\";\n  ServerMode2[\"Test\"] = \"test\";\n  return ServerMode2;\n})(ServerMode || {});\nfunction isServerMode(value) {\n  return value === \"development\" /* Development */ || value === \"production\" /* Production */ || value === \"test\" /* Test */;\n}\n\n// lib/server-runtime/errors.ts\nfunction sanitizeError(error, serverMode) {\n  if (error instanceof Error && serverMode !== \"development\" /* Development */) {\n    let sanitized = new Error(\"Unexpected Server Error\");\n    sanitized.stack = void 0;\n    return sanitized;\n  }\n  return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n  return Object.entries(errors).reduce((acc, [routeId, error]) => {\n    return Object.assign(acc, { [routeId]: sanitizeError(error, serverMode) });\n  }, {});\n}\nfunction serializeError(error, serverMode) {\n  let sanitized = sanitizeError(error, serverMode);\n  return {\n    message: sanitized.message,\n    stack: sanitized.stack\n  };\n}\nfunction serializeErrors(errors, serverMode) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(val)) {\n      serialized[key] = { ...val, __type: \"RouteErrorResponse\" };\n    } else if (val instanceof Error) {\n      let sanitized = sanitizeError(val, serverMode);\n      serialized[key] = {\n        message: sanitized.message,\n        stack: sanitized.stack,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.  This will only apply\n        // in dev mode since all production errors are sanitized to normal\n        // Error instances\n        ...sanitized.name !== \"Error\" ? {\n          __subType: sanitized.name\n        } : {}\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n// lib/server-runtime/routeMatching.ts\nfunction matchServerRoutes(routes, pathname, basename) {\n  let matches = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(\n    routes,\n    pathname,\n    basename\n  );\n  if (!matches) return null;\n  return matches.map((match) => ({\n    params: match.params,\n    pathname: match.pathname,\n    route: match.route\n  }));\n}\n\n// lib/server-runtime/data.ts\nasync function callRouteHandler(handler, args) {\n  let result = await handler({\n    request: stripRoutesParam(stripIndexParam2(args.request)),\n    params: args.params,\n    context: args.context\n  });\n  if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isDataWithResponseInit)(result) && result.init && result.init.status && (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRedirectStatusCode)(result.init.status)) {\n    throw new Response(null, result.init);\n  }\n  return result;\n}\nfunction stripIndexParam2(request) {\n  let url = new URL(request.url);\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\nfunction stripRoutesParam(request) {\n  let url = new URL(request.url);\n  url.searchParams.delete(\"_routes\");\n  let init = {\n    method: request.method,\n    body: request.body,\n    headers: request.headers,\n    signal: request.signal\n  };\n  if (init.body) {\n    init.duplex = \"half\";\n  }\n  return new Request(url.href, init);\n}\n\n// lib/server-runtime/invariant.ts\nfunction invariant2(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    console.error(\n      \"The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose\"\n    );\n    throw new Error(message);\n  }\n}\n\n// lib/server-runtime/dev.ts\nvar globalDevServerHooksKey = \"__reactRouterDevServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n  globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n  return globalThis[globalDevServerHooksKey];\n}\nfunction getBuildTimeHeader(request, headerName) {\n  if (typeof process !== \"undefined\") {\n    try {\n      if (process.env?.IS_RR_BUILD_REQUEST === \"yes\") {\n        return request.headers.get(headerName);\n      }\n    } catch (e) {\n    }\n  }\n  return null;\n}\n\n// lib/server-runtime/routes.ts\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach((route) => {\n    if (route) {\n      let parentId = route.parentId || \"\";\n      if (!routes[parentId]) {\n        routes[parentId] = [];\n      }\n      routes[parentId].push(route);\n    }\n  });\n  return routes;\n}\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map((route) => ({\n    ...route,\n    children: createRoutes(manifest, route.id, routesByParentId)\n  }));\n}\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest)) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let commonRoute = {\n      // Always include root due to default boundaries\n      hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n      id: route.id,\n      path: route.path,\n      middleware: route.module.middleware,\n      // Need to use RR's version in the param typed here to permit the optional\n      // context even though we know it'll always be provided in remix\n      loader: route.module.loader ? async (args) => {\n        let preRenderedData = getBuildTimeHeader(\n          args.request,\n          \"X-React-Router-Prerender-Data\"\n        );\n        if (preRenderedData != null) {\n          let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;\n          invariant2(encoded, \"Missing prerendered data for route\");\n          let uint8array = new TextEncoder().encode(encoded);\n          let stream = new ReadableStream({\n            start(controller) {\n              controller.enqueue(uint8array);\n              controller.close();\n            }\n          });\n          let decoded = await (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.decodeViaTurboStream)(stream, global);\n          let data2 = decoded.value;\n          if (data2 && _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.SingleFetchRedirectSymbol in data2) {\n            let result = data2[_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.SingleFetchRedirectSymbol];\n            let init = { status: result.status };\n            if (result.reload) {\n              throw (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.redirectDocument)(result.redirect, init);\n            } else if (result.replace) {\n              throw (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.replace)(result.redirect, init);\n            } else {\n              throw (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.redirect)(result.redirect, init);\n            }\n          } else {\n            invariant2(\n              data2 && route.id in data2,\n              \"Unable to decode prerendered data\"\n            );\n            let result = data2[route.id];\n            invariant2(\n              \"data\" in result,\n              \"Unable to process prerendered data\"\n            );\n            return result.data;\n          }\n        }\n        let val = await callRouteHandler(route.module.loader, args);\n        return val;\n      } : void 0,\n      action: route.module.action ? (args) => callRouteHandler(route.module.action, args) : void 0,\n      handle: route.module.handle\n    };\n    return route.index ? {\n      index: true,\n      ...commonRoute\n    } : {\n      caseSensitive: route.caseSensitive,\n      children: createStaticHandlerDataRoutes(\n        manifest,\n        future,\n        route.id,\n        routesByParentId\n      ),\n      ...commonRoute\n    };\n  });\n}\n\n// lib/server-runtime/serverHandoff.ts\nfunction createServerHandoffString(serverHandoff) {\n  return (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.escapeHtml)(JSON.stringify(serverHandoff));\n}\n\n// lib/server-runtime/headers.ts\n\nfunction getDocumentHeaders(context, build) {\n  return getDocumentHeadersImpl(context, (m) => {\n    let route = build.routes[m.route.id];\n    invariant2(route, `Route with id \"${m.route.id}\" not found in build`);\n    return route.module.headers;\n  });\n}\nfunction getDocumentHeadersImpl(context, getRouteHeadersFn, _defaultHeaders) {\n  let boundaryIdx = context.errors ? context.matches.findIndex((m) => context.errors[m.route.id]) : -1;\n  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n  let errorHeaders;\n  if (boundaryIdx >= 0) {\n    let { actionHeaders, actionData, loaderHeaders, loaderData } = context;\n    context.matches.slice(boundaryIdx).some((match) => {\n      let id = match.route.id;\n      if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {\n        errorHeaders = actionHeaders[id];\n      } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {\n        errorHeaders = loaderHeaders[id];\n      }\n      return errorHeaders != null;\n    });\n  }\n  const defaultHeaders = new Headers(_defaultHeaders);\n  return matches.reduce((parentHeaders, match, idx) => {\n    let { id } = match.route;\n    let loaderHeaders = context.loaderHeaders[id] || new Headers();\n    let actionHeaders = context.actionHeaders[id] || new Headers();\n    let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;\n    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n    let headersFn = getRouteHeadersFn(match);\n    if (headersFn == null) {\n      let headers2 = new Headers(parentHeaders);\n      if (includeErrorCookies) {\n        prependCookies(errorHeaders, headers2);\n      }\n      prependCookies(actionHeaders, headers2);\n      prependCookies(loaderHeaders, headers2);\n      return headers2;\n    }\n    let headers = new Headers(\n      typeof headersFn === \"function\" ? headersFn({\n        loaderHeaders,\n        parentHeaders,\n        actionHeaders,\n        errorHeaders: includeErrorHeaders ? errorHeaders : void 0\n      }) : headersFn\n    );\n    if (includeErrorCookies) {\n      prependCookies(errorHeaders, headers);\n    }\n    prependCookies(actionHeaders, headers);\n    prependCookies(loaderHeaders, headers);\n    prependCookies(parentHeaders, headers);\n    return headers;\n  }, new Headers(defaultHeaders));\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n  let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n  if (parentSetCookieString) {\n    let cookies = (0,set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__.splitCookiesString)(parentSetCookieString);\n    let childCookies = new Set(childHeaders.getSetCookie());\n    cookies.forEach((cookie) => {\n      if (!childCookies.has(cookie)) {\n        childHeaders.append(\"Set-Cookie\", cookie);\n      }\n    });\n  }\n}\n\n// lib/server-runtime/single-fetch.ts\nvar SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n  ..._chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.NO_BODY_STATUS_CODES,\n  304\n]);\nasync function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      method: request.method,\n      body: request.body,\n      headers: request.headers,\n      signal: request.signal,\n      ...request.body ? { duplex: \"half\" } : void 0\n    });\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      skipLoaderErrorBubbling: true,\n      skipRevalidation: true,\n      generateMiddlewareResponse: build.future.v8_middleware ? async (query) => {\n        try {\n          let innerResult = await query(handlerRequest);\n          return handleQueryResult(innerResult);\n        } catch (error) {\n          return handleQueryError(error);\n        }\n      } : void 0\n    });\n    return handleQueryResult(result);\n  } catch (error) {\n    return handleQueryError(error);\n  }\n  function handleQueryResult(result) {\n    return (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isResponse)(result) ? result : staticContextToResponse(result);\n  }\n  function handleQueryError(error) {\n    handleError(error);\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: { error },\n      headers: new Headers(),\n      status: 500\n    });\n  }\n  function staticContextToResponse(context) {\n    let headers = getDocumentHeaders(context, build);\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRedirectStatusCode)(context.statusCode) && headers.has(\"Location\")) {\n      return new Response(null, { status: context.statusCode, headers });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!(0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let singleFetchResult;\n    if (context.errors) {\n      singleFetchResult = { error: Object.values(context.errors)[0] };\n    } else {\n      singleFetchResult = {\n        data: Object.values(context.actionData || {})[0]\n      };\n    }\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: singleFetchResult,\n      headers,\n      status: context.statusCode\n    });\n  }\n}\nasync function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n  let routesParam = new URL(request.url).searchParams.get(\"_routes\");\n  let loadRouteIds = routesParam ? new Set(routesParam.split(\",\")) : null;\n  try {\n    let handlerRequest = new Request(handlerUrl, {\n      headers: request.headers,\n      signal: request.signal\n    });\n    let result = await staticHandler.query(handlerRequest, {\n      requestContext: loadContext,\n      filterMatchesToLoad: (m) => !loadRouteIds || loadRouteIds.has(m.route.id),\n      skipLoaderErrorBubbling: true,\n      generateMiddlewareResponse: build.future.v8_middleware ? async (query) => {\n        try {\n          let innerResult = await query(handlerRequest);\n          return handleQueryResult(innerResult);\n        } catch (error) {\n          return handleQueryError(error);\n        }\n      } : void 0\n    });\n    return handleQueryResult(result);\n  } catch (error) {\n    return handleQueryError(error);\n  }\n  function handleQueryResult(result) {\n    return (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isResponse)(result) ? result : staticContextToResponse(result);\n  }\n  function handleQueryError(error) {\n    handleError(error);\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: { error },\n      headers: new Headers(),\n      status: 500\n    });\n  }\n  function staticContextToResponse(context) {\n    let headers = getDocumentHeaders(context, build);\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRedirectStatusCode)(context.statusCode) && headers.has(\"Location\")) {\n      return new Response(null, { status: context.statusCode, headers });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!(0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let results = {};\n    let loadedMatches = new Set(\n      context.matches.filter(\n        (m) => loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null\n      ).map((m) => m.route.id)\n    );\n    if (context.errors) {\n      for (let [id, error] of Object.entries(context.errors)) {\n        results[id] = { error };\n      }\n    }\n    for (let [id, data2] of Object.entries(context.loaderData)) {\n      if (!(id in results) && loadedMatches.has(id)) {\n        results[id] = { data: data2 };\n      }\n    }\n    return generateSingleFetchResponse(request, build, serverMode, {\n      result: results,\n      headers,\n      status: context.statusCode\n    });\n  }\n}\nfunction generateSingleFetchResponse(request, build, serverMode, {\n  result,\n  headers,\n  status\n}) {\n  let resultHeaders = new Headers(headers);\n  resultHeaders.set(\"X-Remix-Response\", \"yes\");\n  if (SERVER_NO_BODY_STATUS_CODES.has(status)) {\n    return new Response(null, { status, headers: resultHeaders });\n  }\n  resultHeaders.set(\"Content-Type\", \"text/x-script\");\n  resultHeaders.delete(\"Content-Length\");\n  return new Response(\n    encodeViaTurboStream(\n      result,\n      request.signal,\n      build.entry.module.streamTimeout,\n      serverMode\n    ),\n    {\n      status: status || 200,\n      headers: resultHeaders\n    }\n  );\n}\nfunction generateSingleFetchRedirectResponse(redirectResponse, request, build, serverMode) {\n  let redirect2 = getSingleFetchRedirect(\n    redirectResponse.status,\n    redirectResponse.headers,\n    build.basename\n  );\n  let headers = new Headers(redirectResponse.headers);\n  headers.delete(\"Location\");\n  headers.set(\"Content-Type\", \"text/x-script\");\n  return generateSingleFetchResponse(request, build, serverMode, {\n    result: request.method === \"GET\" ? { [_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.SingleFetchRedirectSymbol]: redirect2 } : redirect2,\n    headers,\n    status: _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.SINGLE_FETCH_REDIRECT_STATUS\n  });\n}\nfunction getSingleFetchRedirect(status, headers, basename) {\n  let redirect2 = headers.get(\"Location\");\n  if (basename) {\n    redirect2 = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(redirect2, basename) || redirect2;\n  }\n  return {\n    redirect: redirect2,\n    status,\n    revalidate: (\n      // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n      // detail of ?_data requests as our way to tell the front end to revalidate when\n      // we didn't have a response body to include that information in.\n      // With single fetch, we tell the front end via this revalidate boolean field.\n      // However, we're respecting it for now because it may be something folks have\n      // used in their own responses\n      // TODO(v3): Consider removing or making this official public API\n      headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\")\n    ),\n    reload: headers.has(\"X-Remix-Reload-Document\"),\n    replace: headers.has(\"X-Remix-Replace\")\n  };\n}\nfunction encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {\n  let controller = new AbortController();\n  let timeoutId = setTimeout(\n    () => controller.abort(new Error(\"Server Timeout\")),\n    typeof streamTimeout === \"number\" ? streamTimeout : 4950\n  );\n  requestSignal.addEventListener(\"abort\", () => clearTimeout(timeoutId));\n  return (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.encode)(data2, {\n    signal: controller.signal,\n    plugins: [\n      (value) => {\n        if (value instanceof Error) {\n          let { name, message, stack } = serverMode === \"production\" /* Production */ ? sanitizeError(value, serverMode) : value;\n          return [\"SanitizedError\", name, message, stack];\n        }\n        if (value instanceof _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorResponseImpl) {\n          let { data: data3, status, statusText } = value;\n          return [\"ErrorResponse\", data3, status, statusText];\n        }\n        if (value && typeof value === \"object\" && _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.SingleFetchRedirectSymbol in value) {\n          return [\"SingleFetchRedirect\", value[_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.SingleFetchRedirectSymbol]];\n        }\n      }\n    ],\n    postPlugins: [\n      (value) => {\n        if (!value) return;\n        if (typeof value !== \"object\") return;\n        return [\n          \"SingleFetchClassInstance\",\n          Object.fromEntries(Object.entries(value))\n        ];\n      },\n      () => [\"SingleFetchFallback\"]\n    ]\n  });\n}\n\n// lib/server-runtime/server.ts\nfunction derive(build, mode) {\n  let routes = createRoutes(build.routes);\n  let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);\n  let serverMode = isServerMode(mode) ? mode : \"production\" /* Production */;\n  let staticHandler = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createStaticHandler)(dataRoutes, {\n    basename: build.basename\n  });\n  let errorHandler = build.entry.module.handleError || ((error, { request }) => {\n    if (serverMode !== \"test\" /* Test */ && !request.signal.aborted) {\n      console.error(\n        // @ts-expect-error This is \"private\" from users but intended for internal use\n        (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) && error.error ? error.error : error\n      );\n    }\n  });\n  return {\n    routes,\n    dataRoutes,\n    serverMode,\n    staticHandler,\n    errorHandler\n  };\n}\nvar createRequestHandler = (build, mode) => {\n  let _build;\n  let routes;\n  let serverMode;\n  let staticHandler;\n  let errorHandler;\n  return async function requestHandler(request, initialContext) {\n    _build = typeof build === \"function\" ? await build() : build;\n    if (typeof build === \"function\") {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n    } else if (!routes || !serverMode || !staticHandler || !errorHandler) {\n      let derived = derive(_build, mode);\n      routes = derived.routes;\n      serverMode = derived.serverMode;\n      staticHandler = derived.staticHandler;\n      errorHandler = derived.errorHandler;\n    }\n    let params = {};\n    let loadContext;\n    let handleError = (error) => {\n      if (mode === \"development\" /* Development */) {\n        getDevServerHooks()?.processRequestError?.(error);\n      }\n      errorHandler(error, {\n        context: loadContext,\n        params,\n        request\n      });\n    };\n    if (_build.future.v8_middleware) {\n      if (initialContext && !(initialContext instanceof _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterContextProvider)) {\n        let error = new Error(\n          \"Invalid `context` value provided to `handleRequest`. When middleware is enabled you must return an instance of `RouterContextProvider` from your `getLoadContext` function.\"\n        );\n        handleError(error);\n        return returnLastResortErrorResponse(error, serverMode);\n      }\n      loadContext = initialContext || new _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.RouterContextProvider();\n    } else {\n      loadContext = initialContext || {};\n    }\n    let url = new URL(request.url);\n    let normalizedBasename = _build.basename || \"/\";\n    let normalizedPath = url.pathname;\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(normalizedPath, normalizedBasename) === \"/_root.data\") {\n      normalizedPath = normalizedBasename;\n    } else if (normalizedPath.endsWith(\".data\")) {\n      normalizedPath = normalizedPath.replace(/\\.data$/, \"\");\n    }\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(normalizedPath, normalizedBasename) !== \"/\" && normalizedPath.endsWith(\"/\")) {\n      normalizedPath = normalizedPath.slice(0, -1);\n    }\n    let isSpaMode = getBuildTimeHeader(request, \"X-React-Router-SPA-Mode\") === \"yes\";\n    if (!_build.ssr) {\n      let decodedPath = decodeURI(normalizedPath);\n      if (normalizedBasename !== \"/\") {\n        let strippedPath = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(decodedPath, normalizedBasename);\n        if (strippedPath == null) {\n          errorHandler(\n            new _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorResponseImpl(\n              404,\n              \"Not Found\",\n              `Refusing to prerender the \\`${decodedPath}\\` path because it does not start with the basename \\`${normalizedBasename}\\``\n            ),\n            {\n              context: loadContext,\n              params,\n              request\n            }\n          );\n          return new Response(\"Not Found\", {\n            status: 404,\n            statusText: \"Not Found\"\n          });\n        }\n        decodedPath = strippedPath;\n      }\n      if (_build.prerender.length === 0) {\n        isSpaMode = true;\n      } else if (!_build.prerender.includes(decodedPath) && !_build.prerender.includes(decodedPath + \"/\")) {\n        if (url.pathname.endsWith(\".data\")) {\n          errorHandler(\n            new _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorResponseImpl(\n              404,\n              \"Not Found\",\n              `Refusing to SSR the path \\`${decodedPath}\\` because \\`ssr:false\\` is set and the path is not included in the \\`prerender\\` config, so in production the path will be a 404.`\n            ),\n            {\n              context: loadContext,\n              params,\n              request\n            }\n          );\n          return new Response(\"Not Found\", {\n            status: 404,\n            statusText: \"Not Found\"\n          });\n        } else {\n          isSpaMode = true;\n        }\n      }\n    }\n    let manifestUrl = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.getManifestPath)(\n      _build.routeDiscovery.manifestPath,\n      normalizedBasename\n    );\n    if (url.pathname === manifestUrl) {\n      try {\n        let res = await handleManifestRequest(_build, routes, url);\n        return res;\n      } catch (e) {\n        handleError(e);\n        return new Response(\"Unknown Server Error\", { status: 500 });\n      }\n    }\n    let matches = matchServerRoutes(routes, normalizedPath, _build.basename);\n    if (matches && matches.length > 0) {\n      Object.assign(params, matches[0].params);\n    }\n    let response;\n    if (url.pathname.endsWith(\".data\")) {\n      let handlerUrl = new URL(request.url);\n      handlerUrl.pathname = normalizedPath;\n      let singleFetchMatches = matchServerRoutes(\n        routes,\n        handlerUrl.pathname,\n        _build.basename\n      );\n      response = await handleSingleFetchRequest(\n        serverMode,\n        _build,\n        staticHandler,\n        request,\n        handlerUrl,\n        loadContext,\n        handleError\n      );\n      if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRedirectResponse)(response)) {\n        response = generateSingleFetchRedirectResponse(\n          response,\n          request,\n          _build,\n          serverMode\n        );\n      }\n      if (_build.entry.module.handleDataRequest) {\n        response = await _build.entry.module.handleDataRequest(response, {\n          context: loadContext,\n          params: singleFetchMatches ? singleFetchMatches[0].params : {},\n          request\n        });\n        if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRedirectResponse)(response)) {\n          response = generateSingleFetchRedirectResponse(\n            response,\n            request,\n            _build,\n            serverMode\n          );\n        }\n      }\n    } else if (!isSpaMode && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n      response = await handleResourceRequest(\n        serverMode,\n        _build,\n        staticHandler,\n        matches.slice(-1)[0].route.id,\n        request,\n        loadContext,\n        handleError\n      );\n    } else {\n      let { pathname } = url;\n      let criticalCss = void 0;\n      if (_build.unstable_getCriticalCss) {\n        criticalCss = await _build.unstable_getCriticalCss({ pathname });\n      } else if (mode === \"development\" /* Development */ && getDevServerHooks()?.getCriticalCss) {\n        criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);\n      }\n      response = await handleDocumentRequest(\n        serverMode,\n        _build,\n        staticHandler,\n        request,\n        loadContext,\n        handleError,\n        isSpaMode,\n        criticalCss\n      );\n    }\n    if (request.method === \"HEAD\") {\n      return new Response(null, {\n        headers: response.headers,\n        status: response.status,\n        statusText: response.statusText\n      });\n    }\n    return response;\n  };\n};\nasync function handleManifestRequest(build, routes, url) {\n  if (build.assets.version !== url.searchParams.get(\"version\")) {\n    return new Response(null, {\n      status: 204,\n      headers: {\n        \"X-Remix-Reload-Document\": \"true\"\n      }\n    });\n  }\n  let patches = {};\n  if (url.searchParams.has(\"paths\")) {\n    let paths = /* @__PURE__ */ new Set();\n    let pathParam = url.searchParams.get(\"paths\") || \"\";\n    let requestedPaths = pathParam.split(\",\").filter(Boolean);\n    requestedPaths.forEach((path) => {\n      if (!path.startsWith(\"/\")) {\n        path = `/${path}`;\n      }\n      let segments = path.split(\"/\").slice(1);\n      segments.forEach((_, i) => {\n        let partialPath = segments.slice(0, i + 1).join(\"/\");\n        paths.add(`/${partialPath}`);\n      });\n    });\n    for (let path of paths) {\n      let matches = matchServerRoutes(routes, path, build.basename);\n      if (matches) {\n        for (let match of matches) {\n          let routeId = match.route.id;\n          let route = build.assets.routes[routeId];\n          if (route) {\n            patches[routeId] = route;\n          }\n        }\n      }\n    }\n    return Response.json(patches, {\n      headers: {\n        \"Cache-Control\": \"public, max-age=31536000, immutable\"\n      }\n    });\n  }\n  return new Response(\"Invalid Request\", { status: 400 });\n}\nasync function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {\n  let response = request.method !== \"GET\" ? await singleFetchAction(\n    build,\n    serverMode,\n    staticHandler,\n    request,\n    handlerUrl,\n    loadContext,\n    handleError\n  ) : await singleFetchLoaders(\n    build,\n    serverMode,\n    staticHandler,\n    request,\n    handlerUrl,\n    loadContext,\n    handleError\n  );\n  return response;\n}\nasync function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {\n  try {\n    let result = await staticHandler.query(request, {\n      requestContext: loadContext,\n      generateMiddlewareResponse: build.future.v8_middleware ? async (query) => {\n        try {\n          let innerResult = await query(request);\n          if (!(0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isResponse)(innerResult)) {\n            innerResult = await renderHtml(innerResult, isSpaMode);\n          }\n          return innerResult;\n        } catch (error) {\n          handleError(error);\n          return new Response(null, { status: 500 });\n        }\n      } : void 0\n    });\n    if (!(0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isResponse)(result)) {\n      result = await renderHtml(result, isSpaMode);\n    }\n    return result;\n  } catch (error) {\n    handleError(error);\n    return new Response(null, { status: 500 });\n  }\n  async function renderHtml(context, isSpaMode2) {\n    let headers = getDocumentHeaders(context, build);\n    if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {\n      return new Response(null, { status: context.statusCode, headers });\n    }\n    if (context.errors) {\n      Object.values(context.errors).forEach((err) => {\n        if (!(0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(err) || err.error) {\n          handleError(err);\n        }\n      });\n      context.errors = sanitizeErrors(context.errors, serverMode);\n    }\n    let state = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors, serverMode)\n    };\n    let baseServerHandoff = {\n      basename: build.basename,\n      future: build.future,\n      routeDiscovery: build.routeDiscovery,\n      ssr: build.ssr,\n      isSpaMode: isSpaMode2\n    };\n    let entryContext = {\n      manifest: build.assets,\n      routeModules: createEntryRouteModules(build.routes),\n      staticHandlerContext: context,\n      criticalCss,\n      serverHandoffString: createServerHandoffString({\n        ...baseServerHandoff,\n        criticalCss\n      }),\n      serverHandoffStream: encodeViaTurboStream(\n        state,\n        request.signal,\n        build.entry.module.streamTimeout,\n        serverMode\n      ),\n      renderMeta: {},\n      future: build.future,\n      ssr: build.ssr,\n      routeDiscovery: build.routeDiscovery,\n      isSpaMode: isSpaMode2,\n      serializeError: (err) => serializeError(err, serverMode)\n    };\n    let handleDocumentRequestFunction = build.entry.module.default;\n    try {\n      return await handleDocumentRequestFunction(\n        request,\n        context.statusCode,\n        headers,\n        entryContext,\n        loadContext\n      );\n    } catch (error) {\n      handleError(error);\n      let errorForSecondRender = error;\n      if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isResponse)(error)) {\n        try {\n          let data2 = await unwrapResponse(error);\n          errorForSecondRender = new _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorResponseImpl(\n            error.status,\n            error.statusText,\n            data2\n          );\n        } catch (e) {\n        }\n      }\n      context = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.getStaticContextFromError)(\n        staticHandler.dataRoutes,\n        context,\n        errorForSecondRender\n      );\n      if (context.errors) {\n        context.errors = sanitizeErrors(context.errors, serverMode);\n      }\n      let state2 = {\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: serializeErrors(context.errors, serverMode)\n      };\n      entryContext = {\n        ...entryContext,\n        staticHandlerContext: context,\n        serverHandoffString: createServerHandoffString(baseServerHandoff),\n        serverHandoffStream: encodeViaTurboStream(\n          state2,\n          request.signal,\n          build.entry.module.streamTimeout,\n          serverMode\n        ),\n        renderMeta: {}\n      };\n      try {\n        return await handleDocumentRequestFunction(\n          request,\n          context.statusCode,\n          headers,\n          entryContext,\n          loadContext\n        );\n      } catch (error2) {\n        handleError(error2);\n        return returnLastResortErrorResponse(error2, serverMode);\n      }\n    }\n  }\n}\nasync function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {\n  try {\n    let result = await staticHandler.queryRoute(request, {\n      routeId,\n      requestContext: loadContext,\n      generateMiddlewareResponse: build.future.v8_middleware ? async (queryRoute) => {\n        try {\n          let innerResult = await queryRoute(request);\n          return handleQueryRouteResult(innerResult);\n        } catch (error) {\n          return handleQueryRouteError(error);\n        }\n      } : void 0\n    });\n    return handleQueryRouteResult(result);\n  } catch (error) {\n    return handleQueryRouteError(error);\n  }\n  function handleQueryRouteResult(result) {\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isResponse)(result)) {\n      return result;\n    }\n    if (typeof result === \"string\") {\n      return new Response(result);\n    }\n    return Response.json(result);\n  }\n  function handleQueryRouteError(error) {\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isResponse)(error)) {\n      return error;\n    }\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error)) {\n      handleError(error);\n      return errorResponseToJson(error, serverMode);\n    }\n    if (error instanceof Error && error.message === \"Expected a response from queryRoute\") {\n      let newError = new Error(\n        \"Expected a Response to be returned from resource route handler\"\n      );\n      handleError(newError);\n      return returnLastResortErrorResponse(newError, serverMode);\n    }\n    handleError(error);\n    return returnLastResortErrorResponse(error, serverMode);\n  }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n  return Response.json(\n    serializeError(\n      // @ts-expect-error This is \"private\" from users but intended for internal use\n      errorResponse.error || new Error(\"Unexpected Server Error\"),\n      serverMode\n    ),\n    {\n      status: errorResponse.status,\n      statusText: errorResponse.statusText\n    }\n  );\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n  let message = \"Unexpected Server Error\";\n  if (serverMode !== \"production\" /* Production */) {\n    message += `\n\n${String(error)}`;\n  }\n  return new Response(message, {\n    status: 500,\n    headers: {\n      \"Content-Type\": \"text/plain\"\n    }\n  });\n}\nfunction unwrapResponse(response) {\n  let contentType = response.headers.get(\"Content-Type\");\n  return contentType && /\\bapplication\\/json\\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();\n}\n\n// lib/server-runtime/sessions.ts\nfunction flash(name) {\n  return `__flash_${name}__`;\n}\nvar createSession = (initialData = {}, id = \"\") => {\n  let map = new Map(Object.entries(initialData));\n  return {\n    get id() {\n      return id;\n    },\n    get data() {\n      return Object.fromEntries(map);\n    },\n    has(name) {\n      return map.has(name) || map.has(flash(name));\n    },\n    get(name) {\n      if (map.has(name)) return map.get(name);\n      let flashName = flash(name);\n      if (map.has(flashName)) {\n        let value = map.get(flashName);\n        map.delete(flashName);\n        return value;\n      }\n      return void 0;\n    },\n    set(name, value) {\n      map.set(name, value);\n    },\n    flash(name, value) {\n      map.set(flash(name), value);\n    },\n    unset(name) {\n      map.delete(name);\n    }\n  };\n};\nvar isSession = (object) => {\n  return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nfunction createSessionStorage({\n  cookie: cookieArg,\n  createData,\n  readData,\n  updateData,\n  deleteData\n}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      let id = cookieHeader && await cookie.parse(cookieHeader, options);\n      let data2 = id && await readData(id);\n      return createSession(data2 || {}, id || \"\");\n    },\n    async commitSession(session, options) {\n      let { id, data: data2 } = session;\n      let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;\n      if (id) {\n        await updateData(id, data2, expires);\n      } else {\n        id = await createData(data2, expires);\n      }\n      return cookie.serialize(id, options);\n    },\n    async destroySession(session, options) {\n      await deleteData(session.id);\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */ new Date(0)\n      });\n    }\n  };\n}\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n  (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.warnOnce)(\n    cookie.isSigned,\n    `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`\n  );\n}\n\n// lib/server-runtime/sessions/cookieStorage.ts\nfunction createCookieSessionStorage({ cookie: cookieArg } = {}) {\n  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n  warnOnceAboutSigningSessionCookie(cookie);\n  return {\n    async getSession(cookieHeader, options) {\n      return createSession(\n        cookieHeader && await cookie.parse(cookieHeader, options) || {}\n      );\n    },\n    async commitSession(session, options) {\n      let serializedCookie = await cookie.serialize(session.data, options);\n      if (serializedCookie.length > 4096) {\n        throw new Error(\n          \"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length\n        );\n      }\n      return serializedCookie;\n    },\n    async destroySession(_session, options) {\n      return cookie.serialize(\"\", {\n        ...options,\n        maxAge: void 0,\n        expires: /* @__PURE__ */ new Date(0)\n      });\n    }\n  };\n}\n\n// lib/server-runtime/sessions/memoryStorage.ts\nfunction createMemorySessionStorage({ cookie } = {}) {\n  let map = /* @__PURE__ */ new Map();\n  return createSessionStorage({\n    cookie,\n    async createData(data2, expires) {\n      let id = Math.random().toString(36).substring(2, 10);\n      map.set(id, { data: data2, expires });\n      return id;\n    },\n    async readData(id) {\n      if (map.has(id)) {\n        let { data: data2, expires } = map.get(id);\n        if (!expires || expires > /* @__PURE__ */ new Date()) {\n          return data2;\n        }\n        if (expires) map.delete(id);\n      }\n      return null;\n    },\n    async updateData(id, data2, expires) {\n      map.set(id, { data: data2, expires });\n    },\n    async deleteData(id) {\n      map.delete(id);\n    }\n  });\n}\n\n// lib/href.ts\nfunction href(path, ...args) {\n  let params = args[0];\n  let result = path.replace(/\\/*\\*?$/, \"\").replace(\n    /\\/:([\\w-]+)(\\?)?/g,\n    // same regex as in .\\router\\utils.ts: compilePath().\n    (_, param, questionMark) => {\n      const isRequired = questionMark === void 0;\n      const value = params ? params[param] : void 0;\n      if (isRequired && value === void 0) {\n        throw new Error(\n          `Path '${path}' requires param '${param}' but it was not provided`\n        );\n      }\n      return value === void 0 ? \"\" : \"/\" + value;\n    }\n  );\n  if (path.endsWith(\"*\")) {\n    const value = params ? params[\"*\"] : void 0;\n    if (value !== void 0) {\n      result += \"/\" + value;\n    }\n  }\n  return result || \"/\";\n}\n\n// lib/rsc/browser.tsx\n\n\n\n// lib/dom/ssr/hydration.tsx\nfunction getHydrationData({\n  state,\n  routes,\n  getRouteInfo,\n  location: location2,\n  basename,\n  isSpaMode\n}) {\n  let hydrationData = {\n    ...state,\n    loaderData: { ...state.loaderData }\n  };\n  let initialMatches = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, location2, basename);\n  if (initialMatches) {\n    for (let match of initialMatches) {\n      let routeId = match.route.id;\n      let routeInfo = getRouteInfo(routeId);\n      if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.shouldHydrateRouteLoader)(\n        routeId,\n        routeInfo.clientLoader,\n        routeInfo.hasLoader,\n        isSpaMode\n      ) && (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {\n        delete hydrationData.loaderData[routeId];\n      } else if (!routeInfo.hasLoader) {\n        hydrationData.loaderData[routeId] = null;\n      }\n    }\n  }\n  return hydrationData;\n}\n\n// lib/rsc/errorBoundaries.tsx\n\nvar RSCRouterGlobalErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: null, location: props.location };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location) {\n      return { error: null, location: props.location };\n    }\n    return { error: state.error, location: state.location };\n  }\n  render() {\n    if (this.state.error) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        RSCDefaultRootErrorBoundaryImpl,\n        {\n          error: this.state.error,\n          renderAppShell: true\n        }\n      );\n    } else {\n      return this.props.children;\n    }\n  }\n};\nfunction ErrorWrapper({\n  renderAppShell,\n  title,\n  children\n}) {\n  if (!renderAppShell) {\n    return children;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"html\", { lang: \"en\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"head\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"meta\", { charSet: \"utf-8\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"meta\",\n    {\n      name: \"viewport\",\n      content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }\n  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", null, title)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"body\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"main\", { style: { fontFamily: \"system-ui, sans-serif\", padding: \"2rem\" } }, children)));\n}\nfunction RSCDefaultRootErrorBoundaryImpl({\n  error,\n  renderAppShell\n}) {\n  console.error(error);\n  let heyDeveloper = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n      }\n    }\n  );\n  if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error)) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      ErrorWrapper,\n      {\n        renderAppShell,\n        title: \"Unhandled Thrown Response!\"\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", { style: { fontSize: \"24px\" } }, error.status, \" \", error.statusText),\n      _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.ENABLE_DEV_WARNINGS ? heyDeveloper : null\n    );\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ErrorWrapper, { renderAppShell, title: \"Application Error!\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", { style: { fontSize: \"24px\" } }, \"Application Error\"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"pre\",\n    {\n      style: {\n        padding: \"2rem\",\n        background: \"hsla(10, 50%, 50%, 0.1)\",\n        color: \"red\",\n        overflow: \"auto\"\n      }\n    },\n    errorInstance.stack\n  ), heyDeveloper);\n}\nfunction RSCDefaultRootErrorBoundary({\n  hasRootLayout\n}) {\n  let error = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.useRouteError)();\n  if (hasRootLayout === void 0) {\n    throw new Error(\"Missing 'hasRootLayout' prop\");\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    RSCDefaultRootErrorBoundaryImpl,\n    {\n      renderAppShell: !hasRootLayout,\n      error\n    }\n  );\n}\n\n// lib/rsc/route-modules.ts\nfunction createRSCRouteModules(payload) {\n  const routeModules = {};\n  for (const match of payload.matches) {\n    populateRSCRouteModules(routeModules, match);\n  }\n  return routeModules;\n}\nfunction populateRSCRouteModules(routeModules, matches) {\n  matches = Array.isArray(matches) ? matches : [matches];\n  for (const match of matches) {\n    routeModules[match.id] = {\n      links: match.links,\n      meta: match.meta,\n      default: noopComponent\n    };\n  }\n}\nvar noopComponent = () => null;\n\n// lib/rsc/browser.tsx\nfunction createCallServer({\n  createFromReadableStream,\n  createTemporaryReferenceSet,\n  encodeReply,\n  fetch: fetchImplementation = fetch\n}) {\n  const globalVar = window;\n  let landedActionId = 0;\n  return async (id, args) => {\n    let actionId = globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const payloadPromise = fetchImplementation(\n      new Request(location.href, {\n        body: await encodeReply(args, { temporaryReferences }),\n        method: \"POST\",\n        headers: {\n          Accept: \"text/x-component\",\n          \"rsc-action-id\": id\n        }\n      })\n    ).then((response) => {\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n      return createFromReadableStream(response.body, {\n        temporaryReferences\n      });\n    });\n    globalVar.__reactRouterDataRouter.__setPendingRerender(\n      Promise.resolve(payloadPromise).then(async (payload) => {\n        if (payload.type === \"redirect\") {\n          if (payload.reload) {\n            window.location.href = payload.location;\n            return () => {\n            };\n          }\n          return () => {\n            globalVar.__reactRouterDataRouter.navigate(payload.location, {\n              replace: payload.replace\n            });\n          };\n        }\n        if (payload.type !== \"action\") {\n          throw new Error(\"Unexpected payload type\");\n        }\n        const rerender = await payload.rerender;\n        if (rerender && landedActionId < actionId && globalVar.__routerActionID <= actionId) {\n          if (rerender.type === \"redirect\") {\n            if (rerender.reload) {\n              window.location.href = rerender.location;\n              return;\n            }\n            return () => {\n              globalVar.__reactRouterDataRouter.navigate(rerender.location, {\n                replace: rerender.replace\n              });\n            };\n          }\n          return () => {\n            let lastMatch;\n            for (const match of rerender.matches) {\n              globalVar.__reactRouterDataRouter.patchRoutes(\n                lastMatch?.id ?? null,\n                [createRouteFromServerManifest(match)],\n                true\n              );\n              lastMatch = match;\n            }\n            window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp(\n              {\n                loaderData: Object.assign(\n                  {},\n                  globalVar.__reactRouterDataRouter.state.loaderData,\n                  rerender.loaderData\n                ),\n                errors: rerender.errors ? Object.assign(\n                  {},\n                  globalVar.__reactRouterDataRouter.state.errors,\n                  rerender.errors\n                ) : null\n              }\n            );\n          };\n        }\n        return () => {\n        };\n      }).catch(() => {\n      })\n    );\n    return payloadPromise.then((payload) => {\n      if (payload.type !== \"action\" && payload.type !== \"redirect\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      return payload.actionResult;\n    });\n  };\n}\nfunction createRouterFromPayload({\n  fetchImplementation,\n  createFromReadableStream,\n  getContext,\n  payload\n}) {\n  const globalVar = window;\n  if (globalVar.__reactRouterDataRouter && globalVar.__reactRouterRouteModules)\n    return {\n      router: globalVar.__reactRouterDataRouter,\n      routeModules: globalVar.__reactRouterRouteModules\n    };\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  globalVar.__reactRouterRouteModules = globalVar.__reactRouterRouteModules ?? {};\n  populateRSCRouteModules(globalVar.__reactRouterRouteModules, payload.matches);\n  let patches = /* @__PURE__ */ new Map();\n  payload.patches?.forEach((patch) => {\n    (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.invariant)(patch.parentId, \"Invalid patch parentId\");\n    if (!patches.has(patch.parentId)) {\n      patches.set(patch.parentId, []);\n    }\n    patches.get(patch.parentId)?.push(patch);\n  });\n  let routes = payload.matches.reduceRight((previous, match) => {\n    const route = createRouteFromServerManifest(\n      match,\n      payload\n    );\n    if (previous.length > 0) {\n      route.children = previous;\n      let childrenToPatch = patches.get(match.id);\n      if (childrenToPatch) {\n        route.children.push(\n          ...childrenToPatch.map((r) => createRouteFromServerManifest(r))\n        );\n      }\n    }\n    return [route];\n  }, []);\n  globalVar.__reactRouterDataRouter = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n    routes,\n    getContext,\n    basename: payload.basename,\n    history: (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)(),\n    hydrationData: getHydrationData({\n      state: {\n        loaderData: payload.loaderData,\n        actionData: payload.actionData,\n        errors: payload.errors\n      },\n      routes,\n      getRouteInfo: (routeId) => {\n        let match = payload.matches.find((m) => m.id === routeId);\n        (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.invariant)(match, \"Route not found in payload\");\n        return {\n          clientLoader: match.clientLoader,\n          hasLoader: match.hasLoader,\n          hasHydrateFallback: match.hydrateFallbackElement != null\n        };\n      },\n      location: payload.location,\n      basename: payload.basename,\n      isSpaMode: false\n    }),\n    async patchRoutesOnNavigation({ path, signal }) {\n      if (discoveredPaths.has(path)) {\n        return;\n      }\n      await fetchAndApplyManifestPatches(\n        [path],\n        createFromReadableStream,\n        fetchImplementation,\n        signal\n      );\n    },\n    // FIXME: Pass `build.ssr` into this function\n    dataStrategy: getRSCSingleFetchDataStrategy(\n      () => globalVar.__reactRouterDataRouter,\n      true,\n      payload.basename,\n      createFromReadableStream,\n      fetchImplementation\n    )\n  });\n  if (globalVar.__reactRouterDataRouter.state.initialized) {\n    globalVar.__routerInitialized = true;\n    globalVar.__reactRouterDataRouter.initialize();\n  } else {\n    globalVar.__routerInitialized = false;\n  }\n  let lastLoaderData = void 0;\n  globalVar.__reactRouterDataRouter.subscribe(({ loaderData, actionData }) => {\n    if (lastLoaderData !== loaderData) {\n      globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    }\n  });\n  globalVar.__reactRouterDataRouter._updateRoutesForHMR = (routeUpdateByRouteId) => {\n    const oldRoutes = window.__reactRouterDataRouter.routes;\n    const newRoutes = [];\n    function walkRoutes(routes2, parentId) {\n      return routes2.map((route) => {\n        const routeUpdate = routeUpdateByRouteId.get(route.id);\n        if (routeUpdate) {\n          const {\n            routeModule,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader\n          } = routeUpdate;\n          const newRoute = createRouteFromServerManifest({\n            clientAction: routeModule.clientAction,\n            clientLoader: routeModule.clientLoader,\n            element: route.element,\n            errorElement: route.errorElement,\n            handle: route.handle,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader,\n            hydrateFallbackElement: route.hydrateFallbackElement,\n            id: route.id,\n            index: route.index,\n            links: routeModule.links,\n            meta: routeModule.meta,\n            parentId,\n            path: route.path,\n            shouldRevalidate: routeModule.shouldRevalidate\n          });\n          if (route.children) {\n            newRoute.children = walkRoutes(route.children, route.id);\n          }\n          return newRoute;\n        }\n        const updatedRoute = { ...route };\n        if (route.children) {\n          updatedRoute.children = walkRoutes(route.children, route.id);\n        }\n        return updatedRoute;\n      });\n    }\n    newRoutes.push(\n      ...walkRoutes(oldRoutes, void 0)\n    );\n    window.__reactRouterDataRouter._internalSetRoutes(newRoutes);\n  };\n  return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n}\nvar renderedRoutesContext = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\n  let dataStrategy = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.getSingleFetchDataStrategyImpl)(\n    getRouter,\n    (match) => {\n      let M = match;\n      return {\n        hasLoader: M.route.hasLoader,\n        hasClientLoader: M.route.hasClientLoader,\n        hasComponent: M.route.hasComponent,\n        hasAction: M.route.hasAction,\n        hasClientAction: M.route.hasClientAction,\n        hasShouldRevalidate: M.route.hasShouldRevalidate\n      };\n    },\n    // pass map into fetchAndDecode so it can add payloads\n    getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation),\n    ssr,\n    basename,\n    // If the route has a component but we don't have an element, we need to hit\n    // the server loader flow regardless of whether the client loader calls\n    // `serverLoader` or not, otherwise we'll have nothing to render.\n    (match) => {\n      let M = match;\n      return M.route.hasComponent && !M.route.element;\n    }\n  );\n  return async (args) => args.runClientMiddleware(async () => {\n    let context = args.context;\n    context.set(renderedRoutesContext, []);\n    let results = await dataStrategy(args);\n    const renderedRoutesById = /* @__PURE__ */ new Map();\n    for (const route of context.get(renderedRoutesContext)) {\n      if (!renderedRoutesById.has(route.id)) {\n        renderedRoutesById.set(route.id, []);\n      }\n      renderedRoutesById.get(route.id).push(route);\n    }\n    for (const match of args.matches) {\n      const renderedRoutes = renderedRoutesById.get(match.route.id);\n      if (renderedRoutes) {\n        for (const rendered of renderedRoutes) {\n          window.__reactRouterDataRouter.patchRoutes(\n            rendered.parentId ?? null,\n            [createRouteFromServerManifest(rendered)],\n            true\n          );\n        }\n      }\n    }\n    return results;\n  });\n}\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\n  return async (args, basename, targetRoutes) => {\n    let { request, context } = args;\n    let url = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.singleFetchUrl)(request.url, basename, \"rsc\");\n    if (request.method === \"GET\") {\n      url = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.stripIndexParam)(url);\n      if (targetRoutes) {\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n      }\n    }\n    let res = await fetchImplementation(\n      new Request(url, await (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createRequestInit)(request))\n    );\n    if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\n      throw new _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorResponseImpl(res.status, res.statusText, await res.text());\n    }\n    (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.invariant)(res.body, \"No response body to decode\");\n    try {\n      const payload = await createFromReadableStream(res.body, {\n        temporaryReferences: void 0\n      });\n      if (payload.type === \"redirect\") {\n        return {\n          status: res.status,\n          data: {\n            redirect: {\n              redirect: payload.location,\n              reload: payload.reload,\n              replace: payload.replace,\n              revalidate: false,\n              status: payload.status\n            }\n          }\n        };\n      }\n      if (payload.type !== \"render\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      context.get(renderedRoutesContext).push(...payload.matches);\n      let results = { routes: {} };\n      const dataKey = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isMutationMethod)(request.method) ? \"actionData\" : \"loaderData\";\n      for (let [routeId, data2] of Object.entries(payload[dataKey] || {})) {\n        results.routes[routeId] = { data: data2 };\n      }\n      if (payload.errors) {\n        for (let [routeId, error] of Object.entries(payload.errors)) {\n          results.routes[routeId] = { error };\n        }\n      }\n      return { status: res.status, data: results };\n    } catch (e) {\n      throw new Error(\"Unable to decode RSC response\");\n    }\n  };\n}\nfunction RSCHydratedRouter({\n  createFromReadableStream,\n  fetch: fetchImplementation = fetch,\n  payload,\n  routeDiscovery = \"eager\",\n  getContext\n}) {\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  let { router, routeModules } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => createRouterFromPayload({\n      payload,\n      fetchImplementation,\n      getContext,\n      createFromReadableStream\n    }),\n    [createFromReadableStream, payload, fetchImplementation, getContext]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.setIsHydrated)();\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    const globalVar = window;\n    if (!globalVar.__routerInitialized) {\n      globalVar.__routerInitialized = true;\n      globalVar.__reactRouterDataRouter.initialize();\n    }\n  }, []);\n  let [location2, setLocation] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state.location);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(\n    () => router.subscribe((newState) => {\n      if (newState.location !== location2) {\n        setLocation(newState.location);\n      }\n    }),\n    [router, location2]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (routeDiscovery === \"lazy\" || // @ts-expect-error - TS doesn't know about this yet\n    window.navigator?.connection?.saveData === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let paths = Array.from(nextPaths.keys()).filter((path) => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (paths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(\n          paths,\n          createFromReadableStream,\n          fetchImplementation\n        );\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\n    routeModules\n  };\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RSCRouterGlobalErrorBoundary, { location: location2 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.UNSTABLE_TransitionEnabledRouterProvider, { router, flushSync: react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync }))));\n}\nfunction createRouteFromServerManifest(match, payload) {\n  let hasInitialData = payload && match.id in payload.loaderData;\n  let initialData = payload?.loaderData[match.id];\n  let hasInitialError = payload?.errors && match.id in payload.errors;\n  let initialError = payload?.errors?.[match.id];\n  let isHydrationRequest = match.clientLoader?.hydrate === true || !match.hasLoader || // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match.hasComponent && !match.element;\n  (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.invariant)(window.__reactRouterRouteModules);\n  populateRSCRouteModules(window.__reactRouterRouteModules, match);\n  let dataRoute = {\n    id: match.id,\n    element: match.element,\n    errorElement: match.errorElement,\n    handle: match.handle,\n    hasErrorBoundary: match.hasErrorBoundary,\n    hydrateFallbackElement: match.hydrateFallbackElement,\n    index: match.index,\n    loader: match.clientLoader ? async (args, singleFetch) => {\n      try {\n        let result = await match.clientLoader({\n          ...args,\n          serverLoader: () => {\n            preventInvalidServerHandlerCall(\n              \"loader\",\n              match.id,\n              match.hasLoader\n            );\n            if (isHydrationRequest) {\n              if (hasInitialData) {\n                return initialData;\n              }\n              if (hasInitialError) {\n                throw initialError;\n              }\n            }\n            return callSingleFetch(singleFetch);\n          }\n        });\n        return result;\n      } finally {\n        isHydrationRequest = false;\n      }\n    } : (\n      // We always make the call in this RSC world since even if we don't\n      // have a `loader` we may need to get the `element` implementation\n      (_, singleFetch) => callSingleFetch(singleFetch)\n    ),\n    action: match.clientAction ? (args, singleFetch) => match.clientAction({\n      ...args,\n      serverAction: async () => {\n        preventInvalidServerHandlerCall(\n          \"action\",\n          match.id,\n          match.hasLoader\n        );\n        return await callSingleFetch(singleFetch);\n      }\n    }) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\n      throw (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.noActionDefinedError)(\"action\", match.id);\n    },\n    path: match.path,\n    shouldRevalidate: match.shouldRevalidate,\n    // We always have a \"loader\" in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    hasLoader: true,\n    hasClientLoader: match.clientLoader != null,\n    hasAction: match.hasAction,\n    hasClientAction: match.clientAction != null,\n    hasShouldRevalidate: match.shouldRevalidate != null\n  };\n  if (typeof dataRoute.loader === \"function\") {\n    dataRoute.loader.hydrate = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.shouldHydrateRouteLoader)(\n      match.id,\n      match.clientLoader,\n      match.hasLoader,\n      false\n    );\n  }\n  return dataRoute;\n}\nfunction callSingleFetch(singleFetch) {\n  (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.invariant)(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\n  return singleFetch();\n}\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\n  if (!hasHandler) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${routeId}\")`;\n    console.error(msg);\n    throw new _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction getManifestUrl(paths) {\n  if (paths.length === 0) {\n    return null;\n  }\n  if (paths.length === 1) {\n    return new URL(`${paths[0]}.manifest`, window.location.origin);\n  }\n  const globalVar = window;\n  let basename = (globalVar.__reactRouterDataRouter.basename ?? \"\").replace(\n    /^\\/|\\/$/g,\n    \"\"\n  );\n  let url = new URL(`${basename}/.manifest`, window.location.origin);\n  url.searchParams.set(\"paths\", paths.sort().join(\",\"));\n  return url;\n}\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\n  let url = getManifestUrl(paths);\n  if (url == null) {\n    return;\n  }\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let response = await fetchImplementation(new Request(url, { signal }));\n  if (!response.body || response.status < 200 || response.status >= 300) {\n    throw new Error(\"Unable to fetch new route matches from the server\");\n  }\n  let payload = await createFromReadableStream(response.body, {\n    temporaryReferences: void 0\n  });\n  if (payload.type !== \"manifest\") {\n    throw new Error(\"Failed to patch routes\");\n  }\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\n  payload.patches.forEach((p) => {\n    window.__reactRouterDataRouter.patchRoutes(\n      p.parentId ?? null,\n      [createRouteFromServerManifest(p)]\n    );\n  });\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return (...args) => {\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\n\n// lib/rsc/server.ssr.tsx\n\n\n// lib/rsc/html-stream/server.ts\nvar encoder2 = new TextEncoder();\nvar trailer = \"</body></html>\";\nfunction injectRSCPayload(rscStream) {\n  let decoder = new TextDecoder();\n  let resolveFlightDataPromise;\n  let flightDataPromise = new Promise(\n    (resolve) => resolveFlightDataPromise = resolve\n  );\n  let startedRSC = false;\n  let buffered = [];\n  let timeout = null;\n  function flushBufferedChunks(controller) {\n    for (let chunk of buffered) {\n      let buf = decoder.decode(chunk, { stream: true });\n      if (buf.endsWith(trailer)) {\n        buf = buf.slice(0, -trailer.length);\n      }\n      controller.enqueue(encoder2.encode(buf));\n    }\n    buffered.length = 0;\n    timeout = null;\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      buffered.push(chunk);\n      if (timeout) {\n        return;\n      }\n      timeout = setTimeout(async () => {\n        flushBufferedChunks(controller);\n        if (!startedRSC) {\n          startedRSC = true;\n          writeRSCStream(rscStream, controller).catch((err) => controller.error(err)).then(resolveFlightDataPromise);\n        }\n      }, 0);\n    },\n    async flush(controller) {\n      await flightDataPromise;\n      if (timeout) {\n        clearTimeout(timeout);\n        flushBufferedChunks(controller);\n      }\n      controller.enqueue(encoder2.encode(\"</body></html>\"));\n    }\n  });\n}\nasync function writeRSCStream(rscStream, controller) {\n  let decoder = new TextDecoder(\"utf-8\", { fatal: true });\n  const reader = rscStream.getReader();\n  try {\n    let read;\n    while ((read = await reader.read()) && !read.done) {\n      const chunk = read.value;\n      try {\n        writeChunk(\n          JSON.stringify(decoder.decode(chunk, { stream: true })),\n          controller\n        );\n      } catch (err) {\n        let base64 = JSON.stringify(btoa(String.fromCodePoint(...chunk)));\n        writeChunk(\n          `Uint8Array.from(atob(${base64}), m => m.codePointAt(0))`,\n          controller\n        );\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n  let remaining = decoder.decode();\n  if (remaining.length) {\n    writeChunk(JSON.stringify(remaining), controller);\n  }\n}\nfunction writeChunk(chunk, controller) {\n  controller.enqueue(\n    encoder2.encode(\n      `<script>${escapeScript(\n        `(self.__FLIGHT_DATA||=[]).push(${chunk})`\n      )}</script>`\n    )\n  );\n}\nfunction escapeScript(script) {\n  return script.replace(/<!--/g, \"<\\\\!--\").replace(/<\\/(script)/gi, \"</\\\\$1\");\n}\n\n// lib/rsc/server.ssr.tsx\nvar REACT_USE = \"use\";\nvar useImpl = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[REACT_USE];\nfunction useSafe(promise) {\n  if (useImpl) {\n    return useImpl(promise);\n  }\n  throw new Error(\"React Router v7 requires React 19+ for RSC features.\");\n}\nasync function routeRSCServerRequest({\n  request,\n  fetchServer,\n  createFromReadableStream,\n  renderHTML,\n  hydrate = true\n}) {\n  const url = new URL(request.url);\n  const isDataRequest = isReactServerRequest(url);\n  const respondWithRSCPayload = isDataRequest || isManifestRequest(url) || request.headers.has(\"rsc-action-id\");\n  const serverResponse = await fetchServer(request);\n  if (respondWithRSCPayload || serverResponse.headers.get(\"React-Router-Resource\") === \"true\") {\n    return serverResponse;\n  }\n  if (!serverResponse.body) {\n    throw new Error(\"Missing body in server response\");\n  }\n  const detectRedirectResponse = serverResponse.clone();\n  let serverResponseB = null;\n  if (hydrate) {\n    serverResponseB = serverResponse.clone();\n  }\n  const body = serverResponse.body;\n  let buffer;\n  let streamControllers = [];\n  const createStream = () => {\n    if (!buffer) {\n      buffer = [];\n      return body.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            buffer.push(chunk);\n            controller.enqueue(chunk);\n            streamControllers.forEach((c) => c.enqueue(chunk));\n          },\n          flush() {\n            streamControllers.forEach((c) => c.close());\n            streamControllers = [];\n          }\n        })\n      );\n    }\n    return new ReadableStream({\n      start(controller) {\n        buffer.forEach((chunk) => controller.enqueue(chunk));\n        streamControllers.push(controller);\n      }\n    });\n  };\n  let deepestRenderedBoundaryId = null;\n  const getPayload = () => {\n    const payloadPromise = Promise.resolve(\n      createFromReadableStream(createStream())\n    );\n    return Object.defineProperties(payloadPromise, {\n      _deepestRenderedBoundaryId: {\n        get() {\n          return deepestRenderedBoundaryId;\n        },\n        set(boundaryId) {\n          deepestRenderedBoundaryId = boundaryId;\n        }\n      },\n      formState: {\n        get() {\n          return payloadPromise.then(\n            (payload) => payload.type === \"render\" ? payload.formState : void 0\n          );\n        }\n      }\n    });\n  };\n  try {\n    if (!detectRedirectResponse.body) {\n      throw new Error(\"Failed to clone server response\");\n    }\n    const payload = await createFromReadableStream(\n      detectRedirectResponse.body\n    );\n    if (serverResponse.status === _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.SINGLE_FETCH_REDIRECT_STATUS && payload.type === \"redirect\") {\n      const headers2 = new Headers(serverResponse.headers);\n      headers2.delete(\"Content-Encoding\");\n      headers2.delete(\"Content-Length\");\n      headers2.delete(\"Content-Type\");\n      headers2.delete(\"X-Remix-Response\");\n      headers2.set(\"Location\", payload.location);\n      return new Response(serverResponseB?.body || \"\", {\n        headers: headers2,\n        status: payload.status,\n        statusText: serverResponse.statusText\n      });\n    }\n    const html = await renderHTML(getPayload);\n    const headers = new Headers(serverResponse.headers);\n    headers.set(\"Content-Type\", \"text/html; charset=utf-8\");\n    if (!hydrate) {\n      return new Response(html, {\n        status: serverResponse.status,\n        headers\n      });\n    }\n    if (!serverResponseB?.body) {\n      throw new Error(\"Failed to clone server response\");\n    }\n    const body2 = html.pipeThrough(injectRSCPayload(serverResponseB.body));\n    return new Response(body2, {\n      status: serverResponse.status,\n      headers\n    });\n  } catch (reason) {\n    if (reason instanceof Response) {\n      return reason;\n    }\n    try {\n      const status = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(reason) ? reason.status : 500;\n      const html = await renderHTML(() => {\n        const decoded = Promise.resolve(\n          createFromReadableStream(createStream())\n        );\n        const payloadPromise = decoded.then(\n          (payload) => Object.assign(payload, {\n            status,\n            errors: deepestRenderedBoundaryId ? {\n              [deepestRenderedBoundaryId]: reason\n            } : {}\n          })\n        );\n        return Object.defineProperties(payloadPromise, {\n          _deepestRenderedBoundaryId: {\n            get() {\n              return deepestRenderedBoundaryId;\n            },\n            set(boundaryId) {\n              deepestRenderedBoundaryId = boundaryId;\n            }\n          },\n          formState: {\n            get() {\n              return payloadPromise.then(\n                (payload) => payload.type === \"render\" ? payload.formState : void 0\n              );\n            }\n          }\n        });\n      });\n      const headers = new Headers(serverResponse.headers);\n      headers.set(\"Content-Type\", \"text/html\");\n      if (!hydrate) {\n        return new Response(html, {\n          status,\n          headers\n        });\n      }\n      if (!serverResponseB?.body) {\n        throw new Error(\"Failed to clone server response\");\n      }\n      const body2 = html.pipeThrough(injectRSCPayload(serverResponseB.body));\n      return new Response(body2, {\n        status,\n        headers\n      });\n    } catch {\n    }\n    throw reason;\n  }\n}\nfunction RSCStaticRouter({ getPayload }) {\n  const decoded = getPayload();\n  const payload = useSafe(decoded);\n  if (payload.type === \"redirect\") {\n    throw new Response(null, {\n      status: payload.status,\n      headers: {\n        Location: payload.location\n      }\n    });\n  }\n  if (payload.type !== \"render\") return null;\n  let patchedLoaderData = { ...payload.loaderData };\n  for (const match of payload.matches) {\n    if ((0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.shouldHydrateRouteLoader)(\n      match.id,\n      match.clientLoader,\n      match.hasLoader,\n      false\n    ) && (match.hydrateFallbackElement || !match.hasLoader)) {\n      delete patchedLoaderData[match.id];\n    }\n  }\n  const context = {\n    get _deepestRenderedBoundaryId() {\n      return decoded._deepestRenderedBoundaryId ?? null;\n    },\n    set _deepestRenderedBoundaryId(boundaryId) {\n      decoded._deepestRenderedBoundaryId = boundaryId;\n    },\n    actionData: payload.actionData,\n    actionHeaders: {},\n    basename: payload.basename,\n    errors: payload.errors,\n    loaderData: patchedLoaderData,\n    loaderHeaders: {},\n    location: payload.location,\n    statusCode: 200,\n    matches: payload.matches.map((match) => ({\n      params: match.params,\n      pathname: match.pathname,\n      pathnameBase: match.pathnameBase,\n      route: {\n        id: match.id,\n        action: match.hasAction || !!match.clientAction,\n        handle: match.handle,\n        hasErrorBoundary: match.hasErrorBoundary,\n        loader: match.hasLoader || !!match.clientLoader,\n        index: match.index,\n        path: match.path,\n        shouldRevalidate: match.shouldRevalidate\n      }\n    }))\n  };\n  const router = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.createStaticRouter)(\n    payload.matches.reduceRight((previous, match) => {\n      const route = {\n        id: match.id,\n        action: match.hasAction || !!match.clientAction,\n        element: match.element,\n        errorElement: match.errorElement,\n        handle: match.handle,\n        hasErrorBoundary: !!match.errorElement,\n        hydrateFallbackElement: match.hydrateFallbackElement,\n        index: match.index,\n        loader: match.hasLoader || !!match.clientLoader,\n        path: match.path,\n        shouldRevalidate: match.shouldRevalidate\n      };\n      if (previous.length > 0) {\n        route.children = previous;\n      }\n      return [route];\n    }, []),\n    context\n  );\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\n    routeModules: createRSCRouteModules(payload)\n  };\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RSCRouterGlobalErrorBoundary, { location: payload.location }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.StaticRouterProvider,\n    {\n      context,\n      router,\n      hydrate: false,\n      nonce: payload.nonce\n    }\n  ))));\n}\nfunction isReactServerRequest(url) {\n  return url.pathname.endsWith(\".rsc\");\n}\nfunction isManifestRequest(url) {\n  return url.pathname.endsWith(\".manifest\");\n}\n\n// lib/rsc/html-stream/browser.ts\nfunction getRSCStream() {\n  let encoder3 = new TextEncoder();\n  let streamController = null;\n  let rscStream = new ReadableStream({\n    start(controller) {\n      if (typeof window === \"undefined\") {\n        return;\n      }\n      let handleChunk = (chunk) => {\n        if (typeof chunk === \"string\") {\n          controller.enqueue(encoder3.encode(chunk));\n        } else {\n          controller.enqueue(chunk);\n        }\n      };\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\n      window.__FLIGHT_DATA.forEach(handleChunk);\n      window.__FLIGHT_DATA.push = (chunk) => {\n        handleChunk(chunk);\n        return 0;\n      };\n      streamController = controller;\n    }\n  });\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      streamController?.close();\n    });\n  } else {\n    streamController?.close();\n  }\n  return rscStream;\n}\n\n// lib/dom/ssr/errors.ts\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_1__.ErrorResponseImpl(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvY2h1bmstNjVYSk1NTE8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcUQ4Qjs7QUFFOUI7QUFDK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBMkQ7QUFDbkUsZUFBZSx1RUFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZFQUF3QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1RUFBa0I7QUFDakMseUJBQXlCLGdEQUFtQixDQUFDLDJDQUFjLHdCQUF3QixnREFBbUI7QUFDdEcsSUFBSSxpRUFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLGdEQUFtQixDQUFDLG1FQUFrQixJQUFJLGlDQUFpQyxrQkFBa0IsZ0RBQW1CO0FBQ3BJLE1BQU0scUVBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnREFBbUIsQ0FBQywyQ0FBYyx3QkFBd0IsZ0RBQW1CO0FBQ2hJLElBQUksK0RBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2dDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQkFBb0IseUNBQWE7QUFDakMsOEJBQThCLHlDQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFT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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQVU7QUFDbEI7QUFDQTtBQUNBLFFBQVEseUVBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsY0FBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLDJDQUEyQztBQUNqRTtBQUNBO0FBQ0EseUJBQXlCLGdEQUFvQixDQUFDLGlFQUFnQixhQUFhLGFBQWEsa0JBQWtCLGdEQUFvQixpQ0FBaUMsNEJBQTRCLGtCQUFrQixnREFBb0IsQ0FBQyxpRUFBZ0IsYUFBYSx5QkFBeUIsa0JBQWtCLGdEQUFvQjtBQUM5VCxJQUFJLHFFQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXdCRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2RldmVsb3BtZW50L2NodW5rLTY1WEpNTUxPLm1qcz82NjZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3Qtcm91dGVyIHY3LjkuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQge1xuICBFTkFCTEVfREVWX1dBUk5JTkdTLFxuICBFcnJvclJlc3BvbnNlSW1wbCxcbiAgRnJhbWV3b3JrQ29udGV4dCxcbiAgTk9fQk9EWV9TVEFUVVNfQ09ERVMsXG4gIE91dGxldCxcbiAgUlNDUm91dGVyQ29udGV4dCxcbiAgUmVtaXhFcnJvckJvdW5kYXJ5LFxuICBSb3V0ZXJDb250ZXh0UHJvdmlkZXIsXG4gIFJvdXRlclByb3ZpZGVyLFxuICBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTLFxuICBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sLFxuICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgU3RyZWFtVHJhbnNmZXIsXG4gIFVOU1RBQkxFX1RyYW5zaXRpb25FbmFibGVkUm91dGVyUHJvdmlkZXIsXG4gIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsXG4gIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBjcmVhdGVDb250ZXh0LFxuICBjcmVhdGVNZW1vcnlSb3V0ZXIsXG4gIGNyZWF0ZVJlcXVlc3RJbml0LFxuICBjcmVhdGVSb3V0ZXIsXG4gIGNyZWF0ZVNlcnZlclJvdXRlcyxcbiAgY3JlYXRlU3RhdGljSGFuZGxlcixcbiAgY3JlYXRlU3RhdGljUm91dGVyLFxuICBkZWNvZGVWaWFUdXJib1N0cmVhbSxcbiAgZW5jb2RlLFxuICBlc2NhcGVIdG1sLFxuICBnZXRNYW5pZmVzdFBhdGgsXG4gIGdldFNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5SW1wbCxcbiAgZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcixcbiAgaW52YXJpYW50LFxuICBpc0RhdGFXaXRoUmVzcG9uc2VJbml0LFxuICBpc011dGF0aW9uTWV0aG9kLFxuICBpc1JlZGlyZWN0UmVzcG9uc2UsXG4gIGlzUmVkaXJlY3RTdGF0dXNDb2RlLFxuICBpc1Jlc3BvbnNlLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgbWF0Y2hSb3V0ZXMsXG4gIG5vQWN0aW9uRGVmaW5lZEVycm9yLFxuICByZWRpcmVjdCxcbiAgcmVkaXJlY3REb2N1bWVudCxcbiAgcmVwbGFjZSxcbiAgc2V0SXNIeWRyYXRlZCxcbiAgc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyLFxuICBzaW5nbGVGZXRjaFVybCxcbiAgc3RyaXBCYXNlbmFtZSxcbiAgc3RyaXBJbmRleFBhcmFtLFxuICB1c2VSb3V0ZUVycm9yLFxuICB3YXJuT25jZSxcbiAgd2l0aENvbXBvbmVudFByb3BzLFxuICB3aXRoRXJyb3JCb3VuZGFyeVByb3BzLFxuICB3aXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHNcbn0gZnJvbSBcIi4vY2h1bmstTklTSFlSSUsubWpzXCI7XG5cbi8vIGxpYi9kb20vc3NyL3NlcnZlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gU2VydmVyUm91dGVyKHtcbiAgY29udGV4dCxcbiAgdXJsLFxuICBub25jZVxufSkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgfVxuICBsZXQgeyBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBjcml0aWNhbENzcywgc2VydmVySGFuZG9mZlN0cmluZyB9ID0gY29udGV4dDtcbiAgbGV0IHJvdXRlcyA9IGNyZWF0ZVNlcnZlclJvdXRlcyhcbiAgICBtYW5pZmVzdC5yb3V0ZXMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIGNvbnRleHQuZnV0dXJlLFxuICAgIGNvbnRleHQuaXNTcGFNb2RlXG4gICk7XG4gIGNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubG9hZGVyRGF0YSA9IHtcbiAgICAuLi5jb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LmxvYWRlckRhdGFcbiAgfTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dC5tYXRjaGVzKSB7XG4gICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBsZXQgcm91dGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG4gICAgbGV0IG1hbmlmZXN0Um91dGUgPSBjb250ZXh0Lm1hbmlmZXN0LnJvdXRlc1tyb3V0ZUlkXTtcbiAgICBpZiAocm91dGUgJiYgbWFuaWZlc3RSb3V0ZSAmJiBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIoXG4gICAgICByb3V0ZUlkLFxuICAgICAgcm91dGUuY2xpZW50TG9hZGVyLFxuICAgICAgbWFuaWZlc3RSb3V0ZS5oYXNMb2FkZXIsXG4gICAgICBjb250ZXh0LmlzU3BhTW9kZVxuICAgICkgJiYgKHJvdXRlLkh5ZHJhdGVGYWxsYmFjayB8fCAhbWFuaWZlc3RSb3V0ZS5oYXNMb2FkZXIpKSB7XG4gICAgICBkZWxldGUgY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dC5sb2FkZXJEYXRhW3JvdXRlSWRdO1xuICAgIH1cbiAgfVxuICBsZXQgcm91dGVyID0gY3JlYXRlU3RhdGljUm91dGVyKHJvdXRlcywgY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgRnJhbWV3b3JrQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgICBjcml0aWNhbENzcyxcbiAgICAgICAgc2VydmVySGFuZG9mZlN0cmluZyxcbiAgICAgICAgZnV0dXJlOiBjb250ZXh0LmZ1dHVyZSxcbiAgICAgICAgc3NyOiBjb250ZXh0LnNzcixcbiAgICAgICAgaXNTcGFNb2RlOiBjb250ZXh0LmlzU3BhTW9kZSxcbiAgICAgICAgcm91dGVEaXNjb3Zlcnk6IGNvbnRleHQucm91dGVEaXNjb3ZlcnksXG4gICAgICAgIHNlcmlhbGl6ZUVycm9yOiBjb250ZXh0LnNlcmlhbGl6ZUVycm9yLFxuICAgICAgICByZW5kZXJNZXRhOiBjb250ZXh0LnJlbmRlck1ldGFcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlbWl4RXJyb3JCb3VuZGFyeSwgeyBsb2NhdGlvbjogcm91dGVyLnN0YXRlLmxvY2F0aW9uIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU3RhdGljUm91dGVyUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgY29udGV4dDogY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgICAgICAgaHlkcmF0ZTogZmFsc2VcbiAgICAgIH1cbiAgICApKVxuICApLCBjb250ZXh0LnNlcnZlckhhbmRvZmZTdHJlYW0gPyAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5TdXNwZW5zZSwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgU3RyZWFtVHJhbnNmZXIsXG4gICAge1xuICAgICAgY29udGV4dCxcbiAgICAgIGlkZW50aWZpZXI6IDAsXG4gICAgICByZWFkZXI6IGNvbnRleHQuc2VydmVySGFuZG9mZlN0cmVhbS5nZXRSZWFkZXIoKSxcbiAgICAgIHRleHREZWNvZGVyOiBuZXcgVGV4dERlY29kZXIoKSxcbiAgICAgIG5vbmNlXG4gICAgfVxuICApKSA6IG51bGwpO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9yb3V0ZXMtdGVzdC1zdHViLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzU3R1Yihyb3V0ZXMsIF9jb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBSb3V0ZXNUZXN0U3R1Yih7XG4gICAgaW5pdGlhbEVudHJpZXMsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIGh5ZHJhdGlvbkRhdGEsXG4gICAgZnV0dXJlXG4gIH0pIHtcbiAgICBsZXQgcm91dGVyUmVmID0gUmVhY3QyLnVzZVJlZigpO1xuICAgIGxldCBmcmFtZXdvcmtDb250ZXh0UmVmID0gUmVhY3QyLnVzZVJlZigpO1xuICAgIGlmIChyb3V0ZXJSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICBmcmFtZXdvcmtDb250ZXh0UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIGZ1dHVyZToge1xuICAgICAgICAgIHVuc3RhYmxlX3N1YlJlc291cmNlSW50ZWdyaXR5OiBmdXR1cmU/LnVuc3RhYmxlX3N1YlJlc291cmNlSW50ZWdyaXR5ID09PSB0cnVlLFxuICAgICAgICAgIHY4X21pZGRsZXdhcmU6IGZ1dHVyZT8udjhfbWlkZGxld2FyZSA9PT0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtYW5pZmVzdDoge1xuICAgICAgICAgIHJvdXRlczoge30sXG4gICAgICAgICAgZW50cnk6IHsgaW1wb3J0czogW10sIG1vZHVsZTogXCJcIiB9LFxuICAgICAgICAgIHVybDogXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIHJvdXRlTW9kdWxlczoge30sXG4gICAgICAgIHNzcjogZmFsc2UsXG4gICAgICAgIGlzU3BhTW9kZTogZmFsc2UsXG4gICAgICAgIHJvdXRlRGlzY292ZXJ5OiB7IG1vZGU6IFwibGF6eVwiLCBtYW5pZmVzdFBhdGg6IFwiL19fbWFuaWZlc3RcIiB9XG4gICAgICB9O1xuICAgICAgbGV0IHBhdGNoZWQgPSBwcm9jZXNzUm91dGVzKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBTdHViUm91dGVPYmplY3RgIGlzIHN0cmljdGVyIGFib3V0IGBsb2FkZXJgL2BhY3Rpb25gXG4gICAgICAgIC8vIHR5cGVzIGNvbXBhcmVkIHRvIGBBZ25vc3RpY1JvdXRlT2JqZWN0YFxuICAgICAgICBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgKHIpID0+IHIpLFxuICAgICAgICBfY29udGV4dCAhPT0gdm9pZCAwID8gX2NvbnRleHQgOiBmdXR1cmU/LnY4X21pZGRsZXdhcmUgPyBuZXcgUm91dGVyQ29udGV4dFByb3ZpZGVyKCkgOiB7fSxcbiAgICAgICAgZnJhbWV3b3JrQ29udGV4dFJlZi5jdXJyZW50Lm1hbmlmZXN0LFxuICAgICAgICBmcmFtZXdvcmtDb250ZXh0UmVmLmN1cnJlbnQucm91dGVNb2R1bGVzXG4gICAgICApO1xuICAgICAgcm91dGVyUmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlSb3V0ZXIocGF0Y2hlZCwge1xuICAgICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgICBoeWRyYXRpb25EYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChGcmFtZXdvcmtDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmcmFtZXdvcmtDb250ZXh0UmVmLmN1cnJlbnQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvdXRlclByb3ZpZGVyLCB7IHJvdXRlcjogcm91dGVyUmVmLmN1cnJlbnQgfSkpO1xuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlcyhyb3V0ZXMsIGNvbnRleHQsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHBhcmVudElkKSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSkgPT4ge1xuICAgIGlmICghcm91dGUuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIHJvdXRlLmlkIGluIHJlYWN0LXJvdXRlciBwcm9jZXNzUm91dGVzKCkgZnVuY3Rpb25cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG5ld1JvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIENvbXBvbmVudDogcm91dGUuQ29tcG9uZW50ID8gd2l0aENvbXBvbmVudFByb3BzKHJvdXRlLkNvbXBvbmVudCkgOiB2b2lkIDAsXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHJvdXRlLkh5ZHJhdGVGYWxsYmFjayA/IHdpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyhyb3V0ZS5IeWRyYXRlRmFsbGJhY2spIDogdm9pZCAwLFxuICAgICAgRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSA/IHdpdGhFcnJvckJvdW5kYXJ5UHJvcHMocm91dGUuRXJyb3JCb3VuZGFyeSkgOiB2b2lkIDAsXG4gICAgICBhY3Rpb246IHJvdXRlLmFjdGlvbiA/IChhcmdzKSA9PiByb3V0ZS5hY3Rpb24oeyAuLi5hcmdzLCBjb250ZXh0IH0pIDogdm9pZCAwLFxuICAgICAgbG9hZGVyOiByb3V0ZS5sb2FkZXIgPyAoYXJncykgPT4gcm91dGUubG9hZGVyKHsgLi4uYXJncywgY29udGV4dCB9KSA6IHZvaWQgMCxcbiAgICAgIG1pZGRsZXdhcmU6IHJvdXRlLm1pZGRsZXdhcmUgPyByb3V0ZS5taWRkbGV3YXJlLm1hcChcbiAgICAgICAgKG13KSA9PiAoLi4uYXJncykgPT4gbXcoXG4gICAgICAgICAgeyAuLi5hcmdzWzBdLCBjb250ZXh0IH0sXG4gICAgICAgICAgYXJnc1sxXVxuICAgICAgICApXG4gICAgICApIDogdm9pZCAwLFxuICAgICAgaGFuZGxlOiByb3V0ZS5oYW5kbGUsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiByb3V0ZS5zaG91bGRSZXZhbGlkYXRlXG4gICAgfTtcbiAgICBsZXQgZW50cnlSb3V0ZSA9IHtcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBpbmRleDogcm91dGUuaW5kZXgsXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIGhhc0FjdGlvbjogcm91dGUuYWN0aW9uICE9IG51bGwsXG4gICAgICBoYXNMb2FkZXI6IHJvdXRlLmxvYWRlciAhPSBudWxsLFxuICAgICAgLy8gV2hlbiB0ZXN0aW5nIHJvdXRlcywgeW91IHNob3VsZCBiZSBzdHViYmluZyBsb2FkZXIvYWN0aW9uL21pZGRsZXdhcmUsXG4gICAgICAvLyBub3QgdHJ5aW5nIHRvIHJlLWltcGxlbWVudCB0aGUgZnVsbCBsb2FkZXIvY2xpZW50TG9hZGVyL1NTUi9oeWRyYXRpb25cbiAgICAgIC8vIGZsb3cuIFRoYXQgaXMgYmV0dGVyIHRlc3RlZCB2aWEgRTJFIHRlc3RzLlxuICAgICAgaGFzQ2xpZW50QWN0aW9uOiBmYWxzZSxcbiAgICAgIGhhc0NsaWVudExvYWRlcjogZmFsc2UsXG4gICAgICBoYXNDbGllbnRNaWRkbGV3YXJlOiBmYWxzZSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLkVycm9yQm91bmRhcnkgIT0gbnVsbCxcbiAgICAgIC8vIGFueSBuZWVkIGZvciB0aGVzZT9cbiAgICAgIG1vZHVsZTogXCJidWlsZC9zdHViLXBhdGgtdG8tbW9kdWxlLmpzXCIsXG4gICAgICBjbGllbnRBY3Rpb25Nb2R1bGU6IHZvaWQgMCxcbiAgICAgIGNsaWVudExvYWRlck1vZHVsZTogdm9pZCAwLFxuICAgICAgY2xpZW50TWlkZGxld2FyZU1vZHVsZTogdm9pZCAwLFxuICAgICAgaHlkcmF0ZUZhbGxiYWNrTW9kdWxlOiB2b2lkIDBcbiAgICB9O1xuICAgIG1hbmlmZXN0LnJvdXRlc1tuZXdSb3V0ZS5pZF0gPSBlbnRyeVJvdXRlO1xuICAgIHJvdXRlTW9kdWxlc1tyb3V0ZS5pZF0gPSB7XG4gICAgICBkZWZhdWx0OiBuZXdSb3V0ZS5Db21wb25lbnQgfHwgT3V0bGV0LFxuICAgICAgRXJyb3JCb3VuZGFyeTogbmV3Um91dGUuRXJyb3JCb3VuZGFyeSB8fCB2b2lkIDAsXG4gICAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZSxcbiAgICAgIGxpbmtzOiByb3V0ZS5saW5rcyxcbiAgICAgIG1ldGE6IHJvdXRlLm1ldGEsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiByb3V0ZS5zaG91bGRSZXZhbGlkYXRlXG4gICAgfTtcbiAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgIG5ld1JvdXRlLmNoaWxkcmVuID0gcHJvY2Vzc1JvdXRlcyhcbiAgICAgICAgcm91dGUuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgIG5ld1JvdXRlLmlkXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Um91dGU7XG4gIH0pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvY29va2llcy50c1xuaW1wb3J0IHsgcGFyc2UsIHNlcmlhbGl6ZSB9IGZyb20gXCJjb29raWVcIjtcblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2NyeXB0by50c1xudmFyIGVuY29kZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRleHRFbmNvZGVyKCk7XG52YXIgc2lnbiA9IGFzeW5jICh2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIGxldCBkYXRhMiA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgbGV0IGtleSA9IGF3YWl0IGNyZWF0ZUtleShzZWNyZXQsIFtcInNpZ25cIl0pO1xuICBsZXQgc2lnbmF0dXJlID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKFwiSE1BQ1wiLCBrZXksIGRhdGEyKTtcbiAgbGV0IGhhc2ggPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSkpLnJlcGxhY2UoXG4gICAgLz0rJC8sXG4gICAgXCJcIlxuICApO1xuICByZXR1cm4gdmFsdWUgKyBcIi5cIiArIGhhc2g7XG59O1xudmFyIHVuc2lnbiA9IGFzeW5jIChjb29raWUsIHNlY3JldCkgPT4ge1xuICBsZXQgaW5kZXggPSBjb29raWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICBsZXQgdmFsdWUgPSBjb29raWUuc2xpY2UoMCwgaW5kZXgpO1xuICBsZXQgaGFzaCA9IGNvb2tpZS5zbGljZShpbmRleCArIDEpO1xuICBsZXQgZGF0YTIgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhd2FpdCBjcmVhdGVLZXkoc2VjcmV0LCBbXCJ2ZXJpZnlcIl0pO1xuICB0cnkge1xuICAgIGxldCBzaWduYXR1cmUgPSBieXRlU3RyaW5nVG9VaW50OEFycmF5KGF0b2IoaGFzaCkpO1xuICAgIGxldCB2YWxpZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KFwiSE1BQ1wiLCBrZXksIHNpZ25hdHVyZSwgZGF0YTIpO1xuICAgIHJldHVybiB2YWxpZCA/IHZhbHVlIDogZmFsc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGNyZWF0ZUtleSA9IGFzeW5jIChzZWNyZXQsIHVzYWdlcykgPT4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gIFwicmF3XCIsXG4gIGVuY29kZXIuZW5jb2RlKHNlY3JldCksXG4gIHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiIH0sXG4gIGZhbHNlLFxuICB1c2FnZXNcbik7XG5mdW5jdGlvbiBieXRlU3RyaW5nVG9VaW50OEFycmF5KGJ5dGVTdHJpbmcpIHtcbiAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9jb29raWVzLnRzXG52YXIgY3JlYXRlQ29va2llID0gKG5hbWUsIGNvb2tpZU9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQgeyBzZWNyZXRzID0gW10sIC4uLm9wdGlvbnMgfSA9IHtcbiAgICBwYXRoOiBcIi9cIixcbiAgICBzYW1lU2l0ZTogXCJsYXhcIixcbiAgICAuLi5jb29raWVPcHRpb25zXG4gIH07XG4gIHdhcm5PbmNlQWJvdXRFeHBpcmVzQ29va2llKG5hbWUsIG9wdGlvbnMuZXhwaXJlcyk7XG4gIHJldHVybiB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuICAgIGdldCBpc1NpZ25lZCgpIHtcbiAgICAgIHJldHVybiBzZWNyZXRzLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICBnZXQgZXhwaXJlcygpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0aW9ucy5tYXhBZ2UgKiAxZTMpIDogb3B0aW9ucy5leHBpcmVzO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2UoY29va2llSGVhZGVyLCBwYXJzZU9wdGlvbnMpIHtcbiAgICAgIGlmICghY29va2llSGVhZGVyKSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCBjb29raWVzID0gcGFyc2UoY29va2llSGVhZGVyLCB7IC4uLm9wdGlvbnMsIC4uLnBhcnNlT3B0aW9ucyB9KTtcbiAgICAgIGlmIChuYW1lIGluIGNvb2tpZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gY29va2llc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpO1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHNlcmlhbGl6ZSh2YWx1ZSwgc2VyaWFsaXplT3B0aW9ucykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUgPT09IFwiXCIgPyBcIlwiIDogYXdhaXQgZW5jb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi5zZXJpYWxpemVPcHRpb25zXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcbnZhciBpc0Nvb2tpZSA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QubmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmlzU2lnbmVkID09PSBcImJvb2xlYW5cIiAmJiB0eXBlb2Ygb2JqZWN0LnBhcnNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIjtcbn07XG5hc3luYyBmdW5jdGlvbiBlbmNvZGVDb29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0cykge1xuICBsZXQgZW5jb2RlZCA9IGVuY29kZURhdGEodmFsdWUpO1xuICBpZiAoc2VjcmV0cy5sZW5ndGggPiAwKSB7XG4gICAgZW5jb2RlZCA9IGF3YWl0IHNpZ24oZW5jb2RlZCwgc2VjcmV0c1swXSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGVDb29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0cykge1xuICBpZiAoc2VjcmV0cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChsZXQgc2VjcmV0IG9mIHNlY3JldHMpIHtcbiAgICAgIGxldCB1bnNpZ25lZFZhbHVlID0gYXdhaXQgdW5zaWduKHZhbHVlLCBzZWNyZXQpO1xuICAgICAgaWYgKHVuc2lnbmVkVmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVEYXRhKHVuc2lnbmVkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZGVjb2RlRGF0YSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhKHZhbHVlKSB7XG4gIHJldHVybiBidG9hKG15VW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHZhbHVlKSkpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZURhdGEodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQobXlFc2NhcGUoYXRvYih2YWx1ZSkpKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5mdW5jdGlvbiBteUVzY2FwZSh2YWx1ZSkge1xuICBsZXQgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjaHIsIGNvZGU7XG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBjaHIgPSBzdHIuY2hhckF0KGluZGV4KyspO1xuICAgIGlmICgvW1xcdyorXFwtLi9AXS8uZXhlYyhjaHIpKSB7XG4gICAgICByZXN1bHQgKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICByZXN1bHQgKz0gXCIlXCIgKyBoZXgoY29kZSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gXCIldVwiICsgaGV4KGNvZGUsIDQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoZXgoY29kZSwgbGVuZ3RoKSB7XG4gIGxldCByZXN1bHQgPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBsZW5ndGgpIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbXlVbmVzY2FwZSh2YWx1ZSkge1xuICBsZXQgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjaHIsIHBhcnQ7XG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBjaHIgPSBzdHIuY2hhckF0KGluZGV4KyspO1xuICAgIGlmIChjaHIgPT09IFwiJVwiKSB7XG4gICAgICBpZiAoc3RyLmNoYXJBdChpbmRleCkgPT09IFwidVwiKSB7XG4gICAgICAgIHBhcnQgPSBzdHIuc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDUpO1xuICAgICAgICBpZiAoL15bXFxkYS1mXXs0fSQvaS5leGVjKHBhcnQpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocGFydCwgMTYpKTtcbiAgICAgICAgICBpbmRleCArPSA1O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0ID0gc3RyLnNsaWNlKGluZGV4LCBpbmRleCArIDIpO1xuICAgICAgICBpZiAoL15bXFxkYS1mXXsyfSQvaS5leGVjKHBhcnQpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQocGFydCwgMTYpKTtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCArPSBjaHI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdhcm5PbmNlQWJvdXRFeHBpcmVzQ29va2llKG5hbWUsIGV4cGlyZXMpIHtcbiAgd2Fybk9uY2UoXG4gICAgIWV4cGlyZXMsXG4gICAgYFRoZSBcIiR7bmFtZX1cIiBjb29raWUgaGFzIGFuIFwiZXhwaXJlc1wiIHByb3BlcnR5IHNldC4gVGhpcyB3aWxsIGNhdXNlIHRoZSBleHBpcmVzIHZhbHVlIHRvIG5vdCBiZSB1cGRhdGVkIHdoZW4gdGhlIHNlc3Npb24gaXMgY29tbWl0dGVkLiBJbnN0ZWFkLCB5b3Ugc2hvdWxkIHNldCB0aGUgZXhwaXJlcyB2YWx1ZSB3aGVuIHNlcmlhbGl6aW5nIHRoZSBjb29raWUuIFlvdSBjYW4gdXNlIFxcYGNvbW1pdFNlc3Npb24oc2Vzc2lvbiwgeyBleHBpcmVzIH0pXFxgIGlmIHVzaW5nIGEgc2Vzc2lvbiBzdG9yYWdlIG9iamVjdCwgb3IgXFxgY29va2llLnNlcmlhbGl6ZShcInZhbHVlXCIsIHsgZXhwaXJlcyB9KVxcYCBpZiB5b3UncmUgdXNpbmcgdGhlIGNvb2tpZSBkaXJlY3RseS5gXG4gICk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9lbnRyeS50c1xuZnVuY3Rpb24gY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMobWFuaWZlc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hbmlmZXN0KS5yZWR1Y2UoKG1lbW8sIHJvdXRlSWQpID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFtyb3V0ZUlkXTtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIG1lbW9bcm91dGVJZF0gPSByb3V0ZS5tb2R1bGU7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9tb2RlLnRzXG52YXIgU2VydmVyTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcnZlck1vZGUyKSA9PiB7XG4gIFNlcnZlck1vZGUyW1wiRGV2ZWxvcG1lbnRcIl0gPSBcImRldmVsb3BtZW50XCI7XG4gIFNlcnZlck1vZGUyW1wiUHJvZHVjdGlvblwiXSA9IFwicHJvZHVjdGlvblwiO1xuICBTZXJ2ZXJNb2RlMltcIlRlc3RcIl0gPSBcInRlc3RcIjtcbiAgcmV0dXJuIFNlcnZlck1vZGUyO1xufSkoU2VydmVyTW9kZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1NlcnZlck1vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcImRldmVsb3BtZW50XCIgLyogRGV2ZWxvcG1lbnQgKi8gfHwgdmFsdWUgPT09IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi8gfHwgdmFsdWUgPT09IFwidGVzdFwiIC8qIFRlc3QgKi87XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9lcnJvcnMudHNcbmZ1bmN0aW9uIHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgc2VydmVyTW9kZSAhPT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovKSB7XG4gICAgbGV0IHNhbml0aXplZCA9IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpO1xuICAgIHNhbml0aXplZC5zdGFjayA9IHZvaWQgMDtcbiAgICByZXR1cm4gc2FuaXRpemVkO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRXJyb3JzKGVycm9ycywgc2VydmVyTW9kZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZXJyb3JzKS5yZWR1Y2UoKGFjYywgW3JvdXRlSWQsIGVycm9yXSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbcm91dGVJZF06IHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIH0pO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcihlcnJvciwgc2VydmVyTW9kZSkge1xuICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVFcnJvcihlcnJvciwgc2VydmVyTW9kZSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogc2FuaXRpemVkLm1lc3NhZ2UsXG4gICAgc3RhY2s6IHNhbml0aXplZC5zdGFja1xuICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3JzKGVycm9ycywgc2VydmVyTW9kZSkge1xuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzKTtcbiAgbGV0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgaWYgKGlzUm91dGVFcnJvclJlc3BvbnNlKHZhbCkpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHsgLi4udmFsLCBfX3R5cGU6IFwiUm91dGVFcnJvclJlc3BvbnNlXCIgfTtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVFcnJvcih2YWwsIHNlcnZlck1vZGUpO1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiBzYW5pdGl6ZWQubWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IHNhbml0aXplZC5zdGFjayxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCIsXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWJjbGFzcyAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpLCBzZW5kIHVwIHRoZSB0eXBlIHNvIHdlXG4gICAgICAgIC8vIGNhbiByZS1jcmVhdGUgdGhlIHNhbWUgdHlwZSBkdXJpbmcgaHlkcmF0aW9uLiAgVGhpcyB3aWxsIG9ubHkgYXBwbHlcbiAgICAgICAgLy8gaW4gZGV2IG1vZGUgc2luY2UgYWxsIHByb2R1Y3Rpb24gZXJyb3JzIGFyZSBzYW5pdGl6ZWQgdG8gbm9ybWFsXG4gICAgICAgIC8vIEVycm9yIGluc3RhbmNlc1xuICAgICAgICAuLi5zYW5pdGl6ZWQubmFtZSAhPT0gXCJFcnJvclwiID8ge1xuICAgICAgICAgIF9fc3ViVHlwZTogc2FuaXRpemVkLm5hbWVcbiAgICAgICAgfSA6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvcm91dGVNYXRjaGluZy50c1xuZnVuY3Rpb24gbWF0Y2hTZXJ2ZXJSb3V0ZXMocm91dGVzLCBwYXRobmFtZSwgYmFzZW5hbWUpIHtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhcbiAgICByb3V0ZXMsXG4gICAgcGF0aG5hbWUsXG4gICAgYmFzZW5hbWVcbiAgKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKChtYXRjaCkgPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IG1hdGNoLnJvdXRlXG4gIH0pKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2RhdGEudHNcbmFzeW5jIGZ1bmN0aW9uIGNhbGxSb3V0ZUhhbmRsZXIoaGFuZGxlciwgYXJncykge1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcih7XG4gICAgcmVxdWVzdDogc3RyaXBSb3V0ZXNQYXJhbShzdHJpcEluZGV4UGFyYW0yKGFyZ3MucmVxdWVzdCkpLFxuICAgIHBhcmFtczogYXJncy5wYXJhbXMsXG4gICAgY29udGV4dDogYXJncy5jb250ZXh0XG4gIH0pO1xuICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpICYmIHJlc3VsdC5pbml0ICYmIHJlc3VsdC5pbml0LnN0YXR1cyAmJiBpc1JlZGlyZWN0U3RhdHVzQ29kZShyZXN1bHQuaW5pdC5zdGF0dXMpKSB7XG4gICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHJlc3VsdC5pbml0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtMihyZXF1ZXN0KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgbGV0IGluZGV4VmFsdWVzID0gdXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgbGV0IGluZGV4VmFsdWVzVG9LZWVwID0gW107XG4gIGZvciAobGV0IGluZGV4VmFsdWUgb2YgaW5kZXhWYWx1ZXMpIHtcbiAgICBpZiAoaW5kZXhWYWx1ZSkge1xuICAgICAgaW5kZXhWYWx1ZXNUb0tlZXAucHVzaChpbmRleFZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgdG9LZWVwIG9mIGluZGV4VmFsdWVzVG9LZWVwKSB7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB0b0tlZXApO1xuICB9XG4gIGxldCBpbml0ID0ge1xuICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsXG4gIH07XG4gIGlmIChpbml0LmJvZHkpIHtcbiAgICBpbml0LmR1cGxleCA9IFwiaGFsZlwiO1xuICB9XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgaW5pdCk7XG59XG5mdW5jdGlvbiBzdHJpcFJvdXRlc1BhcmFtKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcIl9yb3V0ZXNcIik7XG4gIGxldCBpbml0ID0ge1xuICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgYm9keTogcmVxdWVzdC5ib2R5LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsXG4gIH07XG4gIGlmIChpbml0LmJvZHkpIHtcbiAgICBpbml0LmR1cGxleCA9IFwiaGFsZlwiO1xuICB9XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgaW5pdCk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9pbnZhcmlhbnQudHNcbmZ1bmN0aW9uIGludmFyaWFudDIodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJUaGUgZm9sbG93aW5nIGVycm9yIGlzIGEgYnVnIGluIFJlYWN0IFJvdXRlcjsgcGxlYXNlIG9wZW4gYW4gaXNzdWUhIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy9uZXcvY2hvb3NlXCJcbiAgICApO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZGV2LnRzXG52YXIgZ2xvYmFsRGV2U2VydmVySG9va3NLZXkgPSBcIl9fcmVhY3RSb3V0ZXJEZXZTZXJ2ZXJIb29rc1wiO1xuZnVuY3Rpb24gc2V0RGV2U2VydmVySG9va3MoZGV2U2VydmVySG9va3MpIHtcbiAgZ2xvYmFsVGhpc1tnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleV0gPSBkZXZTZXJ2ZXJIb29rcztcbn1cbmZ1bmN0aW9uIGdldERldlNlcnZlckhvb2tzKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleV07XG59XG5mdW5jdGlvbiBnZXRCdWlsZFRpbWVIZWFkZXIocmVxdWVzdCwgaGVhZGVyTmFtZSkge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Py5JU19SUl9CVUlMRF9SRVFVRVNUID09PSBcInllc1wiKSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0LmhlYWRlcnMuZ2V0KGhlYWRlck5hbWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9yb3V0ZXMudHNcbmZ1bmN0aW9uIGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCkge1xuICBsZXQgcm91dGVzID0ge307XG4gIE9iamVjdC52YWx1ZXMobWFuaWZlc3QpLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgaWYgKHJvdXRlKSB7XG4gICAgICBsZXQgcGFyZW50SWQgPSByb3V0ZS5wYXJlbnRJZCB8fCBcIlwiO1xuICAgICAgaWYgKCFyb3V0ZXNbcGFyZW50SWRdKSB7XG4gICAgICAgIHJvdXRlc1twYXJlbnRJZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvdXRlc1twYXJlbnRJZF0ucHVzaChyb3V0ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgcGFyZW50SWQgPSBcIlwiLCByb3V0ZXNCeVBhcmVudElkID0gZ3JvdXBSb3V0ZXNCeVBhcmVudElkKG1hbmlmZXN0KSkge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiAoe1xuICAgIC4uLnJvdXRlLFxuICAgIGNoaWxkcmVuOiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIHJvdXRlLmlkLCByb3V0ZXNCeVBhcmVudElkKVxuICB9KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyhtYW5pZmVzdCwgZnV0dXJlLCBwYXJlbnRJZCA9IFwiXCIsIHJvdXRlc0J5UGFyZW50SWQgPSBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgY29tbW9uUm91dGUgPSB7XG4gICAgICAvLyBBbHdheXMgaW5jbHVkZSByb290IGR1ZSB0byBkZWZhdWx0IGJvdW5kYXJpZXNcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLmlkID09PSBcInJvb3RcIiB8fCByb3V0ZS5tb2R1bGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsLFxuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIG1pZGRsZXdhcmU6IHJvdXRlLm1vZHVsZS5taWRkbGV3YXJlLFxuICAgICAgLy8gTmVlZCB0byB1c2UgUlIncyB2ZXJzaW9uIGluIHRoZSBwYXJhbSB0eXBlZCBoZXJlIHRvIHBlcm1pdCB0aGUgb3B0aW9uYWxcbiAgICAgIC8vIGNvbnRleHQgZXZlbiB0aG91Z2ggd2Uga25vdyBpdCdsbCBhbHdheXMgYmUgcHJvdmlkZWQgaW4gcmVtaXhcbiAgICAgIGxvYWRlcjogcm91dGUubW9kdWxlLmxvYWRlciA/IGFzeW5jIChhcmdzKSA9PiB7XG4gICAgICAgIGxldCBwcmVSZW5kZXJlZERhdGEgPSBnZXRCdWlsZFRpbWVIZWFkZXIoXG4gICAgICAgICAgYXJncy5yZXF1ZXN0LFxuICAgICAgICAgIFwiWC1SZWFjdC1Sb3V0ZXItUHJlcmVuZGVyLURhdGFcIlxuICAgICAgICApO1xuICAgICAgICBpZiAocHJlUmVuZGVyZWREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgZW5jb2RlZCA9IHByZVJlbmRlcmVkRGF0YSA/IGRlY29kZVVSSShwcmVSZW5kZXJlZERhdGEpIDogcHJlUmVuZGVyZWREYXRhO1xuICAgICAgICAgIGludmFyaWFudDIoZW5jb2RlZCwgXCJNaXNzaW5nIHByZXJlbmRlcmVkIGRhdGEgZm9yIHJvdXRlXCIpO1xuICAgICAgICAgIGxldCB1aW50OGFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGVuY29kZWQpO1xuICAgICAgICAgIGxldCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodWludDhhcnJheSk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgZGVjb2RlZCA9IGF3YWl0IGRlY29kZVZpYVR1cmJvU3RyZWFtKHN0cmVhbSwgZ2xvYmFsKTtcbiAgICAgICAgICBsZXQgZGF0YTIgPSBkZWNvZGVkLnZhbHVlO1xuICAgICAgICAgIGlmIChkYXRhMiAmJiBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIGRhdGEyKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZGF0YTJbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF07XG4gICAgICAgICAgICBsZXQgaW5pdCA9IHsgc3RhdHVzOiByZXN1bHQuc3RhdHVzIH07XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlbG9hZCkge1xuICAgICAgICAgICAgICB0aHJvdyByZWRpcmVjdERvY3VtZW50KHJlc3VsdC5yZWRpcmVjdCwgaW5pdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5yZXBsYWNlKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcGxhY2UocmVzdWx0LnJlZGlyZWN0LCBpbml0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IHJlZGlyZWN0KHJlc3VsdC5yZWRpcmVjdCwgaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludmFyaWFudDIoXG4gICAgICAgICAgICAgIGRhdGEyICYmIHJvdXRlLmlkIGluIGRhdGEyLFxuICAgICAgICAgICAgICBcIlVuYWJsZSB0byBkZWNvZGUgcHJlcmVuZGVyZWQgZGF0YVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGRhdGEyW3JvdXRlLmlkXTtcbiAgICAgICAgICAgIGludmFyaWFudDIoXG4gICAgICAgICAgICAgIFwiZGF0YVwiIGluIHJlc3VsdCxcbiAgICAgICAgICAgICAgXCJVbmFibGUgdG8gcHJvY2VzcyBwcmVyZW5kZXJlZCBkYXRhXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB2YWwgPSBhd2FpdCBjYWxsUm91dGVIYW5kbGVyKHJvdXRlLm1vZHVsZS5sb2FkZXIsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSA6IHZvaWQgMCxcbiAgICAgIGFjdGlvbjogcm91dGUubW9kdWxlLmFjdGlvbiA/IChhcmdzKSA9PiBjYWxsUm91dGVIYW5kbGVyKHJvdXRlLm1vZHVsZS5hY3Rpb24sIGFyZ3MpIDogdm9pZCAwLFxuICAgICAgaGFuZGxlOiByb3V0ZS5tb2R1bGUuaGFuZGxlXG4gICAgfTtcbiAgICByZXR1cm4gcm91dGUuaW5kZXggPyB7XG4gICAgICBpbmRleDogdHJ1ZSxcbiAgICAgIC4uLmNvbW1vblJvdXRlXG4gICAgfSA6IHtcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUsXG4gICAgICBjaGlsZHJlbjogY3JlYXRlU3RhdGljSGFuZGxlckRhdGFSb3V0ZXMoXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBmdXR1cmUsXG4gICAgICAgIHJvdXRlLmlkLFxuICAgICAgICByb3V0ZXNCeVBhcmVudElkXG4gICAgICApLFxuICAgICAgLi4uY29tbW9uUm91dGVcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NlcnZlckhhbmRvZmYudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoc2VydmVySGFuZG9mZikge1xuICByZXR1cm4gZXNjYXBlSHRtbChKU09OLnN0cmluZ2lmeShzZXJ2ZXJIYW5kb2ZmKSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9oZWFkZXJzLnRzXG5pbXBvcnQgeyBzcGxpdENvb2tpZXNTdHJpbmcgfSBmcm9tIFwic2V0LWNvb2tpZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGdldERvY3VtZW50SGVhZGVycyhjb250ZXh0LCBidWlsZCkge1xuICByZXR1cm4gZ2V0RG9jdW1lbnRIZWFkZXJzSW1wbChjb250ZXh0LCAobSkgPT4ge1xuICAgIGxldCByb3V0ZSA9IGJ1aWxkLnJvdXRlc1ttLnJvdXRlLmlkXTtcbiAgICBpbnZhcmlhbnQyKHJvdXRlLCBgUm91dGUgd2l0aCBpZCBcIiR7bS5yb3V0ZS5pZH1cIiBub3QgZm91bmQgaW4gYnVpbGRgKTtcbiAgICByZXR1cm4gcm91dGUubW9kdWxlLmhlYWRlcnM7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRIZWFkZXJzSW1wbChjb250ZXh0LCBnZXRSb3V0ZUhlYWRlcnNGbiwgX2RlZmF1bHRIZWFkZXJzKSB7XG4gIGxldCBib3VuZGFyeUlkeCA9IGNvbnRleHQuZXJyb3JzID8gY29udGV4dC5tYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gY29udGV4dC5lcnJvcnNbbS5yb3V0ZS5pZF0pIDogLTE7XG4gIGxldCBtYXRjaGVzID0gYm91bmRhcnlJZHggPj0gMCA/IGNvbnRleHQubWF0Y2hlcy5zbGljZSgwLCBib3VuZGFyeUlkeCArIDEpIDogY29udGV4dC5tYXRjaGVzO1xuICBsZXQgZXJyb3JIZWFkZXJzO1xuICBpZiAoYm91bmRhcnlJZHggPj0gMCkge1xuICAgIGxldCB7IGFjdGlvbkhlYWRlcnMsIGFjdGlvbkRhdGEsIGxvYWRlckhlYWRlcnMsIGxvYWRlckRhdGEgfSA9IGNvbnRleHQ7XG4gICAgY29udGV4dC5tYXRjaGVzLnNsaWNlKGJvdW5kYXJ5SWR4KS5zb21lKChtYXRjaCkgPT4ge1xuICAgICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgICBpZiAoYWN0aW9uSGVhZGVyc1tpZF0gJiYgKCFhY3Rpb25EYXRhIHx8ICFhY3Rpb25EYXRhLmhhc093blByb3BlcnR5KGlkKSkpIHtcbiAgICAgICAgZXJyb3JIZWFkZXJzID0gYWN0aW9uSGVhZGVyc1tpZF07XG4gICAgICB9IGVsc2UgaWYgKGxvYWRlckhlYWRlcnNbaWRdICYmICFsb2FkZXJEYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBlcnJvckhlYWRlcnMgPSBsb2FkZXJIZWFkZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvckhlYWRlcnMgIT0gbnVsbDtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBkZWZhdWx0SGVhZGVycyA9IG5ldyBIZWFkZXJzKF9kZWZhdWx0SGVhZGVycyk7XG4gIHJldHVybiBtYXRjaGVzLnJlZHVjZSgocGFyZW50SGVhZGVycywgbWF0Y2gsIGlkeCkgPT4ge1xuICAgIGxldCB7IGlkIH0gPSBtYXRjaC5yb3V0ZTtcbiAgICBsZXQgbG9hZGVySGVhZGVycyA9IGNvbnRleHQubG9hZGVySGVhZGVyc1tpZF0gfHwgbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgYWN0aW9uSGVhZGVycyA9IGNvbnRleHQuYWN0aW9uSGVhZGVyc1tpZF0gfHwgbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgaW5jbHVkZUVycm9ySGVhZGVycyA9IGVycm9ySGVhZGVycyAhPSBudWxsICYmIGlkeCA9PT0gbWF0Y2hlcy5sZW5ndGggLSAxO1xuICAgIGxldCBpbmNsdWRlRXJyb3JDb29raWVzID0gaW5jbHVkZUVycm9ySGVhZGVycyAmJiBlcnJvckhlYWRlcnMgIT09IGxvYWRlckhlYWRlcnMgJiYgZXJyb3JIZWFkZXJzICE9PSBhY3Rpb25IZWFkZXJzO1xuICAgIGxldCBoZWFkZXJzRm4gPSBnZXRSb3V0ZUhlYWRlcnNGbihtYXRjaCk7XG4gICAgaWYgKGhlYWRlcnNGbiA9PSBudWxsKSB7XG4gICAgICBsZXQgaGVhZGVyczIgPSBuZXcgSGVhZGVycyhwYXJlbnRIZWFkZXJzKTtcbiAgICAgIGlmIChpbmNsdWRlRXJyb3JDb29raWVzKSB7XG4gICAgICAgIHByZXBlbmRDb29raWVzKGVycm9ySGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgfVxuICAgICAgcHJlcGVuZENvb2tpZXMoYWN0aW9uSGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgcHJlcGVuZENvb2tpZXMobG9hZGVySGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgcmV0dXJuIGhlYWRlcnMyO1xuICAgIH1cbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKFxuICAgICAgdHlwZW9mIGhlYWRlcnNGbiA9PT0gXCJmdW5jdGlvblwiID8gaGVhZGVyc0ZuKHtcbiAgICAgICAgbG9hZGVySGVhZGVycyxcbiAgICAgICAgcGFyZW50SGVhZGVycyxcbiAgICAgICAgYWN0aW9uSGVhZGVycyxcbiAgICAgICAgZXJyb3JIZWFkZXJzOiBpbmNsdWRlRXJyb3JIZWFkZXJzID8gZXJyb3JIZWFkZXJzIDogdm9pZCAwXG4gICAgICB9KSA6IGhlYWRlcnNGblxuICAgICk7XG4gICAgaWYgKGluY2x1ZGVFcnJvckNvb2tpZXMpIHtcbiAgICAgIHByZXBlbmRDb29raWVzKGVycm9ySGVhZGVycywgaGVhZGVycyk7XG4gICAgfVxuICAgIHByZXBlbmRDb29raWVzKGFjdGlvbkhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHByZXBlbmRDb29raWVzKGxvYWRlckhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHByZXBlbmRDb29raWVzKHBhcmVudEhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LCBuZXcgSGVhZGVycyhkZWZhdWx0SGVhZGVycykpO1xufVxuZnVuY3Rpb24gcHJlcGVuZENvb2tpZXMocGFyZW50SGVhZGVycywgY2hpbGRIZWFkZXJzKSB7XG4gIGxldCBwYXJlbnRTZXRDb29raWVTdHJpbmcgPSBwYXJlbnRIZWFkZXJzLmdldChcIlNldC1Db29raWVcIik7XG4gIGlmIChwYXJlbnRTZXRDb29raWVTdHJpbmcpIHtcbiAgICBsZXQgY29va2llcyA9IHNwbGl0Q29va2llc1N0cmluZyhwYXJlbnRTZXRDb29raWVTdHJpbmcpO1xuICAgIGxldCBjaGlsZENvb2tpZXMgPSBuZXcgU2V0KGNoaWxkSGVhZGVycy5nZXRTZXRDb29raWUoKSk7XG4gICAgY29va2llcy5mb3JFYWNoKChjb29raWUpID0+IHtcbiAgICAgIGlmICghY2hpbGRDb29raWVzLmhhcyhjb29raWUpKSB7XG4gICAgICAgIGNoaWxkSGVhZGVycy5hcHBlbmQoXCJTZXQtQ29va2llXCIsIGNvb2tpZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NpbmdsZS1mZXRjaC50c1xudmFyIFNFUlZFUl9OT19CT0RZX1NUQVRVU19DT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgLi4uTk9fQk9EWV9TVEFUVVNfQ09ERVMsXG4gIDMwNFxuXSk7XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaEFjdGlvbihidWlsZCwgc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaGFuZGxlclVybCwge1xuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG4gICAgICAuLi5yZXF1ZXN0LmJvZHkgPyB7IGR1cGxleDogXCJoYWxmXCIgfSA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KGhhbmRsZXJSZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZzogdHJ1ZSxcbiAgICAgIHNraXBSZXZhbGlkYXRpb246IHRydWUsXG4gICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVSZXNwb25zZTogYnVpbGQuZnV0dXJlLnY4X21pZGRsZXdhcmUgPyBhc3luYyAocXVlcnkpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgaW5uZXJSZXN1bHQgPSBhd2FpdCBxdWVyeShoYW5kbGVyUmVxdWVzdCk7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVF1ZXJ5UmVzdWx0KGlubmVyUmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUXVlcnlFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gaGFuZGxlUXVlcnlSZXN1bHQocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gaGFuZGxlUXVlcnlFcnJvcihlcnJvcik7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUXVlcnlSZXN1bHQocmVzdWx0KSB7XG4gICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IHN0YXRpY0NvbnRleHRUb1Jlc3BvbnNlKHJlc3VsdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUXVlcnlFcnJvcihlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gICAgICByZXN1bHQ6IHsgZXJyb3IgfSxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCksXG4gICAgICBzdGF0dXM6IDUwMFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXRpY0NvbnRleHRUb1Jlc3BvbnNlKGNvbnRleHQpIHtcbiAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhjb250ZXh0LCBidWlsZCk7XG4gICAgaWYgKGlzUmVkaXJlY3RTdGF0dXNDb2RlKGNvbnRleHQuc3RhdHVzQ29kZSkgJiYgaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogY29udGV4dC5zdGF0dXNDb2RlLCBoZWFkZXJzIH0pO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICBpZiAoIWlzUm91dGVFcnJvclJlc3BvbnNlKGVycikgfHwgZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgbGV0IHNpbmdsZUZldGNoUmVzdWx0O1xuICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgc2luZ2xlRmV0Y2hSZXN1bHQgPSB7IGVycm9yOiBPYmplY3QudmFsdWVzKGNvbnRleHQuZXJyb3JzKVswXSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzaW5nbGVGZXRjaFJlc3VsdCA9IHtcbiAgICAgICAgZGF0YTogT2JqZWN0LnZhbHVlcyhjb250ZXh0LmFjdGlvbkRhdGEgfHwge30pWzBdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gICAgICByZXN1bHQ6IHNpbmdsZUZldGNoUmVzdWx0LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHN0YXR1czogY29udGV4dC5zdGF0dXNDb2RlXG4gICAgfSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVycyhidWlsZCwgc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIGxldCByb3V0ZXNQYXJhbSA9IG5ldyBVUkwocmVxdWVzdC51cmwpLnNlYXJjaFBhcmFtcy5nZXQoXCJfcm91dGVzXCIpO1xuICBsZXQgbG9hZFJvdXRlSWRzID0gcm91dGVzUGFyYW0gPyBuZXcgU2V0KHJvdXRlc1BhcmFtLnNwbGl0KFwiLFwiKSkgOiBudWxsO1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGhhbmRsZXJVcmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeShoYW5kbGVyUmVxdWVzdCwge1xuICAgICAgcmVxdWVzdENvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZDogKG0pID0+ICFsb2FkUm91dGVJZHMgfHwgbG9hZFJvdXRlSWRzLmhhcyhtLnJvdXRlLmlkKSxcbiAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlUmVzcG9uc2U6IGJ1aWxkLmZ1dHVyZS52OF9taWRkbGV3YXJlID8gYXN5bmMgKHF1ZXJ5KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGlubmVyUmVzdWx0ID0gYXdhaXQgcXVlcnkoaGFuZGxlclJlcXVlc3QpO1xuICAgICAgICAgIHJldHVybiBoYW5kbGVRdWVyeVJlc3VsdChpbm5lclJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVF1ZXJ5RXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIGhhbmRsZVF1ZXJ5UmVzdWx0KHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGhhbmRsZVF1ZXJ5RXJyb3IoZXJyb3IpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVF1ZXJ5UmVzdWx0KHJlc3VsdCkge1xuICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiBzdGF0aWNDb250ZXh0VG9SZXNwb25zZShyZXN1bHQpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVF1ZXJ5RXJyb3IoZXJyb3IpIHtcbiAgICBoYW5kbGVFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGdlbmVyYXRlU2luZ2xlRmV0Y2hSZXNwb25zZShyZXF1ZXN0LCBidWlsZCwgc2VydmVyTW9kZSwge1xuICAgICAgcmVzdWx0OiB7IGVycm9yIH0sXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgICAgc3RhdHVzOiA1MDBcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdGF0aWNDb250ZXh0VG9SZXNwb25zZShjb250ZXh0KSB7XG4gICAgbGV0IGhlYWRlcnMgPSBnZXREb2N1bWVudEhlYWRlcnMoY29udGV4dCwgYnVpbGQpO1xuICAgIGlmIChpc1JlZGlyZWN0U3RhdHVzQ29kZShjb250ZXh0LnN0YXR1c0NvZGUpICYmIGhlYWRlcnMuaGFzKFwiTG9jYXRpb25cIikpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IGNvbnRleHQuc3RhdHVzQ29kZSwgaGVhZGVycyB9KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICBPYmplY3QudmFsdWVzKGNvbnRleHQuZXJyb3JzKS5mb3JFYWNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKCFpc1JvdXRlRXJyb3JSZXNwb25zZShlcnIpIHx8IGVyci5lcnJvcikge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgfVxuICAgIGxldCByZXN1bHRzID0ge307XG4gICAgbGV0IGxvYWRlZE1hdGNoZXMgPSBuZXcgU2V0KFxuICAgICAgY29udGV4dC5tYXRjaGVzLmZpbHRlcihcbiAgICAgICAgKG0pID0+IGxvYWRSb3V0ZUlkcyA/IGxvYWRSb3V0ZUlkcy5oYXMobS5yb3V0ZS5pZCkgOiBtLnJvdXRlLmxvYWRlciAhPSBudWxsXG4gICAgICApLm1hcCgobSkgPT4gbS5yb3V0ZS5pZClcbiAgICApO1xuICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgZm9yIChsZXQgW2lkLCBlcnJvcl0gb2YgT2JqZWN0LmVudHJpZXMoY29udGV4dC5lcnJvcnMpKSB7XG4gICAgICAgIHJlc3VsdHNbaWRdID0geyBlcnJvciB9O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBbaWQsIGRhdGEyXSBvZiBPYmplY3QuZW50cmllcyhjb250ZXh0LmxvYWRlckRhdGEpKSB7XG4gICAgICBpZiAoIShpZCBpbiByZXN1bHRzKSAmJiBsb2FkZWRNYXRjaGVzLmhhcyhpZCkpIHtcbiAgICAgICAgcmVzdWx0c1tpZF0gPSB7IGRhdGE6IGRhdGEyIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzdGF0dXM6IGNvbnRleHQuc3RhdHVzQ29kZVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgcmVzdWx0LFxuICBoZWFkZXJzLFxuICBzdGF0dXNcbn0pIHtcbiAgbGV0IHJlc3VsdEhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcbiAgcmVzdWx0SGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlc3BvbnNlXCIsIFwieWVzXCIpO1xuICBpZiAoU0VSVkVSX05PX0JPRFlfU1RBVFVTX0NPREVTLmhhcyhzdGF0dXMpKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1cywgaGVhZGVyczogcmVzdWx0SGVhZGVycyB9KTtcbiAgfVxuICByZXN1bHRIZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQveC1zY3JpcHRcIik7XG4gIHJlc3VsdEhlYWRlcnMuZGVsZXRlKFwiQ29udGVudC1MZW5ndGhcIik7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgZW5jb2RlVmlhVHVyYm9TdHJlYW0oXG4gICAgICByZXN1bHQsXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgc2VydmVyTW9kZVxuICAgICksXG4gICAge1xuICAgICAgc3RhdHVzOiBzdGF0dXMgfHwgMjAwLFxuICAgICAgaGVhZGVyczogcmVzdWx0SGVhZGVyc1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2luZ2xlRmV0Y2hSZWRpcmVjdFJlc3BvbnNlKHJlZGlyZWN0UmVzcG9uc2UsIHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlKSB7XG4gIGxldCByZWRpcmVjdDIgPSBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgIHJlZGlyZWN0UmVzcG9uc2Uuc3RhdHVzLFxuICAgIHJlZGlyZWN0UmVzcG9uc2UuaGVhZGVycyxcbiAgICBidWlsZC5iYXNlbmFtZVxuICApO1xuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlZGlyZWN0UmVzcG9uc2UuaGVhZGVycyk7XG4gIGhlYWRlcnMuZGVsZXRlKFwiTG9jYXRpb25cIik7XG4gIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC94LXNjcmlwdFwiKTtcbiAgcmV0dXJuIGdlbmVyYXRlU2luZ2xlRmV0Y2hSZXNwb25zZShyZXF1ZXN0LCBidWlsZCwgc2VydmVyTW9kZSwge1xuICAgIHJlc3VsdDogcmVxdWVzdC5tZXRob2QgPT09IFwiR0VUXCIgPyB7IFtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTogcmVkaXJlY3QyIH0gOiByZWRpcmVjdDIsXG4gICAgaGVhZGVycyxcbiAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVNcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KHN0YXR1cywgaGVhZGVycywgYmFzZW5hbWUpIHtcbiAgbGV0IHJlZGlyZWN0MiA9IGhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGlmIChiYXNlbmFtZSkge1xuICAgIHJlZGlyZWN0MiA9IHN0cmlwQmFzZW5hbWUocmVkaXJlY3QyLCBiYXNlbmFtZSkgfHwgcmVkaXJlY3QyO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVkaXJlY3Q6IHJlZGlyZWN0MixcbiAgICBzdGF0dXMsXG4gICAgcmV2YWxpZGF0ZTogKFxuICAgICAgLy8gVGVjaG5pY2FsbHkgWC1SZW1peC1SZXZhbGlkYXRlIGlzbid0IG5lZWRlZCBoZXJlIC0gdGhhdCB3YXMgYW4gaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGRldGFpbCBvZiA/X2RhdGEgcmVxdWVzdHMgYXMgb3VyIHdheSB0byB0ZWxsIHRoZSBmcm9udCBlbmQgdG8gcmV2YWxpZGF0ZSB3aGVuXG4gICAgICAvLyB3ZSBkaWRuJ3QgaGF2ZSBhIHJlc3BvbnNlIGJvZHkgdG8gaW5jbHVkZSB0aGF0IGluZm9ybWF0aW9uIGluLlxuICAgICAgLy8gV2l0aCBzaW5nbGUgZmV0Y2gsIHdlIHRlbGwgdGhlIGZyb250IGVuZCB2aWEgdGhpcyByZXZhbGlkYXRlIGJvb2xlYW4gZmllbGQuXG4gICAgICAvLyBIb3dldmVyLCB3ZSdyZSByZXNwZWN0aW5nIGl0IGZvciBub3cgYmVjYXVzZSBpdCBtYXkgYmUgc29tZXRoaW5nIGZvbGtzIGhhdmVcbiAgICAgIC8vIHVzZWQgaW4gdGhlaXIgb3duIHJlc3BvbnNlc1xuICAgICAgLy8gVE9ETyh2Myk6IENvbnNpZGVyIHJlbW92aW5nIG9yIG1ha2luZyB0aGlzIG9mZmljaWFsIHB1YmxpYyBBUElcbiAgICAgIGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpIHx8IGhlYWRlcnMuaGFzKFwiU2V0LUNvb2tpZVwiKVxuICAgICksXG4gICAgcmVsb2FkOiBoZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpLFxuICAgIHJlcGxhY2U6IGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXBsYWNlXCIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNvZGVWaWFUdXJib1N0cmVhbShkYXRhMiwgcmVxdWVzdFNpZ25hbCwgc3RyZWFtVGltZW91dCwgc2VydmVyTW9kZSkge1xuICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgbGV0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXG4gICAgKCkgPT4gY29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoXCJTZXJ2ZXIgVGltZW91dFwiKSksXG4gICAgdHlwZW9mIHN0cmVhbVRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyBzdHJlYW1UaW1lb3V0IDogNDk1MFxuICApO1xuICByZXF1ZXN0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKSk7XG4gIHJldHVybiBlbmNvZGUoZGF0YTIsIHtcbiAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgIHBsdWdpbnM6IFtcbiAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGxldCB7IG5hbWUsIG1lc3NhZ2UsIHN0YWNrIH0gPSBzZXJ2ZXJNb2RlID09PSBcInByb2R1Y3Rpb25cIiAvKiBQcm9kdWN0aW9uICovID8gc2FuaXRpemVFcnJvcih2YWx1ZSwgc2VydmVyTW9kZSkgOiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gW1wiU2FuaXRpemVkRXJyb3JcIiwgbmFtZSwgbWVzc2FnZSwgc3RhY2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yUmVzcG9uc2VJbXBsKSB7XG4gICAgICAgICAgbGV0IHsgZGF0YTogZGF0YTMsIHN0YXR1cywgc3RhdHVzVGV4dCB9ID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIFtcIkVycm9yUmVzcG9uc2VcIiwgZGF0YTMsIHN0YXR1cywgc3RhdHVzVGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIlNpbmdsZUZldGNoUmVkaXJlY3RcIiwgdmFsdWVbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXSxcbiAgICBwb3N0UGx1Z2luczogW1xuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiU2luZ2xlRmV0Y2hDbGFzc0luc3RhbmNlXCIsXG4gICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBbXCJTaW5nbGVGZXRjaEZhbGxiYWNrXCJdXG4gICAgXVxuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NlcnZlci50c1xuZnVuY3Rpb24gZGVyaXZlKGJ1aWxkLCBtb2RlKSB7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyhidWlsZC5yb3V0ZXMsIGJ1aWxkLmZ1dHVyZSk7XG4gIGxldCBzZXJ2ZXJNb2RlID0gaXNTZXJ2ZXJNb2RlKG1vZGUpID8gbW9kZSA6IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi87XG4gIGxldCBzdGF0aWNIYW5kbGVyID0gY3JlYXRlU3RhdGljSGFuZGxlcihkYXRhUm91dGVzLCB7XG4gICAgYmFzZW5hbWU6IGJ1aWxkLmJhc2VuYW1lXG4gIH0pO1xuICBsZXQgZXJyb3JIYW5kbGVyID0gYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZUVycm9yIHx8ICgoZXJyb3IsIHsgcmVxdWVzdCB9KSA9PiB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFwidGVzdFwiIC8qIFRlc3QgKi8gJiYgIXJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICAgIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSAmJiBlcnJvci5lcnJvciA/IGVycm9yLmVycm9yIDogZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByb3V0ZXMsXG4gICAgZGF0YVJvdXRlcyxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgZXJyb3JIYW5kbGVyXG4gIH07XG59XG52YXIgY3JlYXRlUmVxdWVzdEhhbmRsZXIgPSAoYnVpbGQsIG1vZGUpID0+IHtcbiAgbGV0IF9idWlsZDtcbiAgbGV0IHJvdXRlcztcbiAgbGV0IHNlcnZlck1vZGU7XG4gIGxldCBzdGF0aWNIYW5kbGVyO1xuICBsZXQgZXJyb3JIYW5kbGVyO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEhhbmRsZXIocmVxdWVzdCwgaW5pdGlhbENvbnRleHQpIHtcbiAgICBfYnVpbGQgPSB0eXBlb2YgYnVpbGQgPT09IFwiZnVuY3Rpb25cIiA/IGF3YWl0IGJ1aWxkKCkgOiBidWlsZDtcbiAgICBpZiAodHlwZW9mIGJ1aWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxldCBkZXJpdmVkID0gZGVyaXZlKF9idWlsZCwgbW9kZSk7XG4gICAgICByb3V0ZXMgPSBkZXJpdmVkLnJvdXRlcztcbiAgICAgIHNlcnZlck1vZGUgPSBkZXJpdmVkLnNlcnZlck1vZGU7XG4gICAgICBzdGF0aWNIYW5kbGVyID0gZGVyaXZlZC5zdGF0aWNIYW5kbGVyO1xuICAgICAgZXJyb3JIYW5kbGVyID0gZGVyaXZlZC5lcnJvckhhbmRsZXI7XG4gICAgfSBlbHNlIGlmICghcm91dGVzIHx8ICFzZXJ2ZXJNb2RlIHx8ICFzdGF0aWNIYW5kbGVyIHx8ICFlcnJvckhhbmRsZXIpIHtcbiAgICAgIGxldCBkZXJpdmVkID0gZGVyaXZlKF9idWlsZCwgbW9kZSk7XG4gICAgICByb3V0ZXMgPSBkZXJpdmVkLnJvdXRlcztcbiAgICAgIHNlcnZlck1vZGUgPSBkZXJpdmVkLnNlcnZlck1vZGU7XG4gICAgICBzdGF0aWNIYW5kbGVyID0gZGVyaXZlZC5zdGF0aWNIYW5kbGVyO1xuICAgICAgZXJyb3JIYW5kbGVyID0gZGVyaXZlZC5lcnJvckhhbmRsZXI7XG4gICAgfVxuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBsZXQgbG9hZENvbnRleHQ7XG4gICAgbGV0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBpZiAobW9kZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovKSB7XG4gICAgICAgIGdldERldlNlcnZlckhvb2tzKCk/LnByb2Nlc3NSZXF1ZXN0RXJyb3I/LihlcnJvcik7XG4gICAgICB9XG4gICAgICBlcnJvckhhbmRsZXIoZXJyb3IsIHtcbiAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoX2J1aWxkLmZ1dHVyZS52OF9taWRkbGV3YXJlKSB7XG4gICAgICBpZiAoaW5pdGlhbENvbnRleHQgJiYgIShpbml0aWFsQ29udGV4dCBpbnN0YW5jZW9mIFJvdXRlckNvbnRleHRQcm92aWRlcikpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBgY29udGV4dGAgdmFsdWUgcHJvdmlkZWQgdG8gYGhhbmRsZVJlcXVlc3RgLiBXaGVuIG1pZGRsZXdhcmUgaXMgZW5hYmxlZCB5b3UgbXVzdCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgYFJvdXRlckNvbnRleHRQcm92aWRlcmAgZnJvbSB5b3VyIGBnZXRMb2FkQ29udGV4dGAgZnVuY3Rpb24uXCJcbiAgICAgICAgKTtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gcmV0dXJuTGFzdFJlc29ydEVycm9yUmVzcG9uc2UoZXJyb3IsIHNlcnZlck1vZGUpO1xuICAgICAgfVxuICAgICAgbG9hZENvbnRleHQgPSBpbml0aWFsQ29udGV4dCB8fCBuZXcgUm91dGVyQ29udGV4dFByb3ZpZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRDb250ZXh0ID0gaW5pdGlhbENvbnRleHQgfHwge307XG4gICAgfVxuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbm9ybWFsaXplZEJhc2VuYW1lID0gX2J1aWxkLmJhc2VuYW1lIHx8IFwiL1wiO1xuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IHVybC5wYXRobmFtZTtcbiAgICBpZiAoc3RyaXBCYXNlbmFtZShub3JtYWxpemVkUGF0aCwgbm9ybWFsaXplZEJhc2VuYW1lKSA9PT0gXCIvX3Jvb3QuZGF0YVwiKSB7XG4gICAgICBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZWRCYXNlbmFtZTtcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRQYXRoLmVuZHNXaXRoKFwiLmRhdGFcIikpIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplZFBhdGgucmVwbGFjZSgvXFwuZGF0YSQvLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKHN0cmlwQmFzZW5hbWUobm9ybWFsaXplZFBhdGgsIG5vcm1hbGl6ZWRCYXNlbmFtZSkgIT09IFwiL1wiICYmIG5vcm1hbGl6ZWRQYXRoLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVkUGF0aC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIGxldCBpc1NwYU1vZGUgPSBnZXRCdWlsZFRpbWVIZWFkZXIocmVxdWVzdCwgXCJYLVJlYWN0LVJvdXRlci1TUEEtTW9kZVwiKSA9PT0gXCJ5ZXNcIjtcbiAgICBpZiAoIV9idWlsZC5zc3IpIHtcbiAgICAgIGxldCBkZWNvZGVkUGF0aCA9IGRlY29kZVVSSShub3JtYWxpemVkUGF0aCk7XG4gICAgICBpZiAobm9ybWFsaXplZEJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBsZXQgc3RyaXBwZWRQYXRoID0gc3RyaXBCYXNlbmFtZShkZWNvZGVkUGF0aCwgbm9ybWFsaXplZEJhc2VuYW1lKTtcbiAgICAgICAgaWYgKHN0cmlwcGVkUGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgZXJyb3JIYW5kbGVyKFxuICAgICAgICAgICAgbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICAgICAgICA0MDQsXG4gICAgICAgICAgICAgIFwiTm90IEZvdW5kXCIsXG4gICAgICAgICAgICAgIGBSZWZ1c2luZyB0byBwcmVyZW5kZXIgdGhlIFxcYCR7ZGVjb2RlZFBhdGh9XFxgIHBhdGggYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBiYXNlbmFtZSBcXGAke25vcm1hbGl6ZWRCYXNlbmFtZX1cXGBgXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiTm90IEZvdW5kXCIsIHtcbiAgICAgICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRQYXRoID0gc3RyaXBwZWRQYXRoO1xuICAgICAgfVxuICAgICAgaWYgKF9idWlsZC5wcmVyZW5kZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlzU3BhTW9kZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFfYnVpbGQucHJlcmVuZGVyLmluY2x1ZGVzKGRlY29kZWRQYXRoKSAmJiAhX2J1aWxkLnByZXJlbmRlci5pbmNsdWRlcyhkZWNvZGVkUGF0aCArIFwiL1wiKSkge1xuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmRhdGFcIikpIHtcbiAgICAgICAgICBlcnJvckhhbmRsZXIoXG4gICAgICAgICAgICBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgICAgIDQwNCxcbiAgICAgICAgICAgICAgXCJOb3QgRm91bmRcIixcbiAgICAgICAgICAgICAgYFJlZnVzaW5nIHRvIFNTUiB0aGUgcGF0aCBcXGAke2RlY29kZWRQYXRofVxcYCBiZWNhdXNlIFxcYHNzcjpmYWxzZVxcYCBpcyBzZXQgYW5kIHRoZSBwYXRoIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgXFxgcHJlcmVuZGVyXFxgIGNvbmZpZywgc28gaW4gcHJvZHVjdGlvbiB0aGUgcGF0aCB3aWxsIGJlIGEgNDA0LmBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJOb3QgRm91bmRcIiwge1xuICAgICAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNTcGFNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWFuaWZlc3RVcmwgPSBnZXRNYW5pZmVzdFBhdGgoXG4gICAgICBfYnVpbGQucm91dGVEaXNjb3ZlcnkubWFuaWZlc3RQYXRoLFxuICAgICAgbm9ybWFsaXplZEJhc2VuYW1lXG4gICAgKTtcbiAgICBpZiAodXJsLnBhdGhuYW1lID09PSBtYW5pZmVzdFVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGhhbmRsZU1hbmlmZXN0UmVxdWVzdChfYnVpbGQsIHJvdXRlcywgdXJsKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJVbmtub3duIFNlcnZlciBFcnJvclwiLCB7IHN0YXR1czogNTAwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgbm9ybWFsaXplZFBhdGgsIF9idWlsZC5iYXNlbmFtZSk7XG4gICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgbWF0Y2hlc1swXS5wYXJhbXMpO1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgaWYgKHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5kYXRhXCIpKSB7XG4gICAgICBsZXQgaGFuZGxlclVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgaGFuZGxlclVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZWRQYXRoO1xuICAgICAgbGV0IHNpbmdsZUZldGNoTWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKFxuICAgICAgICByb3V0ZXMsXG4gICAgICAgIGhhbmRsZXJVcmwucGF0aG5hbWUsXG4gICAgICAgIF9idWlsZC5iYXNlbmFtZVxuICAgICAgKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlU2luZ2xlRmV0Y2hSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBfYnVpbGQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGhhbmRsZXJVcmwsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBoYW5kbGVFcnJvclxuICAgICAgKTtcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlZGlyZWN0UmVzcG9uc2UoXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBfYnVpbGQsXG4gICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKF9idWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRGF0YVJlcXVlc3QpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBfYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZURhdGFSZXF1ZXN0KHJlc3BvbnNlLCB7XG4gICAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgICAgcGFyYW1zOiBzaW5nbGVGZXRjaE1hdGNoZXMgPyBzaW5nbGVGZXRjaE1hdGNoZXNbMF0ucGFyYW1zIDoge30sXG4gICAgICAgICAgcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlU2luZ2xlRmV0Y2hSZWRpcmVjdFJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgX2J1aWxkLFxuICAgICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1NwYU1vZGUgJiYgbWF0Y2hlcyAmJiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubW9kdWxlLmRlZmF1bHQgPT0gbnVsbCAmJiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubW9kdWxlLkVycm9yQm91bmRhcnkgPT0gbnVsbCkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVSZXNvdXJjZVJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIF9idWlsZCxcbiAgICAgICAgc3RhdGljSGFuZGxlcixcbiAgICAgICAgbWF0Y2hlcy5zbGljZSgtMSlbMF0ucm91dGUuaWQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBoYW5kbGVFcnJvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHsgcGF0aG5hbWUgfSA9IHVybDtcbiAgICAgIGxldCBjcml0aWNhbENzcyA9IHZvaWQgMDtcbiAgICAgIGlmIChfYnVpbGQudW5zdGFibGVfZ2V0Q3JpdGljYWxDc3MpIHtcbiAgICAgICAgY3JpdGljYWxDc3MgPSBhd2FpdCBfYnVpbGQudW5zdGFibGVfZ2V0Q3JpdGljYWxDc3MoeyBwYXRobmFtZSB9KTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovICYmIGdldERldlNlcnZlckhvb2tzKCk/LmdldENyaXRpY2FsQ3NzKSB7XG4gICAgICAgIGNyaXRpY2FsQ3NzID0gYXdhaXQgZ2V0RGV2U2VydmVySG9va3MoKT8uZ2V0Q3JpdGljYWxDc3M/LihwYXRobmFtZSk7XG4gICAgICB9XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdChcbiAgICAgICAgc2VydmVyTW9kZSxcbiAgICAgICAgX2J1aWxkLFxuICAgICAgICBzdGF0aWNIYW5kbGVyLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgaGFuZGxlRXJyb3IsXG4gICAgICAgIGlzU3BhTW9kZSxcbiAgICAgICAgY3JpdGljYWxDc3NcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcbn07XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVNYW5pZmVzdFJlcXVlc3QoYnVpbGQsIHJvdXRlcywgdXJsKSB7XG4gIGlmIChidWlsZC5hc3NldHMudmVyc2lvbiAhPT0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ2ZXJzaW9uXCIpKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICBzdGF0dXM6IDIwNCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiOiBcInRydWVcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCBwYXRjaGVzID0ge307XG4gIGlmICh1cmwuc2VhcmNoUGFyYW1zLmhhcyhcInBhdGhzXCIpKSB7XG4gICAgbGV0IHBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgcGF0aFBhcmFtID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJwYXRoc1wiKSB8fCBcIlwiO1xuICAgIGxldCByZXF1ZXN0ZWRQYXRocyA9IHBhdGhQYXJhbS5zcGxpdChcIixcIikuZmlsdGVyKEJvb2xlYW4pO1xuICAgIHJlcXVlc3RlZFBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIGlmICghcGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICBwYXRoID0gYC8ke3BhdGh9YDtcbiAgICAgIH1cbiAgICAgIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpLnNsaWNlKDEpO1xuICAgICAgc2VnbWVudHMuZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgICBsZXQgcGFydGlhbFBhdGggPSBzZWdtZW50cy5zbGljZSgwLCBpICsgMSkuam9pbihcIi9cIik7XG4gICAgICAgIHBhdGhzLmFkZChgLyR7cGFydGlhbFBhdGh9YCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmb3IgKGxldCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgcGF0aCwgYnVpbGQuYmFzZW5hbWUpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgIGxldCByb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgICAgICAgbGV0IHJvdXRlID0gYnVpbGQuYXNzZXRzLnJvdXRlc1tyb3V0ZUlkXTtcbiAgICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgIHBhdGNoZXNbcm91dGVJZF0gPSByb3V0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlLmpzb24ocGF0Y2hlcywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNhY2hlLUNvbnRyb2xcIjogXCJwdWJsaWMsIG1heC1hZ2U9MzE1MzYwMDAsIGltbXV0YWJsZVwiXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcIkludmFsaWQgUmVxdWVzdFwiLCB7IHN0YXR1czogNDAwIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlU2luZ2xlRmV0Y2hSZXF1ZXN0KHNlcnZlck1vZGUsIGJ1aWxkLCBzdGF0aWNIYW5kbGVyLCByZXF1ZXN0LCBoYW5kbGVyVXJsLCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IpIHtcbiAgbGV0IHJlc3BvbnNlID0gcmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIgPyBhd2FpdCBzaW5nbGVGZXRjaEFjdGlvbihcbiAgICBidWlsZCxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgcmVxdWVzdCxcbiAgICBoYW5kbGVyVXJsLFxuICAgIGxvYWRDb250ZXh0LFxuICAgIGhhbmRsZUVycm9yXG4gICkgOiBhd2FpdCBzaW5nbGVGZXRjaExvYWRlcnMoXG4gICAgYnVpbGQsXG4gICAgc2VydmVyTW9kZSxcbiAgICBzdGF0aWNIYW5kbGVyLFxuICAgIHJlcXVlc3QsXG4gICAgaGFuZGxlclVybCxcbiAgICBsb2FkQ29udGV4dCxcbiAgICBoYW5kbGVFcnJvclxuICApO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVEb2N1bWVudFJlcXVlc3Qoc2VydmVyTW9kZSwgYnVpbGQsIHN0YXRpY0hhbmRsZXIsIHJlcXVlc3QsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvciwgaXNTcGFNb2RlLCBjcml0aWNhbENzcykge1xuICB0cnkge1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KHJlcXVlc3QsIHtcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVJlc3BvbnNlOiBidWlsZC5mdXR1cmUudjhfbWlkZGxld2FyZSA/IGFzeW5jIChxdWVyeSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBpbm5lclJlc3VsdCA9IGF3YWl0IHF1ZXJ5KHJlcXVlc3QpO1xuICAgICAgICAgIGlmICghaXNSZXNwb25zZShpbm5lclJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlubmVyUmVzdWx0ID0gYXdhaXQgcmVuZGVySHRtbChpbm5lclJlc3VsdCwgaXNTcGFNb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlubmVyUmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gOiB2b2lkIDBcbiAgICB9KTtcbiAgICBpZiAoIWlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcmVuZGVySHRtbChyZXN1bHQsIGlzU3BhTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW5kZXJIdG1sKGNvbnRleHQsIGlzU3BhTW9kZTIpIHtcbiAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhjb250ZXh0LCBidWlsZCk7XG4gICAgaWYgKFNFUlZFUl9OT19CT0RZX1NUQVRVU19DT0RFUy5oYXMoY29udGV4dC5zdGF0dXNDb2RlKSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogY29udGV4dC5zdGF0dXNDb2RlLCBoZWFkZXJzIH0pO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICBpZiAoIWlzUm91dGVFcnJvclJlc3BvbnNlKGVycikgfHwgZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlID0ge1xuICAgICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgICAgZXJyb3JzOiBzZXJpYWxpemVFcnJvcnMoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpXG4gICAgfTtcbiAgICBsZXQgYmFzZVNlcnZlckhhbmRvZmYgPSB7XG4gICAgICBiYXNlbmFtZTogYnVpbGQuYmFzZW5hbWUsXG4gICAgICBmdXR1cmU6IGJ1aWxkLmZ1dHVyZSxcbiAgICAgIHJvdXRlRGlzY292ZXJ5OiBidWlsZC5yb3V0ZURpc2NvdmVyeSxcbiAgICAgIHNzcjogYnVpbGQuc3NyLFxuICAgICAgaXNTcGFNb2RlOiBpc1NwYU1vZGUyXG4gICAgfTtcbiAgICBsZXQgZW50cnlDb250ZXh0ID0ge1xuICAgICAgbWFuaWZlc3Q6IGJ1aWxkLmFzc2V0cyxcbiAgICAgIHJvdXRlTW9kdWxlczogY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMoYnVpbGQucm91dGVzKSxcbiAgICAgIHN0YXRpY0hhbmRsZXJDb250ZXh0OiBjb250ZXh0LFxuICAgICAgY3JpdGljYWxDc3MsXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nOiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHtcbiAgICAgICAgLi4uYmFzZVNlcnZlckhhbmRvZmYsXG4gICAgICAgIGNyaXRpY2FsQ3NzXG4gICAgICB9KSxcbiAgICAgIHNlcnZlckhhbmRvZmZTdHJlYW06IGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICApLFxuICAgICAgcmVuZGVyTWV0YToge30sXG4gICAgICBmdXR1cmU6IGJ1aWxkLmZ1dHVyZSxcbiAgICAgIHNzcjogYnVpbGQuc3NyLFxuICAgICAgcm91dGVEaXNjb3Zlcnk6IGJ1aWxkLnJvdXRlRGlzY292ZXJ5LFxuICAgICAgaXNTcGFNb2RlOiBpc1NwYU1vZGUyLFxuICAgICAgc2VyaWFsaXplRXJyb3I6IChlcnIpID0+IHNlcmlhbGl6ZUVycm9yKGVyciwgc2VydmVyTW9kZSlcbiAgICB9O1xuICAgIGxldCBoYW5kbGVEb2N1bWVudFJlcXVlc3RGdW5jdGlvbiA9IGJ1aWxkLmVudHJ5Lm1vZHVsZS5kZWZhdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgZW50cnlDb250ZXh0LFxuICAgICAgICBsb2FkQ29udGV4dFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgbGV0IGVycm9yRm9yU2Vjb25kUmVuZGVyID0gZXJyb3I7XG4gICAgICBpZiAoaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgZGF0YTIgPSBhd2FpdCB1bndyYXBSZXNwb25zZShlcnJvcik7XG4gICAgICAgICAgZXJyb3JGb3JTZWNvbmRSZW5kZXIgPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgICBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgZGF0YTJcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKFxuICAgICAgICBzdGF0aWNIYW5kbGVyLmRhdGFSb3V0ZXMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGVycm9yRm9yU2Vjb25kUmVuZGVyXG4gICAgICApO1xuICAgICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICAgIGNvbnRleHQuZXJyb3JzID0gc2FuaXRpemVFcnJvcnMoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpO1xuICAgICAgfVxuICAgICAgbGV0IHN0YXRlMiA9IHtcbiAgICAgICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICAgIGVycm9yczogc2VyaWFsaXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKVxuICAgICAgfTtcbiAgICAgIGVudHJ5Q29udGV4dCA9IHtcbiAgICAgICAgLi4uZW50cnlDb250ZXh0LFxuICAgICAgICBzdGF0aWNIYW5kbGVyQ29udGV4dDogY29udGV4dCxcbiAgICAgICAgc2VydmVySGFuZG9mZlN0cmluZzogY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhiYXNlU2VydmVySGFuZG9mZiksXG4gICAgICAgIHNlcnZlckhhbmRvZmZTdHJlYW06IGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgICAgIHN0YXRlMixcbiAgICAgICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgICAgICBidWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgICksXG4gICAgICAgIHJlbmRlck1ldGE6IHt9XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgY29udGV4dC5zdGF0dXNDb2RlLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgZW50cnlDb250ZXh0LFxuICAgICAgICAgIGxvYWRDb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IyKTtcbiAgICAgICAgcmV0dXJuIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKGVycm9yMiwgc2VydmVyTW9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXNvdXJjZVJlcXVlc3Qoc2VydmVyTW9kZSwgYnVpbGQsIHN0YXRpY0hhbmRsZXIsIHJvdXRlSWQsIHJlcXVlc3QsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvcikge1xuICB0cnkge1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5Um91dGUocmVxdWVzdCwge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHJlcXVlc3RDb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVJlc3BvbnNlOiBidWlsZC5mdXR1cmUudjhfbWlkZGxld2FyZSA/IGFzeW5jIChxdWVyeVJvdXRlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGlubmVyUmVzdWx0ID0gYXdhaXQgcXVlcnlSb3V0ZShyZXF1ZXN0KTtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUXVlcnlSb3V0ZVJlc3VsdChpbm5lclJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVF1ZXJ5Um91dGVFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gaGFuZGxlUXVlcnlSb3V0ZVJlc3VsdChyZXN1bHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBoYW5kbGVRdWVyeVJvdXRlRXJyb3IoZXJyb3IpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVF1ZXJ5Um91dGVSZXN1bHQocmVzdWx0KSB7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlLmpzb24ocmVzdWx0KTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVRdWVyeVJvdXRlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSkge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2VUb0pzb24oZXJyb3IsIHNlcnZlck1vZGUpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlID09PSBcIkV4cGVjdGVkIGEgcmVzcG9uc2UgZnJvbSBxdWVyeVJvdXRlXCIpIHtcbiAgICAgIGxldCBuZXdFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFJlc3BvbnNlIHRvIGJlIHJldHVybmVkIGZyb20gcmVzb3VyY2Ugcm91dGUgaGFuZGxlclwiXG4gICAgICApO1xuICAgICAgaGFuZGxlRXJyb3IobmV3RXJyb3IpO1xuICAgICAgcmV0dXJuIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKG5ld0Vycm9yLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yUmVzcG9uc2VUb0pzb24oZXJyb3JSZXNwb25zZSwgc2VydmVyTW9kZSkge1xuICByZXR1cm4gUmVzcG9uc2UuanNvbihcbiAgICBzZXJpYWxpemVFcnJvcihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICBlcnJvclJlc3BvbnNlLmVycm9yIHx8IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpLFxuICAgICAgc2VydmVyTW9kZVxuICAgICksXG4gICAge1xuICAgICAgc3RhdHVzOiBlcnJvclJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGVycm9yUmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKGVycm9yLCBzZXJ2ZXJNb2RlKSB7XG4gIGxldCBtZXNzYWdlID0gXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiO1xuICBpZiAoc2VydmVyTW9kZSAhPT0gXCJwcm9kdWN0aW9uXCIgLyogUHJvZHVjdGlvbiAqLykge1xuICAgIG1lc3NhZ2UgKz0gYFxuXG4ke1N0cmluZyhlcnJvcil9YDtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG1lc3NhZ2UsIHtcbiAgICBzdGF0dXM6IDUwMCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1bndyYXBSZXNwb25zZShyZXNwb25zZSkge1xuICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgcmV0dXJuIGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpID8gcmVzcG9uc2UuYm9keSA9PSBudWxsID8gbnVsbCA6IHJlc3BvbnNlLmpzb24oKSA6IHJlc3BvbnNlLnRleHQoKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3Nlc3Npb25zLnRzXG5mdW5jdGlvbiBmbGFzaChuYW1lKSB7XG4gIHJldHVybiBgX19mbGFzaF8ke25hbWV9X19gO1xufVxudmFyIGNyZWF0ZVNlc3Npb24gPSAoaW5pdGlhbERhdGEgPSB7fSwgaWQgPSBcIlwiKSA9PiB7XG4gIGxldCBtYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGluaXRpYWxEYXRhKSk7XG4gIHJldHVybiB7XG4gICAgZ2V0IGlkKCkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKG1hcCk7XG4gICAgfSxcbiAgICBoYXMobmFtZSkge1xuICAgICAgcmV0dXJuIG1hcC5oYXMobmFtZSkgfHwgbWFwLmhhcyhmbGFzaChuYW1lKSk7XG4gICAgfSxcbiAgICBnZXQobmFtZSkge1xuICAgICAgaWYgKG1hcC5oYXMobmFtZSkpIHJldHVybiBtYXAuZ2V0KG5hbWUpO1xuICAgICAgbGV0IGZsYXNoTmFtZSA9IGZsYXNoKG5hbWUpO1xuICAgICAgaWYgKG1hcC5oYXMoZmxhc2hOYW1lKSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXAuZ2V0KGZsYXNoTmFtZSk7XG4gICAgICAgIG1hcC5kZWxldGUoZmxhc2hOYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgbWFwLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBmbGFzaChuYW1lLCB2YWx1ZSkge1xuICAgICAgbWFwLnNldChmbGFzaChuYW1lKSwgdmFsdWUpO1xuICAgIH0sXG4gICAgdW5zZXQobmFtZSkge1xuICAgICAgbWFwLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH07XG59O1xudmFyIGlzU2Vzc2lvbiA9IChvYmplY3QpID0+IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QuaWQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5kYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBvYmplY3QuaGFzID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnNldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QuZmxhc2ggPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LnVuc2V0ID09PSBcImZ1bmN0aW9uXCI7XG59O1xuZnVuY3Rpb24gY3JlYXRlU2Vzc2lvblN0b3JhZ2Uoe1xuICBjb29raWU6IGNvb2tpZUFyZyxcbiAgY3JlYXRlRGF0YSxcbiAgcmVhZERhdGEsXG4gIHVwZGF0ZURhdGEsXG4gIGRlbGV0ZURhdGFcbn0pIHtcbiAgbGV0IGNvb2tpZSA9IGlzQ29va2llKGNvb2tpZUFyZykgPyBjb29raWVBcmcgOiBjcmVhdGVDb29raWUoY29va2llQXJnPy5uYW1lIHx8IFwiX19zZXNzaW9uXCIsIGNvb2tpZUFyZyk7XG4gIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGdldFNlc3Npb24oY29va2llSGVhZGVyLCBvcHRpb25zKSB7XG4gICAgICBsZXQgaWQgPSBjb29raWVIZWFkZXIgJiYgYXdhaXQgY29va2llLnBhcnNlKGNvb2tpZUhlYWRlciwgb3B0aW9ucyk7XG4gICAgICBsZXQgZGF0YTIgPSBpZCAmJiBhd2FpdCByZWFkRGF0YShpZCk7XG4gICAgICByZXR1cm4gY3JlYXRlU2Vzc2lvbihkYXRhMiB8fCB7fSwgaWQgfHwgXCJcIik7XG4gICAgfSxcbiAgICBhc3luYyBjb21taXRTZXNzaW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIGxldCB7IGlkLCBkYXRhOiBkYXRhMiB9ID0gc2Vzc2lvbjtcbiAgICAgIGxldCBleHBpcmVzID0gb3B0aW9ucz8ubWF4QWdlICE9IG51bGwgPyBuZXcgRGF0ZShEYXRlLm5vdygpICsgb3B0aW9ucy5tYXhBZ2UgKiAxZTMpIDogb3B0aW9ucz8uZXhwaXJlcyAhPSBudWxsID8gb3B0aW9ucy5leHBpcmVzIDogY29va2llLmV4cGlyZXM7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgYXdhaXQgdXBkYXRlRGF0YShpZCwgZGF0YTIsIGV4cGlyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWQgPSBhd2FpdCBjcmVhdGVEYXRhKGRhdGEyLCBleHBpcmVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29raWUuc2VyaWFsaXplKGlkLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGRlc3Ryb3lTZXNzaW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIGF3YWl0IGRlbGV0ZURhdGEoc2Vzc2lvbi5pZCk7XG4gICAgICByZXR1cm4gY29va2llLnNlcmlhbGl6ZShcIlwiLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG1heEFnZTogdm9pZCAwLFxuICAgICAgICBleHBpcmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpIHtcbiAgd2Fybk9uY2UoXG4gICAgY29va2llLmlzU2lnbmVkLFxuICAgIGBUaGUgXCIke2Nvb2tpZS5uYW1lfVwiIGNvb2tpZSBpcyBub3Qgc2lnbmVkLCBidXQgc2Vzc2lvbiBjb29raWVzIHNob3VsZCBiZSBzaWduZWQgdG8gcHJldmVudCB0YW1wZXJpbmcgb24gdGhlIGNsaWVudCBiZWZvcmUgdGhleSBhcmUgc2VudCBiYWNrIHRvIHRoZSBzZXJ2ZXIuIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9leHBsYW5hdGlvbi9zZXNzaW9ucy1hbmQtY29va2llcyNzaWduaW5nLWNvb2tpZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICApO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2Vzc2lvbnMvY29va2llU3RvcmFnZS50c1xuZnVuY3Rpb24gY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2UoeyBjb29raWU6IGNvb2tpZUFyZyB9ID0ge30pIHtcbiAgbGV0IGNvb2tpZSA9IGlzQ29va2llKGNvb2tpZUFyZykgPyBjb29raWVBcmcgOiBjcmVhdGVDb29raWUoY29va2llQXJnPy5uYW1lIHx8IFwiX19zZXNzaW9uXCIsIGNvb2tpZUFyZyk7XG4gIHdhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZShjb29raWUpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIGdldFNlc3Npb24oY29va2llSGVhZGVyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU2Vzc2lvbihcbiAgICAgICAgY29va2llSGVhZGVyICYmIGF3YWl0IGNvb2tpZS5wYXJzZShjb29raWVIZWFkZXIsIG9wdGlvbnMpIHx8IHt9XG4gICAgICApO1xuICAgIH0sXG4gICAgYXN5bmMgY29tbWl0U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBsZXQgc2VyaWFsaXplZENvb2tpZSA9IGF3YWl0IGNvb2tpZS5zZXJpYWxpemUoc2Vzc2lvbi5kYXRhLCBvcHRpb25zKTtcbiAgICAgIGlmIChzZXJpYWxpemVkQ29va2llLmxlbmd0aCA+IDQwOTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ29va2llIGxlbmd0aCB3aWxsIGV4Y2VlZCBicm93c2VyIG1heGltdW0uIExlbmd0aDogXCIgKyBzZXJpYWxpemVkQ29va2llLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRDb29raWU7XG4gICAgfSxcbiAgICBhc3luYyBkZXN0cm95U2Vzc2lvbihfc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNvb2tpZS5zZXJpYWxpemUoXCJcIiwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtYXhBZ2U6IHZvaWQgMCxcbiAgICAgICAgZXhwaXJlczogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXNzaW9ucy9tZW1vcnlTdG9yYWdlLnRzXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSh7IGNvb2tpZSB9ID0ge30pIHtcbiAgbGV0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBjcmVhdGVTZXNzaW9uU3RvcmFnZSh7XG4gICAgY29va2llLFxuICAgIGFzeW5jIGNyZWF0ZURhdGEoZGF0YTIsIGV4cGlyZXMpIHtcbiAgICAgIGxldCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gICAgICBtYXAuc2V0KGlkLCB7IGRhdGE6IGRhdGEyLCBleHBpcmVzIH0pO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgYXN5bmMgcmVhZERhdGEoaWQpIHtcbiAgICAgIGlmIChtYXAuaGFzKGlkKSkge1xuICAgICAgICBsZXQgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9ID0gbWFwLmdldChpZCk7XG4gICAgICAgIGlmICghZXhwaXJlcyB8fCBleHBpcmVzID4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGlyZXMpIG1hcC5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBhc3luYyB1cGRhdGVEYXRhKGlkLCBkYXRhMiwgZXhwaXJlcykge1xuICAgICAgbWFwLnNldChpZCwgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9KTtcbiAgICB9LFxuICAgIGFzeW5jIGRlbGV0ZURhdGEoaWQpIHtcbiAgICAgIG1hcC5kZWxldGUoaWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGxpYi9ocmVmLnRzXG5mdW5jdGlvbiBocmVmKHBhdGgsIC4uLmFyZ3MpIHtcbiAgbGV0IHBhcmFtcyA9IGFyZ3NbMF07XG4gIGxldCByZXN1bHQgPSBwYXRoLnJlcGxhY2UoL1xcLypcXCo/JC8sIFwiXCIpLnJlcGxhY2UoXG4gICAgL1xcLzooW1xcdy1dKykoXFw/KT8vZyxcbiAgICAvLyBzYW1lIHJlZ2V4IGFzIGluIC5cXHJvdXRlclxcdXRpbHMudHM6IGNvbXBpbGVQYXRoKCkuXG4gICAgKF8sIHBhcmFtLCBxdWVzdGlvbk1hcmspID0+IHtcbiAgICAgIGNvbnN0IGlzUmVxdWlyZWQgPSBxdWVzdGlvbk1hcmsgPT09IHZvaWQgMDtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zID8gcGFyYW1zW3BhcmFtXSA6IHZvaWQgMDtcbiAgICAgIGlmIChpc1JlcXVpcmVkICYmIHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQYXRoICcke3BhdGh9JyByZXF1aXJlcyBwYXJhbSAnJHtwYXJhbX0nIGJ1dCBpdCB3YXMgbm90IHByb3ZpZGVkYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBcIlwiIDogXCIvXCIgKyB2YWx1ZTtcbiAgICB9XG4gICk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zID8gcGFyYW1zW1wiKlwiXSA6IHZvaWQgMDtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0ICs9IFwiL1wiICsgdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQgfHwgXCIvXCI7XG59XG5cbi8vIGxpYi9yc2MvYnJvd3Nlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcblxuLy8gbGliL2RvbS9zc3IvaHlkcmF0aW9uLnRzeFxuZnVuY3Rpb24gZ2V0SHlkcmF0aW9uRGF0YSh7XG4gIHN0YXRlLFxuICByb3V0ZXMsXG4gIGdldFJvdXRlSW5mbyxcbiAgbG9jYXRpb246IGxvY2F0aW9uMixcbiAgYmFzZW5hbWUsXG4gIGlzU3BhTW9kZVxufSkge1xuICBsZXQgaHlkcmF0aW9uRGF0YSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsb2FkZXJEYXRhOiB7IC4uLnN0YXRlLmxvYWRlckRhdGEgfVxuICB9O1xuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uMiwgYmFzZW5hbWUpO1xuICBpZiAoaW5pdGlhbE1hdGNoZXMpIHtcbiAgICBmb3IgKGxldCBtYXRjaCBvZiBpbml0aWFsTWF0Y2hlcykge1xuICAgICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICAgIGxldCByb3V0ZUluZm8gPSBnZXRSb3V0ZUluZm8ocm91dGVJZCk7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgICByb3V0ZUluZm8uY2xpZW50TG9hZGVyLFxuICAgICAgICByb3V0ZUluZm8uaGFzTG9hZGVyLFxuICAgICAgICBpc1NwYU1vZGVcbiAgICAgICkgJiYgKHJvdXRlSW5mby5oYXNIeWRyYXRlRmFsbGJhY2sgfHwgIXJvdXRlSW5mby5oYXNMb2FkZXIpKSB7XG4gICAgICAgIGRlbGV0ZSBoeWRyYXRpb25EYXRhLmxvYWRlckRhdGFbcm91dGVJZF07XG4gICAgICB9IGVsc2UgaWYgKCFyb3V0ZUluZm8uaGFzTG9hZGVyKSB7XG4gICAgICAgIGh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YVtyb3V0ZUlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBoeWRyYXRpb25EYXRhO1xufVxuXG4vLyBsaWIvcnNjL2Vycm9yQm91bmRhcmllcy50c3hcbmltcG9ydCBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG52YXIgUlNDUm91dGVyR2xvYmFsRXJyb3JCb3VuZGFyeSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QzLkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7IGVycm9yOiBudWxsLCBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24gfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiBudWxsLCBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3I6IHN0YXRlLmVycm9yLCBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24gfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFJTQ0RlZmF1bHRSb290RXJyb3JCb3VuZGFyeUltcGwsXG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICByZW5kZXJBcHBTaGVsbDogdHJ1ZVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBFcnJvcldyYXBwZXIoe1xuICByZW5kZXJBcHBTaGVsbCxcbiAgdGl0bGUsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGlmICghcmVuZGVyQXBwU2hlbGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcImh0bWxcIiwgeyBsYW5nOiBcImVuXCIgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsgY2hhclNldDogXCJ1dGYtOFwiIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJtZXRhXCIsXG4gICAge1xuICAgICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgICAgY29udGVudDogXCJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLHZpZXdwb3J0LWZpdD1jb3ZlclwiXG4gICAgfVxuICApLCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCB0aXRsZSkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcIm1haW5cIiwgeyBzdHlsZTogeyBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLCBwYWRkaW5nOiBcIjJyZW1cIiB9IH0sIGNoaWxkcmVuKSkpO1xufVxuZnVuY3Rpb24gUlNDRGVmYXVsdFJvb3RFcnJvckJvdW5kYXJ5SW1wbCh7XG4gIGVycm9yLFxuICByZW5kZXJBcHBTaGVsbFxufSkge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgbGV0IGhleURldmVsb3BlciA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9LiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMuIENoZWNrIG91dCBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob3ctdG8vZXJyb3ItYm91bmRhcnkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIGBcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgICAgRXJyb3JXcmFwcGVyLFxuICAgICAge1xuICAgICAgICByZW5kZXJBcHBTaGVsbCxcbiAgICAgICAgdGl0bGU6IFwiVW5oYW5kbGVkIFRocm93biBSZXNwb25zZSFcIlxuICAgICAgfSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcImgxXCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IFwiMjRweFwiIH0gfSwgZXJyb3Iuc3RhdHVzLCBcIiBcIiwgZXJyb3Iuc3RhdHVzVGV4dCksXG4gICAgICBFTkFCTEVfREVWX1dBUk5JTkdTID8gaGV5RGV2ZWxvcGVyIDogbnVsbFxuICAgICk7XG4gIH1cbiAgbGV0IGVycm9ySW5zdGFuY2U7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgZXJyb3JJbnN0YW5jZSA9IGVycm9yO1xuICB9IGVsc2Uge1xuICAgIGxldCBlcnJvclN0cmluZyA9IGVycm9yID09IG51bGwgPyBcIlVua25vd24gRXJyb3JcIiA6IHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcInRvU3RyaW5nXCIgaW4gZXJyb3IgPyBlcnJvci50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICAgIGVycm9ySW5zdGFuY2UgPSBuZXcgRXJyb3IoZXJyb3JTdHJpbmcpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRXJyb3JXcmFwcGVyLCB7IHJlbmRlckFwcFNoZWxsLCB0aXRsZTogXCJBcHBsaWNhdGlvbiBFcnJvciFcIiB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7IHN0eWxlOiB7IGZvbnRTaXplOiBcIjI0cHhcIiB9IH0sIFwiQXBwbGljYXRpb24gRXJyb3JcIiksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcbiAgICBcInByZVwiLFxuICAgIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnJlbVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcImhzbGEoMTAsIDUwJSwgNTAlLCAwLjEpXCIsXG4gICAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgICBvdmVyZmxvdzogXCJhdXRvXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGVycm9ySW5zdGFuY2Uuc3RhY2tcbiAgKSwgaGV5RGV2ZWxvcGVyKTtcbn1cbmZ1bmN0aW9uIFJTQ0RlZmF1bHRSb290RXJyb3JCb3VuZGFyeSh7XG4gIGhhc1Jvb3RMYXlvdXRcbn0pIHtcbiAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xuICBpZiAoaGFzUm9vdExheW91dCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAnaGFzUm9vdExheW91dCcgcHJvcFwiKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgIFJTQ0RlZmF1bHRSb290RXJyb3JCb3VuZGFyeUltcGwsXG4gICAge1xuICAgICAgcmVuZGVyQXBwU2hlbGw6ICFoYXNSb290TGF5b3V0LFxuICAgICAgZXJyb3JcbiAgICB9XG4gICk7XG59XG5cbi8vIGxpYi9yc2Mvcm91dGUtbW9kdWxlcy50c1xuZnVuY3Rpb24gY3JlYXRlUlNDUm91dGVNb2R1bGVzKHBheWxvYWQpIHtcbiAgY29uc3Qgcm91dGVNb2R1bGVzID0ge307XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgcGF5bG9hZC5tYXRjaGVzKSB7XG4gICAgcG9wdWxhdGVSU0NSb3V0ZU1vZHVsZXMocm91dGVNb2R1bGVzLCBtYXRjaCk7XG4gIH1cbiAgcmV0dXJuIHJvdXRlTW9kdWxlcztcbn1cbmZ1bmN0aW9uIHBvcHVsYXRlUlNDUm91dGVNb2R1bGVzKHJvdXRlTW9kdWxlcywgbWF0Y2hlcykge1xuICBtYXRjaGVzID0gQXJyYXkuaXNBcnJheShtYXRjaGVzKSA/IG1hdGNoZXMgOiBbbWF0Y2hlc107XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIHJvdXRlTW9kdWxlc1ttYXRjaC5pZF0gPSB7XG4gICAgICBsaW5rczogbWF0Y2gubGlua3MsXG4gICAgICBtZXRhOiBtYXRjaC5tZXRhLFxuICAgICAgZGVmYXVsdDogbm9vcENvbXBvbmVudFxuICAgIH07XG4gIH1cbn1cbnZhciBub29wQ29tcG9uZW50ID0gKCkgPT4gbnVsbDtcblxuLy8gbGliL3JzYy9icm93c2VyLnRzeFxuZnVuY3Rpb24gY3JlYXRlQ2FsbFNlcnZlcih7XG4gIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSxcbiAgY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0LFxuICBlbmNvZGVSZXBseSxcbiAgZmV0Y2g6IGZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaFxufSkge1xuICBjb25zdCBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGxldCBsYW5kZWRBY3Rpb25JZCA9IDA7XG4gIHJldHVybiBhc3luYyAoaWQsIGFyZ3MpID0+IHtcbiAgICBsZXQgYWN0aW9uSWQgPSBnbG9iYWxWYXIuX19yb3V0ZXJBY3Rpb25JRCA9IChnbG9iYWxWYXIuX19yb3V0ZXJBY3Rpb25JRCA/PyAoZ2xvYmFsVmFyLl9fcm91dGVyQWN0aW9uSUQgPSAwKSkgKyAxO1xuICAgIGNvbnN0IHRlbXBvcmFyeVJlZmVyZW5jZXMgPSBjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQoKTtcbiAgICBjb25zdCBwYXlsb2FkUHJvbWlzZSA9IGZldGNoSW1wbGVtZW50YXRpb24oXG4gICAgICBuZXcgUmVxdWVzdChsb2NhdGlvbi5ocmVmLCB7XG4gICAgICAgIGJvZHk6IGF3YWl0IGVuY29kZVJlcGx5KGFyZ3MsIHsgdGVtcG9yYXJ5UmVmZXJlbmNlcyB9KSxcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEFjY2VwdDogXCJ0ZXh0L3gtY29tcG9uZW50XCIsXG4gICAgICAgICAgXCJyc2MtYWN0aW9uLWlkXCI6IGlkXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGJvZHlcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlLmJvZHksIHtcbiAgICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZ2xvYmFsVmFyLl9fcmVhY3RSb3V0ZXJEYXRhUm91dGVyLl9fc2V0UGVuZGluZ1JlcmVuZGVyKFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHBheWxvYWRQcm9taXNlKS50aGVuKGFzeW5jIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09IFwicmVkaXJlY3RcIikge1xuICAgICAgICAgIGlmIChwYXlsb2FkLnJlbG9hZCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBwYXlsb2FkLmxvY2F0aW9uO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBnbG9iYWxWYXIuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIubmF2aWdhdGUocGF5bG9hZC5sb2NhdGlvbiwge1xuICAgICAgICAgICAgICByZXBsYWNlOiBwYXlsb2FkLnJlcGxhY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBheWxvYWQudHlwZSAhPT0gXCJhY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgcGF5bG9hZCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcmVuZGVyID0gYXdhaXQgcGF5bG9hZC5yZXJlbmRlcjtcbiAgICAgICAgaWYgKHJlcmVuZGVyICYmIGxhbmRlZEFjdGlvbklkIDwgYWN0aW9uSWQgJiYgZ2xvYmFsVmFyLl9fcm91dGVyQWN0aW9uSUQgPD0gYWN0aW9uSWQpIHtcbiAgICAgICAgICBpZiAocmVyZW5kZXIudHlwZSA9PT0gXCJyZWRpcmVjdFwiKSB7XG4gICAgICAgICAgICBpZiAocmVyZW5kZXIucmVsb2FkKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcmVyZW5kZXIubG9jYXRpb247XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgIGdsb2JhbFZhci5fX3JlYWN0Um91dGVyRGF0YVJvdXRlci5uYXZpZ2F0ZShyZXJlbmRlci5sb2NhdGlvbiwge1xuICAgICAgICAgICAgICAgIHJlcGxhY2U6IHJlcmVuZGVyLnJlcGxhY2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxhc3RNYXRjaDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgcmVyZW5kZXIubWF0Y2hlcykge1xuICAgICAgICAgICAgICBnbG9iYWxWYXIuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIucGF0Y2hSb3V0ZXMoXG4gICAgICAgICAgICAgICAgbGFzdE1hdGNoPy5pZCA/PyBudWxsLFxuICAgICAgICAgICAgICAgIFtjcmVhdGVSb3V0ZUZyb21TZXJ2ZXJNYW5pZmVzdChtYXRjaCldLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgbGFzdE1hdGNoID0gbWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIuX2ludGVybmFsU2V0U3RhdGVEb05vdFVzZU9yWW91V2lsbEJyZWFrWW91ckFwcChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxvYWRlckRhdGE6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgIGdsb2JhbFZhci5fX3JlYWN0Um91dGVyRGF0YVJvdXRlci5zdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgICAgICAgICAgcmVyZW5kZXIubG9hZGVyRGF0YVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZXJyb3JzOiByZXJlbmRlci5lcnJvcnMgPyBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICBnbG9iYWxWYXIuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIuc3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgcmVyZW5kZXIuZXJyb3JzXG4gICAgICAgICAgICAgICAgKSA6IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHBheWxvYWRQcm9taXNlLnRoZW4oKHBheWxvYWQpID0+IHtcbiAgICAgIGlmIChwYXlsb2FkLnR5cGUgIT09IFwiYWN0aW9uXCIgJiYgcGF5bG9hZC50eXBlICE9PSBcInJlZGlyZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBwYXlsb2FkIHR5cGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF5bG9hZC5hY3Rpb25SZXN1bHQ7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJGcm9tUGF5bG9hZCh7XG4gIGZldGNoSW1wbGVtZW50YXRpb24sXG4gIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSxcbiAgZ2V0Q29udGV4dCxcbiAgcGF5bG9hZFxufSkge1xuICBjb25zdCBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGlmIChnbG9iYWxWYXIuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIgJiYgZ2xvYmFsVmFyLl9fcmVhY3RSb3V0ZXJSb3V0ZU1vZHVsZXMpXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjogZ2xvYmFsVmFyLl9fcmVhY3RSb3V0ZXJEYXRhUm91dGVyLFxuICAgICAgcm91dGVNb2R1bGVzOiBnbG9iYWxWYXIuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlc1xuICAgIH07XG4gIGlmIChwYXlsb2FkLnR5cGUgIT09IFwicmVuZGVyXCIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF5bG9hZCB0eXBlXCIpO1xuICBnbG9iYWxWYXIuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcyA9IGdsb2JhbFZhci5fX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzID8/IHt9O1xuICBwb3B1bGF0ZVJTQ1JvdXRlTW9kdWxlcyhnbG9iYWxWYXIuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcywgcGF5bG9hZC5tYXRjaGVzKTtcbiAgbGV0IHBhdGNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBwYXlsb2FkLnBhdGNoZXM/LmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgaW52YXJpYW50KHBhdGNoLnBhcmVudElkLCBcIkludmFsaWQgcGF0Y2ggcGFyZW50SWRcIik7XG4gICAgaWYgKCFwYXRjaGVzLmhhcyhwYXRjaC5wYXJlbnRJZCkpIHtcbiAgICAgIHBhdGNoZXMuc2V0KHBhdGNoLnBhcmVudElkLCBbXSk7XG4gICAgfVxuICAgIHBhdGNoZXMuZ2V0KHBhdGNoLnBhcmVudElkKT8ucHVzaChwYXRjaCk7XG4gIH0pO1xuICBsZXQgcm91dGVzID0gcGF5bG9hZC5tYXRjaGVzLnJlZHVjZVJpZ2h0KChwcmV2aW91cywgbWF0Y2gpID0+IHtcbiAgICBjb25zdCByb3V0ZSA9IGNyZWF0ZVJvdXRlRnJvbVNlcnZlck1hbmlmZXN0KFxuICAgICAgbWF0Y2gsXG4gICAgICBwYXlsb2FkXG4gICAgKTtcbiAgICBpZiAocHJldmlvdXMubGVuZ3RoID4gMCkge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBwcmV2aW91cztcbiAgICAgIGxldCBjaGlsZHJlblRvUGF0Y2ggPSBwYXRjaGVzLmdldChtYXRjaC5pZCk7XG4gICAgICBpZiAoY2hpbGRyZW5Ub1BhdGNoKSB7XG4gICAgICAgIHJvdXRlLmNoaWxkcmVuLnB1c2goXG4gICAgICAgICAgLi4uY2hpbGRyZW5Ub1BhdGNoLm1hcCgocikgPT4gY3JlYXRlUm91dGVGcm9tU2VydmVyTWFuaWZlc3QocikpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcm91dGVdO1xuICB9LCBbXSk7XG4gIGdsb2JhbFZhci5fX3JlYWN0Um91dGVyRGF0YVJvdXRlciA9IGNyZWF0ZVJvdXRlcih7XG4gICAgcm91dGVzLFxuICAgIGdldENvbnRleHQsXG4gICAgYmFzZW5hbWU6IHBheWxvYWQuYmFzZW5hbWUsXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSxcbiAgICBoeWRyYXRpb25EYXRhOiBnZXRIeWRyYXRpb25EYXRhKHtcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIGxvYWRlckRhdGE6IHBheWxvYWQubG9hZGVyRGF0YSxcbiAgICAgICAgYWN0aW9uRGF0YTogcGF5bG9hZC5hY3Rpb25EYXRhLFxuICAgICAgICBlcnJvcnM6IHBheWxvYWQuZXJyb3JzXG4gICAgICB9LFxuICAgICAgcm91dGVzLFxuICAgICAgZ2V0Um91dGVJbmZvOiAocm91dGVJZCkgPT4ge1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXlsb2FkLm1hdGNoZXMuZmluZCgobSkgPT4gbS5pZCA9PT0gcm91dGVJZCk7XG4gICAgICAgIGludmFyaWFudChtYXRjaCwgXCJSb3V0ZSBub3QgZm91bmQgaW4gcGF5bG9hZFwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjbGllbnRMb2FkZXI6IG1hdGNoLmNsaWVudExvYWRlcixcbiAgICAgICAgICBoYXNMb2FkZXI6IG1hdGNoLmhhc0xvYWRlcixcbiAgICAgICAgICBoYXNIeWRyYXRlRmFsbGJhY2s6IG1hdGNoLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgIT0gbnVsbFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxvY2F0aW9uOiBwYXlsb2FkLmxvY2F0aW9uLFxuICAgICAgYmFzZW5hbWU6IHBheWxvYWQuYmFzZW5hbWUsXG4gICAgICBpc1NwYU1vZGU6IGZhbHNlXG4gICAgfSksXG4gICAgYXN5bmMgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24oeyBwYXRoLCBzaWduYWwgfSkge1xuICAgICAgaWYgKGRpc2NvdmVyZWRQYXRocy5oYXMocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyhcbiAgICAgICAgW3BhdGhdLFxuICAgICAgICBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0sXG4gICAgICAgIGZldGNoSW1wbGVtZW50YXRpb24sXG4gICAgICAgIHNpZ25hbFxuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIEZJWE1FOiBQYXNzIGBidWlsZC5zc3JgIGludG8gdGhpcyBmdW5jdGlvblxuICAgIGRhdGFTdHJhdGVneTogZ2V0UlNDU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3koXG4gICAgICAoKSA9PiBnbG9iYWxWYXIuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIsXG4gICAgICB0cnVlLFxuICAgICAgcGF5bG9hZC5iYXNlbmFtZSxcbiAgICAgIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSxcbiAgICAgIGZldGNoSW1wbGVtZW50YXRpb25cbiAgICApXG4gIH0pO1xuICBpZiAoZ2xvYmFsVmFyLl9fcmVhY3RSb3V0ZXJEYXRhUm91dGVyLnN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgZ2xvYmFsVmFyLl9fcm91dGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGdsb2JhbFZhci5fX3JlYWN0Um91dGVyRGF0YVJvdXRlci5pbml0aWFsaXplKCk7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsVmFyLl9fcm91dGVySW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuICBsZXQgbGFzdExvYWRlckRhdGEgPSB2b2lkIDA7XG4gIGdsb2JhbFZhci5fX3JlYWN0Um91dGVyRGF0YVJvdXRlci5zdWJzY3JpYmUoKHsgbG9hZGVyRGF0YSwgYWN0aW9uRGF0YSB9KSA9PiB7XG4gICAgaWYgKGxhc3RMb2FkZXJEYXRhICE9PSBsb2FkZXJEYXRhKSB7XG4gICAgICBnbG9iYWxWYXIuX19yb3V0ZXJBY3Rpb25JRCA9IChnbG9iYWxWYXIuX19yb3V0ZXJBY3Rpb25JRCA/PyAoZ2xvYmFsVmFyLl9fcm91dGVyQWN0aW9uSUQgPSAwKSkgKyAxO1xuICAgIH1cbiAgfSk7XG4gIGdsb2JhbFZhci5fX3JlYWN0Um91dGVyRGF0YVJvdXRlci5fdXBkYXRlUm91dGVzRm9ySE1SID0gKHJvdXRlVXBkYXRlQnlSb3V0ZUlkKSA9PiB7XG4gICAgY29uc3Qgb2xkUm91dGVzID0gd2luZG93Ll9fcmVhY3RSb3V0ZXJEYXRhUm91dGVyLnJvdXRlcztcbiAgICBjb25zdCBuZXdSb3V0ZXMgPSBbXTtcbiAgICBmdW5jdGlvbiB3YWxrUm91dGVzKHJvdXRlczIsIHBhcmVudElkKSB7XG4gICAgICByZXR1cm4gcm91dGVzMi5tYXAoKHJvdXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvdXRlVXBkYXRlID0gcm91dGVVcGRhdGVCeVJvdXRlSWQuZ2V0KHJvdXRlLmlkKTtcbiAgICAgICAgaWYgKHJvdXRlVXBkYXRlKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgICBoYXNBY3Rpb24sXG4gICAgICAgICAgICBoYXNDb21wb25lbnQsXG4gICAgICAgICAgICBoYXNFcnJvckJvdW5kYXJ5LFxuICAgICAgICAgICAgaGFzTG9hZGVyXG4gICAgICAgICAgfSA9IHJvdXRlVXBkYXRlO1xuICAgICAgICAgIGNvbnN0IG5ld1JvdXRlID0gY3JlYXRlUm91dGVGcm9tU2VydmVyTWFuaWZlc3Qoe1xuICAgICAgICAgICAgY2xpZW50QWN0aW9uOiByb3V0ZU1vZHVsZS5jbGllbnRBY3Rpb24sXG4gICAgICAgICAgICBjbGllbnRMb2FkZXI6IHJvdXRlTW9kdWxlLmNsaWVudExvYWRlcixcbiAgICAgICAgICAgIGVsZW1lbnQ6IHJvdXRlLmVsZW1lbnQsXG4gICAgICAgICAgICBlcnJvckVsZW1lbnQ6IHJvdXRlLmVycm9yRWxlbWVudCxcbiAgICAgICAgICAgIGhhbmRsZTogcm91dGUuaGFuZGxlLFxuICAgICAgICAgICAgaGFzQWN0aW9uLFxuICAgICAgICAgICAgaGFzQ29tcG9uZW50LFxuICAgICAgICAgICAgaGFzRXJyb3JCb3VuZGFyeSxcbiAgICAgICAgICAgIGhhc0xvYWRlcixcbiAgICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IHJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQsXG4gICAgICAgICAgICBpZDogcm91dGUuaWQsXG4gICAgICAgICAgICBpbmRleDogcm91dGUuaW5kZXgsXG4gICAgICAgICAgICBsaW5rczogcm91dGVNb2R1bGUubGlua3MsXG4gICAgICAgICAgICBtZXRhOiByb3V0ZU1vZHVsZS5tZXRhLFxuICAgICAgICAgICAgcGFyZW50SWQsXG4gICAgICAgICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogcm91dGVNb2R1bGUuc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgbmV3Um91dGUuY2hpbGRyZW4gPSB3YWxrUm91dGVzKHJvdXRlLmNoaWxkcmVuLCByb3V0ZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdSb3V0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVkUm91dGUgPSB7IC4uLnJvdXRlIH07XG4gICAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgIHVwZGF0ZWRSb3V0ZS5jaGlsZHJlbiA9IHdhbGtSb3V0ZXMocm91dGUuY2hpbGRyZW4sIHJvdXRlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlZFJvdXRlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIG5ld1JvdXRlcy5wdXNoKFxuICAgICAgLi4ud2Fsa1JvdXRlcyhvbGRSb3V0ZXMsIHZvaWQgMClcbiAgICApO1xuICAgIHdpbmRvdy5fX3JlYWN0Um91dGVyRGF0YVJvdXRlci5faW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3V0ZXI6IGdsb2JhbFZhci5fX3JlYWN0Um91dGVyRGF0YVJvdXRlcixcbiAgICByb3V0ZU1vZHVsZXM6IGdsb2JhbFZhci5fX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzXG4gIH07XG59XG52YXIgcmVuZGVyZWRSb3V0ZXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuZnVuY3Rpb24gZ2V0UlNDU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3koZ2V0Um91dGVyLCBzc3IsIGJhc2VuYW1lLCBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0sIGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgbGV0IGRhdGFTdHJhdGVneSA9IGdldFNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5SW1wbChcbiAgICBnZXRSb3V0ZXIsXG4gICAgKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgTSA9IG1hdGNoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzTG9hZGVyOiBNLnJvdXRlLmhhc0xvYWRlcixcbiAgICAgICAgaGFzQ2xpZW50TG9hZGVyOiBNLnJvdXRlLmhhc0NsaWVudExvYWRlcixcbiAgICAgICAgaGFzQ29tcG9uZW50OiBNLnJvdXRlLmhhc0NvbXBvbmVudCxcbiAgICAgICAgaGFzQWN0aW9uOiBNLnJvdXRlLmhhc0FjdGlvbixcbiAgICAgICAgaGFzQ2xpZW50QWN0aW9uOiBNLnJvdXRlLmhhc0NsaWVudEFjdGlvbixcbiAgICAgICAgaGFzU2hvdWxkUmV2YWxpZGF0ZTogTS5yb3V0ZS5oYXNTaG91bGRSZXZhbGlkYXRlXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gcGFzcyBtYXAgaW50byBmZXRjaEFuZERlY29kZSBzbyBpdCBjYW4gYWRkIHBheWxvYWRzXG4gICAgZ2V0RmV0Y2hBbmREZWNvZGVWaWFSU0MoY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtLCBmZXRjaEltcGxlbWVudGF0aW9uKSxcbiAgICBzc3IsXG4gICAgYmFzZW5hbWUsXG4gICAgLy8gSWYgdGhlIHJvdXRlIGhhcyBhIGNvbXBvbmVudCBidXQgd2UgZG9uJ3QgaGF2ZSBhbiBlbGVtZW50LCB3ZSBuZWVkIHRvIGhpdFxuICAgIC8vIHRoZSBzZXJ2ZXIgbG9hZGVyIGZsb3cgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjbGllbnQgbG9hZGVyIGNhbGxzXG4gICAgLy8gYHNlcnZlckxvYWRlcmAgb3Igbm90LCBvdGhlcndpc2Ugd2UnbGwgaGF2ZSBub3RoaW5nIHRvIHJlbmRlci5cbiAgICAobWF0Y2gpID0+IHtcbiAgICAgIGxldCBNID0gbWF0Y2g7XG4gICAgICByZXR1cm4gTS5yb3V0ZS5oYXNDb21wb25lbnQgJiYgIU0ucm91dGUuZWxlbWVudDtcbiAgICB9XG4gICk7XG4gIHJldHVybiBhc3luYyAoYXJncykgPT4gYXJncy5ydW5DbGllbnRNaWRkbGV3YXJlKGFzeW5jICgpID0+IHtcbiAgICBsZXQgY29udGV4dCA9IGFyZ3MuY29udGV4dDtcbiAgICBjb250ZXh0LnNldChyZW5kZXJlZFJvdXRlc0NvbnRleHQsIFtdKTtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGRhdGFTdHJhdGVneShhcmdzKTtcbiAgICBjb25zdCByZW5kZXJlZFJvdXRlc0J5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3Qgcm91dGUgb2YgY29udGV4dC5nZXQocmVuZGVyZWRSb3V0ZXNDb250ZXh0KSkge1xuICAgICAgaWYgKCFyZW5kZXJlZFJvdXRlc0J5SWQuaGFzKHJvdXRlLmlkKSkge1xuICAgICAgICByZW5kZXJlZFJvdXRlc0J5SWQuc2V0KHJvdXRlLmlkLCBbXSk7XG4gICAgICB9XG4gICAgICByZW5kZXJlZFJvdXRlc0J5SWQuZ2V0KHJvdXRlLmlkKS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBhcmdzLm1hdGNoZXMpIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVkUm91dGVzID0gcmVuZGVyZWRSb3V0ZXNCeUlkLmdldChtYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBpZiAocmVuZGVyZWRSb3V0ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZW5kZXJlZCBvZiByZW5kZXJlZFJvdXRlcykge1xuICAgICAgICAgIHdpbmRvdy5fX3JlYWN0Um91dGVyRGF0YVJvdXRlci5wYXRjaFJvdXRlcyhcbiAgICAgICAgICAgIHJlbmRlcmVkLnBhcmVudElkID8/IG51bGwsXG4gICAgICAgICAgICBbY3JlYXRlUm91dGVGcm9tU2VydmVyTWFuaWZlc3QocmVuZGVyZWQpXSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZldGNoQW5kRGVjb2RlVmlhUlNDKGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSwgZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICByZXR1cm4gYXN5bmMgKGFyZ3MsIGJhc2VuYW1lLCB0YXJnZXRSb3V0ZXMpID0+IHtcbiAgICBsZXQgeyByZXF1ZXN0LCBjb250ZXh0IH0gPSBhcmdzO1xuICAgIGxldCB1cmwgPSBzaW5nbGVGZXRjaFVybChyZXF1ZXN0LnVybCwgYmFzZW5hbWUsIFwicnNjXCIpO1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgdXJsID0gc3RyaXBJbmRleFBhcmFtKHVybCk7XG4gICAgICBpZiAodGFyZ2V0Um91dGVzKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiX3JvdXRlc1wiLCB0YXJnZXRSb3V0ZXMuam9pbihcIixcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzID0gYXdhaXQgZmV0Y2hJbXBsZW1lbnRhdGlvbihcbiAgICAgIG5ldyBSZXF1ZXN0KHVybCwgYXdhaXQgY3JlYXRlUmVxdWVzdEluaXQocmVxdWVzdCkpXG4gICAgKTtcbiAgICBpZiAocmVzLnN0YXR1cyA+PSA0MDAgJiYgIXJlcy5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVzcG9uc2VcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbChyZXMuc3RhdHVzLCByZXMuc3RhdHVzVGV4dCwgYXdhaXQgcmVzLnRleHQoKSk7XG4gICAgfVxuICAgIGludmFyaWFudChyZXMuYm9keSwgXCJObyByZXNwb25zZSBib2R5IHRvIGRlY29kZVwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbShyZXMuYm9keSwge1xuICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gXCJyZWRpcmVjdFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHJlZGlyZWN0OiB7XG4gICAgICAgICAgICAgIHJlZGlyZWN0OiBwYXlsb2FkLmxvY2F0aW9uLFxuICAgICAgICAgICAgICByZWxvYWQ6IHBheWxvYWQucmVsb2FkLFxuICAgICAgICAgICAgICByZXBsYWNlOiBwYXlsb2FkLnJlcGxhY2UsXG4gICAgICAgICAgICAgIHJldmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgICBzdGF0dXM6IHBheWxvYWQuc3RhdHVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHBheWxvYWQudHlwZSAhPT0gXCJyZW5kZXJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHBheWxvYWQgdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZ2V0KHJlbmRlcmVkUm91dGVzQ29udGV4dCkucHVzaCguLi5wYXlsb2FkLm1hdGNoZXMpO1xuICAgICAgbGV0IHJlc3VsdHMgPSB7IHJvdXRlczoge30gfTtcbiAgICAgIGNvbnN0IGRhdGFLZXkgPSBpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKSA/IFwiYWN0aW9uRGF0YVwiIDogXCJsb2FkZXJEYXRhXCI7XG4gICAgICBmb3IgKGxldCBbcm91dGVJZCwgZGF0YTJdIG9mIE9iamVjdC5lbnRyaWVzKHBheWxvYWRbZGF0YUtleV0gfHwge30pKSB7XG4gICAgICAgIHJlc3VsdHMucm91dGVzW3JvdXRlSWRdID0geyBkYXRhOiBkYXRhMiB9O1xuICAgICAgfVxuICAgICAgaWYgKHBheWxvYWQuZXJyb3JzKSB7XG4gICAgICAgIGZvciAobGV0IFtyb3V0ZUlkLCBlcnJvcl0gb2YgT2JqZWN0LmVudHJpZXMocGF5bG9hZC5lcnJvcnMpKSB7XG4gICAgICAgICAgcmVzdWx0cy5yb3V0ZXNbcm91dGVJZF0gPSB7IGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogcmVzLnN0YXR1cywgZGF0YTogcmVzdWx0cyB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNvZGUgUlNDIHJlc3BvbnNlXCIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFJTQ0h5ZHJhdGVkUm91dGVyKHtcbiAgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtLFxuICBmZXRjaDogZmV0Y2hJbXBsZW1lbnRhdGlvbiA9IGZldGNoLFxuICBwYXlsb2FkLFxuICByb3V0ZURpc2NvdmVyeSA9IFwiZWFnZXJcIixcbiAgZ2V0Q29udGV4dFxufSkge1xuICBpZiAocGF5bG9hZC50eXBlICE9PSBcInJlbmRlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBheWxvYWQgdHlwZVwiKTtcbiAgbGV0IHsgcm91dGVyLCByb3V0ZU1vZHVsZXMgfSA9IFJlYWN0NC51c2VNZW1vKFxuICAgICgpID0+IGNyZWF0ZVJvdXRlckZyb21QYXlsb2FkKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBmZXRjaEltcGxlbWVudGF0aW9uLFxuICAgICAgZ2V0Q29udGV4dCxcbiAgICAgIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbVxuICAgIH0pLFxuICAgIFtjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0sIHBheWxvYWQsIGZldGNoSW1wbGVtZW50YXRpb24sIGdldENvbnRleHRdXG4gICk7XG4gIFJlYWN0NC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzSHlkcmF0ZWQoKTtcbiAgfSwgW10pO1xuICBSZWFjdDQudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gICAgaWYgKCFnbG9iYWxWYXIuX19yb3V0ZXJJbml0aWFsaXplZCkge1xuICAgICAgZ2xvYmFsVmFyLl9fcm91dGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZ2xvYmFsVmFyLl9fcmVhY3RSb3V0ZXJEYXRhUm91dGVyLmluaXRpYWxpemUoKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgbGV0IFtsb2NhdGlvbjIsIHNldExvY2F0aW9uXSA9IFJlYWN0NC51c2VTdGF0ZShyb3V0ZXIuc3RhdGUubG9jYXRpb24pO1xuICBSZWFjdDQudXNlTGF5b3V0RWZmZWN0KFxuICAgICgpID0+IHJvdXRlci5zdWJzY3JpYmUoKG5ld1N0YXRlKSA9PiB7XG4gICAgICBpZiAobmV3U3RhdGUubG9jYXRpb24gIT09IGxvY2F0aW9uMikge1xuICAgICAgICBzZXRMb2NhdGlvbihuZXdTdGF0ZS5sb2NhdGlvbik7XG4gICAgICB9XG4gICAgfSksXG4gICAgW3JvdXRlciwgbG9jYXRpb24yXVxuICApO1xuICBSZWFjdDQudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocm91dGVEaXNjb3ZlcnkgPT09IFwibGF6eVwiIHx8IC8vIEB0cy1leHBlY3QtZXJyb3IgLSBUUyBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyB5ZXRcbiAgICB3aW5kb3cubmF2aWdhdG9yPy5jb25uZWN0aW9uPy5zYXZlRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlckVsZW1lbnQoZWwpIHtcbiAgICAgIGxldCBwYXRoID0gZWwudGFnTmFtZSA9PT0gXCJGT1JNXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgOiBlbC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRobmFtZSA9IGVsLnRhZ05hbWUgPT09IFwiQVwiID8gZWwucGF0aG5hbWUgOiBuZXcgVVJMKHBhdGgsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLnBhdGhuYW1lO1xuICAgICAgaWYgKCFkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGhuYW1lKSkge1xuICAgICAgICBuZXh0UGF0aHMuYWRkKHBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQYXRjaGVzKCkge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImFbZGF0YS1kaXNjb3Zlcl0sIGZvcm1bZGF0YS1kaXNjb3Zlcl1cIikuZm9yRWFjaChyZWdpc3RlckVsZW1lbnQpO1xuICAgICAgbGV0IHBhdGhzID0gQXJyYXkuZnJvbShuZXh0UGF0aHMua2V5cygpKS5maWx0ZXIoKHBhdGgpID0+IHtcbiAgICAgICAgaWYgKGRpc2NvdmVyZWRQYXRocy5oYXMocGF0aCkpIHtcbiAgICAgICAgICBuZXh0UGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZXRjaEFuZEFwcGx5TWFuaWZlc3RQYXRjaGVzKFxuICAgICAgICAgIHBhdGhzLFxuICAgICAgICAgIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSxcbiAgICAgICAgICBmZXRjaEltcGxlbWVudGF0aW9uXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWFuaWZlc3QgcGF0Y2hlc1wiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRlYm91bmNlZEZldGNoUGF0Y2hlcyA9IGRlYm91bmNlKGZldGNoUGF0Y2hlcywgMTAwKTtcbiAgICBmZXRjaFBhdGNoZXMoKTtcbiAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiBkZWJvdW5jZWRGZXRjaFBhdGNoZXMoKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJkYXRhLWRpc2NvdmVyXCIsIFwiaHJlZlwiLCBcImFjdGlvblwiXVxuICAgIH0pO1xuICB9LCBbcm91dGVEaXNjb3ZlcnksIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSwgZmV0Y2hJbXBsZW1lbnRhdGlvbl0pO1xuICBjb25zdCBmcmFtZXdvcmtDb250ZXh0ID0ge1xuICAgIGZ1dHVyZToge1xuICAgICAgLy8gVGhlc2UgZmxhZ3MgaGF2ZSBubyBydW50aW1lIGltcGFjdCBzbyBjYW4gYWx3YXlzIGJlIGZhbHNlLiAgSWYgd2UgYWRkXG4gICAgICAvLyBmbGFncyB0aGF0IGRyaXZlIHJ1bnRpbWUgYmVoYXZpb3IgdGhleSdsbCBuZWVkIHRvIGJlIHByb3hpZWQgdGhyb3VnaC5cbiAgICAgIHY4X21pZGRsZXdhcmU6IGZhbHNlLFxuICAgICAgdW5zdGFibGVfc3ViUmVzb3VyY2VJbnRlZ3JpdHk6IGZhbHNlXG4gICAgfSxcbiAgICBpc1NwYU1vZGU6IGZhbHNlLFxuICAgIHNzcjogdHJ1ZSxcbiAgICBjcml0aWNhbENzczogXCJcIixcbiAgICBtYW5pZmVzdDoge1xuICAgICAgcm91dGVzOiB7fSxcbiAgICAgIHZlcnNpb246IFwiMVwiLFxuICAgICAgdXJsOiBcIlwiLFxuICAgICAgZW50cnk6IHtcbiAgICAgICAgbW9kdWxlOiBcIlwiLFxuICAgICAgICBpbXBvcnRzOiBbXVxuICAgICAgfVxuICAgIH0sXG4gICAgcm91dGVEaXNjb3Zlcnk6IHsgbW9kZTogXCJsYXp5XCIsIG1hbmlmZXN0UGF0aDogXCIvX19tYW5pZmVzdFwiIH0sXG4gICAgcm91dGVNb2R1bGVzXG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUlNDUm91dGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdHJ1ZSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUlNDUm91dGVyR2xvYmFsRXJyb3JCb3VuZGFyeSwgeyBsb2NhdGlvbjogbG9jYXRpb24yIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChGcmFtZXdvcmtDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmcmFtZXdvcmtDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChVTlNUQUJMRV9UcmFuc2l0aW9uRW5hYmxlZFJvdXRlclByb3ZpZGVyLCB7IHJvdXRlciwgZmx1c2hTeW5jOiBSZWFjdERPTS5mbHVzaFN5bmMgfSkpKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21TZXJ2ZXJNYW5pZmVzdChtYXRjaCwgcGF5bG9hZCkge1xuICBsZXQgaGFzSW5pdGlhbERhdGEgPSBwYXlsb2FkICYmIG1hdGNoLmlkIGluIHBheWxvYWQubG9hZGVyRGF0YTtcbiAgbGV0IGluaXRpYWxEYXRhID0gcGF5bG9hZD8ubG9hZGVyRGF0YVttYXRjaC5pZF07XG4gIGxldCBoYXNJbml0aWFsRXJyb3IgPSBwYXlsb2FkPy5lcnJvcnMgJiYgbWF0Y2guaWQgaW4gcGF5bG9hZC5lcnJvcnM7XG4gIGxldCBpbml0aWFsRXJyb3IgPSBwYXlsb2FkPy5lcnJvcnM/LlttYXRjaC5pZF07XG4gIGxldCBpc0h5ZHJhdGlvblJlcXVlc3QgPSBtYXRjaC5jbGllbnRMb2FkZXI/Lmh5ZHJhdGUgPT09IHRydWUgfHwgIW1hdGNoLmhhc0xvYWRlciB8fCAvLyBJZiB0aGUgcm91dGUgaGFzIGEgY29tcG9uZW50IGJ1dCB3ZSBkb24ndCBoYXZlIGFuIGVsZW1lbnQsIHdlIG5lZWQgdG8gaGl0XG4gIC8vIHRoZSBzZXJ2ZXIgbG9hZGVyIGZsb3cgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjbGllbnQgbG9hZGVyIGNhbGxzXG4gIC8vIGBzZXJ2ZXJMb2FkZXJgIG9yIG5vdCwgb3RoZXJ3aXNlIHdlJ2xsIGhhdmUgbm90aGluZyB0byByZW5kZXIuXG4gIG1hdGNoLmhhc0NvbXBvbmVudCAmJiAhbWF0Y2guZWxlbWVudDtcbiAgaW52YXJpYW50KHdpbmRvdy5fX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzKTtcbiAgcG9wdWxhdGVSU0NSb3V0ZU1vZHVsZXMod2luZG93Ll9fcmVhY3RSb3V0ZXJSb3V0ZU1vZHVsZXMsIG1hdGNoKTtcbiAgbGV0IGRhdGFSb3V0ZSA9IHtcbiAgICBpZDogbWF0Y2guaWQsXG4gICAgZWxlbWVudDogbWF0Y2guZWxlbWVudCxcbiAgICBlcnJvckVsZW1lbnQ6IG1hdGNoLmVycm9yRWxlbWVudCxcbiAgICBoYW5kbGU6IG1hdGNoLmhhbmRsZSxcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiBtYXRjaC5oYXNFcnJvckJvdW5kYXJ5LFxuICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IG1hdGNoLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQsXG4gICAgaW5kZXg6IG1hdGNoLmluZGV4LFxuICAgIGxvYWRlcjogbWF0Y2guY2xpZW50TG9hZGVyID8gYXN5bmMgKGFyZ3MsIHNpbmdsZUZldGNoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbWF0Y2guY2xpZW50TG9hZGVyKHtcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgIHNlcnZlckxvYWRlcjogKCkgPT4ge1xuICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcbiAgICAgICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICAgICAgbWF0Y2guaWQsXG4gICAgICAgICAgICAgIG1hdGNoLmhhc0xvYWRlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGlvblJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc0luaXRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxEYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoYXNJbml0aWFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsU2luZ2xlRmV0Y2goc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc0h5ZHJhdGlvblJlcXVlc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IDogKFxuICAgICAgLy8gV2UgYWx3YXlzIG1ha2UgdGhlIGNhbGwgaW4gdGhpcyBSU0Mgd29ybGQgc2luY2UgZXZlbiBpZiB3ZSBkb24ndFxuICAgICAgLy8gaGF2ZSBhIGBsb2FkZXJgIHdlIG1heSBuZWVkIHRvIGdldCB0aGUgYGVsZW1lbnRgIGltcGxlbWVudGF0aW9uXG4gICAgICAoXywgc2luZ2xlRmV0Y2gpID0+IGNhbGxTaW5nbGVGZXRjaChzaW5nbGVGZXRjaClcbiAgICApLFxuICAgIGFjdGlvbjogbWF0Y2guY2xpZW50QWN0aW9uID8gKGFyZ3MsIHNpbmdsZUZldGNoKSA9PiBtYXRjaC5jbGllbnRBY3Rpb24oe1xuICAgICAgLi4uYXJncyxcbiAgICAgIHNlcnZlckFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFxuICAgICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgICAgbWF0Y2guaWQsXG4gICAgICAgICAgbWF0Y2guaGFzTG9hZGVyXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhd2FpdCBjYWxsU2luZ2xlRmV0Y2goc2luZ2xlRmV0Y2gpO1xuICAgICAgfVxuICAgIH0pIDogbWF0Y2guaGFzQWN0aW9uID8gKF8sIHNpbmdsZUZldGNoKSA9PiBjYWxsU2luZ2xlRmV0Y2goc2luZ2xlRmV0Y2gpIDogKCkgPT4ge1xuICAgICAgdGhyb3cgbm9BY3Rpb25EZWZpbmVkRXJyb3IoXCJhY3Rpb25cIiwgbWF0Y2guaWQpO1xuICAgIH0sXG4gICAgcGF0aDogbWF0Y2gucGF0aCxcbiAgICBzaG91bGRSZXZhbGlkYXRlOiBtYXRjaC5zaG91bGRSZXZhbGlkYXRlLFxuICAgIC8vIFdlIGFsd2F5cyBoYXZlIGEgXCJsb2FkZXJcIiBpbiB0aGlzIFJTQyB3b3JsZCBzaW5jZSBldmVuIGlmIHdlIGRvbid0XG4gICAgLy8gaGF2ZSBhIGBsb2FkZXJgIHdlIG1heSBuZWVkIHRvIGdldCB0aGUgYGVsZW1lbnRgIGltcGxlbWVudGF0aW9uXG4gICAgaGFzTG9hZGVyOiB0cnVlLFxuICAgIGhhc0NsaWVudExvYWRlcjogbWF0Y2guY2xpZW50TG9hZGVyICE9IG51bGwsXG4gICAgaGFzQWN0aW9uOiBtYXRjaC5oYXNBY3Rpb24sXG4gICAgaGFzQ2xpZW50QWN0aW9uOiBtYXRjaC5jbGllbnRBY3Rpb24gIT0gbnVsbCxcbiAgICBoYXNTaG91bGRSZXZhbGlkYXRlOiBtYXRjaC5zaG91bGRSZXZhbGlkYXRlICE9IG51bGxcbiAgfTtcbiAgaWYgKHR5cGVvZiBkYXRhUm91dGUubG9hZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkYXRhUm91dGUubG9hZGVyLmh5ZHJhdGUgPSBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIoXG4gICAgICBtYXRjaC5pZCxcbiAgICAgIG1hdGNoLmNsaWVudExvYWRlcixcbiAgICAgIG1hdGNoLmhhc0xvYWRlcixcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGF0YVJvdXRlO1xufVxuZnVuY3Rpb24gY2FsbFNpbmdsZUZldGNoKHNpbmdsZUZldGNoKSB7XG4gIGludmFyaWFudCh0eXBlb2Ygc2luZ2xlRmV0Y2ggPT09IFwiZnVuY3Rpb25cIiwgXCJJbnZhbGlkIHNpbmdsZUZldGNoIHBhcmFtZXRlclwiKTtcbiAgcmV0dXJuIHNpbmdsZUZldGNoKCk7XG59XG5mdW5jdGlvbiBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKHR5cGUsIHJvdXRlSWQsIGhhc0hhbmRsZXIpIHtcbiAgaWYgKCFoYXNIYW5kbGVyKSB7XG4gICAgbGV0IGZuID0gdHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwic2VydmVyQWN0aW9uKClcIiA6IFwic2VydmVyTG9hZGVyKClcIjtcbiAgICBsZXQgbXNnID0gYFlvdSBhcmUgdHJ5aW5nIHRvIGNhbGwgJHtmbn0gb24gYSByb3V0ZSB0aGF0IGRvZXMgbm90IGhhdmUgYSBzZXJ2ZXIgJHt0eXBlfSAocm91dGVJZDogXCIke3JvdXRlSWR9XCIpYDtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwMCwgXCJCYWQgUmVxdWVzdFwiLCBuZXcgRXJyb3IobXNnKSwgdHJ1ZSk7XG4gIH1cbn1cbnZhciBuZXh0UGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIGRpc2NvdmVyZWRQYXRoc01heFNpemUgPSAxZTM7XG52YXIgZGlzY292ZXJlZFBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBVUkxfTElNSVQgPSA3NjgwO1xuZnVuY3Rpb24gZ2V0TWFuaWZlc3RVcmwocGF0aHMpIHtcbiAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbmV3IFVSTChgJHtwYXRoc1swXX0ubWFuaWZlc3RgLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgfVxuICBjb25zdCBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGxldCBiYXNlbmFtZSA9IChnbG9iYWxWYXIuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIuYmFzZW5hbWUgPz8gXCJcIikucmVwbGFjZShcbiAgICAvXlxcL3xcXC8kL2csXG4gICAgXCJcIlxuICApO1xuICBsZXQgdXJsID0gbmV3IFVSTChgJHtiYXNlbmFtZX0vLm1hbmlmZXN0YCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicGF0aHNcIiwgcGF0aHMuc29ydCgpLmpvaW4oXCIsXCIpKTtcbiAgcmV0dXJuIHVybDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMocGF0aHMsIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSwgZmV0Y2hJbXBsZW1lbnRhdGlvbiwgc2lnbmFsKSB7XG4gIGxldCB1cmwgPSBnZXRNYW5pZmVzdFVybChwYXRocyk7XG4gIGlmICh1cmwgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodXJsLnRvU3RyaW5nKCkubGVuZ3RoID4gVVJMX0xJTUlUKSB7XG4gICAgbmV4dFBhdGhzLmNsZWFyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoSW1wbGVtZW50YXRpb24obmV3IFJlcXVlc3QodXJsLCB7IHNpZ25hbCB9KSk7XG4gIGlmICghcmVzcG9uc2UuYm9keSB8fCByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDMwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmZXRjaCBuZXcgcm91dGUgbWF0Y2hlcyBmcm9tIHRoZSBzZXJ2ZXJcIik7XG4gIH1cbiAgbGV0IHBheWxvYWQgPSBhd2FpdCBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0ocmVzcG9uc2UuYm9keSwge1xuICAgIHRlbXBvcmFyeVJlZmVyZW5jZXM6IHZvaWQgMFxuICB9KTtcbiAgaWYgKHBheWxvYWQudHlwZSAhPT0gXCJtYW5pZmVzdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhdGNoIHJvdXRlc1wiKTtcbiAgfVxuICBwYXRocy5mb3JFYWNoKChwKSA9PiBhZGRUb0ZpZm9RdWV1ZShwLCBkaXNjb3ZlcmVkUGF0aHMpKTtcbiAgcGF5bG9hZC5wYXRjaGVzLmZvckVhY2goKHApID0+IHtcbiAgICB3aW5kb3cuX19yZWFjdFJvdXRlckRhdGFSb3V0ZXIucGF0Y2hSb3V0ZXMoXG4gICAgICBwLnBhcmVudElkID8/IG51bGwsXG4gICAgICBbY3JlYXRlUm91dGVGcm9tU2VydmVyTWFuaWZlc3QocCldXG4gICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRUb0ZpZm9RdWV1ZShwYXRoLCBxdWV1ZSkge1xuICBpZiAocXVldWUuc2l6ZSA+PSBkaXNjb3ZlcmVkUGF0aHNNYXhTaXplKSB7XG4gICAgbGV0IGZpcnN0ID0gcXVldWUudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgIHF1ZXVlLmRlbGV0ZShmaXJzdCk7XG4gIH1cbiAgcXVldWUuYWRkKHBhdGgpO1xufVxuZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIHdhaXQpIHtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIHRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKC4uLmFyZ3MpLCB3YWl0KTtcbiAgfTtcbn1cblxuLy8gbGliL3JzYy9zZXJ2ZXIuc3NyLnRzeFxuaW1wb3J0ICogYXMgUmVhY3Q1IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBsaWIvcnNjL2h0bWwtc3RyZWFtL3NlcnZlci50c1xudmFyIGVuY29kZXIyID0gbmV3IFRleHRFbmNvZGVyKCk7XG52YXIgdHJhaWxlciA9IFwiPC9ib2R5PjwvaHRtbD5cIjtcbmZ1bmN0aW9uIGluamVjdFJTQ1BheWxvYWQocnNjU3RyZWFtKSB7XG4gIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCByZXNvbHZlRmxpZ2h0RGF0YVByb21pc2U7XG4gIGxldCBmbGlnaHREYXRhUHJvbWlzZSA9IG5ldyBQcm9taXNlKFxuICAgIChyZXNvbHZlKSA9PiByZXNvbHZlRmxpZ2h0RGF0YVByb21pc2UgPSByZXNvbHZlXG4gICk7XG4gIGxldCBzdGFydGVkUlNDID0gZmFsc2U7XG4gIGxldCBidWZmZXJlZCA9IFtdO1xuICBsZXQgdGltZW91dCA9IG51bGw7XG4gIGZ1bmN0aW9uIGZsdXNoQnVmZmVyZWRDaHVua3MoY29udHJvbGxlcikge1xuICAgIGZvciAobGV0IGNodW5rIG9mIGJ1ZmZlcmVkKSB7XG4gICAgICBsZXQgYnVmID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgaWYgKGJ1Zi5lbmRzV2l0aCh0cmFpbGVyKSkge1xuICAgICAgICBidWYgPSBidWYuc2xpY2UoMCwgLXRyYWlsZXIubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyMi5lbmNvZGUoYnVmKSk7XG4gICAgfVxuICAgIGJ1ZmZlcmVkLmxlbmd0aCA9IDA7XG4gICAgdGltZW91dCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgYnVmZmVyZWQucHVzaChjaHVuayk7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIGZsdXNoQnVmZmVyZWRDaHVua3MoY29udHJvbGxlcik7XG4gICAgICAgIGlmICghc3RhcnRlZFJTQykge1xuICAgICAgICAgIHN0YXJ0ZWRSU0MgPSB0cnVlO1xuICAgICAgICAgIHdyaXRlUlNDU3RyZWFtKHJzY1N0cmVhbSwgY29udHJvbGxlcikuY2F0Y2goKGVycikgPT4gY29udHJvbGxlci5lcnJvcihlcnIpKS50aGVuKHJlc29sdmVGbGlnaHREYXRhUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgYXdhaXQgZmxpZ2h0RGF0YVByb21pc2U7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGZsdXNoQnVmZmVyZWRDaHVua3MoY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlcjIuZW5jb2RlKFwiPC9ib2R5PjwvaHRtbD5cIikpO1xuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZVJTQ1N0cmVhbShyc2NTdHJlYW0sIGNvbnRyb2xsZXIpIHtcbiAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7IGZhdGFsOiB0cnVlIH0pO1xuICBjb25zdCByZWFkZXIgPSByc2NTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHRyeSB7XG4gICAgbGV0IHJlYWQ7XG4gICAgd2hpbGUgKChyZWFkID0gYXdhaXQgcmVhZGVyLnJlYWQoKSkgJiYgIXJlYWQuZG9uZSkge1xuICAgICAgY29uc3QgY2h1bmsgPSByZWFkLnZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkpLFxuICAgICAgICAgIGNvbnRyb2xsZXJcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsZXQgYmFzZTY0ID0gSlNPTi5zdHJpbmdpZnkoYnRvYShTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jaHVuaykpKTtcbiAgICAgICAgd3JpdGVDaHVuayhcbiAgICAgICAgICBgVWludDhBcnJheS5mcm9tKGF0b2IoJHtiYXNlNjR9KSwgbSA9PiBtLmNvZGVQb2ludEF0KDApKWAsXG4gICAgICAgICAgY29udHJvbGxlclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgfVxuICBsZXQgcmVtYWluaW5nID0gZGVjb2Rlci5kZWNvZGUoKTtcbiAgaWYgKHJlbWFpbmluZy5sZW5ndGgpIHtcbiAgICB3cml0ZUNodW5rKEpTT04uc3RyaW5naWZ5KHJlbWFpbmluZyksIGNvbnRyb2xsZXIpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZUNodW5rKGNodW5rLCBjb250cm9sbGVyKSB7XG4gIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICBlbmNvZGVyMi5lbmNvZGUoXG4gICAgICBgPHNjcmlwdD4ke2VzY2FwZVNjcmlwdChcbiAgICAgICAgYChzZWxmLl9fRkxJR0hUX0RBVEF8fD1bXSkucHVzaCgke2NodW5rfSlgXG4gICAgICApfTwvc2NyaXB0PmBcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVTY3JpcHQoc2NyaXB0KSB7XG4gIHJldHVybiBzY3JpcHQucmVwbGFjZSgvPCEtLS9nLCBcIjxcXFxcIS0tXCIpLnJlcGxhY2UoLzxcXC8oc2NyaXB0KS9naSwgXCI8L1xcXFwkMVwiKTtcbn1cblxuLy8gbGliL3JzYy9zZXJ2ZXIuc3NyLnRzeFxudmFyIFJFQUNUX1VTRSA9IFwidXNlXCI7XG52YXIgdXNlSW1wbCA9IFJlYWN0NVtSRUFDVF9VU0VdO1xuZnVuY3Rpb24gdXNlU2FmZShwcm9taXNlKSB7XG4gIGlmICh1c2VJbXBsKSB7XG4gICAgcmV0dXJuIHVzZUltcGwocHJvbWlzZSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QgUm91dGVyIHY3IHJlcXVpcmVzIFJlYWN0IDE5KyBmb3IgUlNDIGZlYXR1cmVzLlwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJvdXRlUlNDU2VydmVyUmVxdWVzdCh7XG4gIHJlcXVlc3QsXG4gIGZldGNoU2VydmVyLFxuICBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0sXG4gIHJlbmRlckhUTUwsXG4gIGh5ZHJhdGUgPSB0cnVlXG59KSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBjb25zdCBpc0RhdGFSZXF1ZXN0ID0gaXNSZWFjdFNlcnZlclJlcXVlc3QodXJsKTtcbiAgY29uc3QgcmVzcG9uZFdpdGhSU0NQYXlsb2FkID0gaXNEYXRhUmVxdWVzdCB8fCBpc01hbmlmZXN0UmVxdWVzdCh1cmwpIHx8IHJlcXVlc3QuaGVhZGVycy5oYXMoXCJyc2MtYWN0aW9uLWlkXCIpO1xuICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoU2VydmVyKHJlcXVlc3QpO1xuICBpZiAocmVzcG9uZFdpdGhSU0NQYXlsb2FkIHx8IHNlcnZlclJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiUmVhY3QtUm91dGVyLVJlc291cmNlXCIpID09PSBcInRydWVcIikge1xuICAgIHJldHVybiBzZXJ2ZXJSZXNwb25zZTtcbiAgfVxuICBpZiAoIXNlcnZlclJlc3BvbnNlLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGJvZHkgaW4gc2VydmVyIHJlc3BvbnNlXCIpO1xuICB9XG4gIGNvbnN0IGRldGVjdFJlZGlyZWN0UmVzcG9uc2UgPSBzZXJ2ZXJSZXNwb25zZS5jbG9uZSgpO1xuICBsZXQgc2VydmVyUmVzcG9uc2VCID0gbnVsbDtcbiAgaWYgKGh5ZHJhdGUpIHtcbiAgICBzZXJ2ZXJSZXNwb25zZUIgPSBzZXJ2ZXJSZXNwb25zZS5jbG9uZSgpO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBzZXJ2ZXJSZXNwb25zZS5ib2R5O1xuICBsZXQgYnVmZmVyO1xuICBsZXQgc3RyZWFtQ29udHJvbGxlcnMgPSBbXTtcbiAgY29uc3QgY3JlYXRlU3RyZWFtID0gKCkgPT4ge1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSBbXTtcbiAgICAgIHJldHVybiBib2R5LnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICBzdHJlYW1Db250cm9sbGVycy5mb3JFYWNoKChjKSA9PiBjLmVucXVldWUoY2h1bmspKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZsdXNoKCkge1xuICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlcnMuZm9yRWFjaCgoYykgPT4gYy5jbG9zZSgpKTtcbiAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXJzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIGJ1ZmZlci5mb3JFYWNoKChjaHVuaykgPT4gY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKSk7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGxldCBkZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkID0gbnVsbDtcbiAgY29uc3QgZ2V0UGF5bG9hZCA9ICgpID0+IHtcbiAgICBjb25zdCBwYXlsb2FkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShcbiAgICAgIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbShjcmVhdGVTdHJlYW0oKSlcbiAgICApO1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwYXlsb2FkUHJvbWlzZSwge1xuICAgICAgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQ6IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBkZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoYm91bmRhcnlJZCkge1xuICAgICAgICAgIGRlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBib3VuZGFyeUlkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZm9ybVN0YXRlOiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcGF5bG9hZFByb21pc2UudGhlbihcbiAgICAgICAgICAgIChwYXlsb2FkKSA9PiBwYXlsb2FkLnR5cGUgPT09IFwicmVuZGVyXCIgPyBwYXlsb2FkLmZvcm1TdGF0ZSA6IHZvaWQgMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgdHJ5IHtcbiAgICBpZiAoIWRldGVjdFJlZGlyZWN0UmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNsb25lIHNlcnZlciByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbShcbiAgICAgIGRldGVjdFJlZGlyZWN0UmVzcG9uc2UuYm9keVxuICAgICk7XG4gICAgaWYgKHNlcnZlclJlc3BvbnNlLnN0YXR1cyA9PT0gU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyAmJiBwYXlsb2FkLnR5cGUgPT09IFwicmVkaXJlY3RcIikge1xuICAgICAgY29uc3QgaGVhZGVyczIgPSBuZXcgSGVhZGVycyhzZXJ2ZXJSZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgIGhlYWRlcnMyLmRlbGV0ZShcIkNvbnRlbnQtRW5jb2RpbmdcIik7XG4gICAgICBoZWFkZXJzMi5kZWxldGUoXCJDb250ZW50LUxlbmd0aFwiKTtcbiAgICAgIGhlYWRlcnMyLmRlbGV0ZShcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgIGhlYWRlcnMyLmRlbGV0ZShcIlgtUmVtaXgtUmVzcG9uc2VcIik7XG4gICAgICBoZWFkZXJzMi5zZXQoXCJMb2NhdGlvblwiLCBwYXlsb2FkLmxvY2F0aW9uKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2Uoc2VydmVyUmVzcG9uc2VCPy5ib2R5IHx8IFwiXCIsIHtcbiAgICAgICAgaGVhZGVyczogaGVhZGVyczIsXG4gICAgICAgIHN0YXR1czogcGF5bG9hZC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHNlcnZlclJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBodG1sID0gYXdhaXQgcmVuZGVySFRNTChnZXRQYXlsb2FkKTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc2VydmVyUmVzcG9uc2UuaGVhZGVycyk7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLThcIik7XG4gICAgaWYgKCFoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGh0bWwsIHtcbiAgICAgICAgc3RhdHVzOiBzZXJ2ZXJSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXNlcnZlclJlc3BvbnNlQj8uYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNsb25lIHNlcnZlciByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgY29uc3QgYm9keTIgPSBodG1sLnBpcGVUaHJvdWdoKGluamVjdFJTQ1BheWxvYWQoc2VydmVyUmVzcG9uc2VCLmJvZHkpKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHkyLCB7XG4gICAgICBzdGF0dXM6IHNlcnZlclJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcmVhc29uO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdHVzID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVhc29uKSA/IHJlYXNvbi5zdGF0dXMgOiA1MDA7XG4gICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVuZGVySFRNTCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtKGNyZWF0ZVN0cmVhbSgpKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwYXlsb2FkUHJvbWlzZSA9IGRlY29kZWQudGhlbihcbiAgICAgICAgICAocGF5bG9hZCkgPT4gT2JqZWN0LmFzc2lnbihwYXlsb2FkLCB7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBlcnJvcnM6IGRlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPyB7XG4gICAgICAgICAgICAgIFtkZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkXTogcmVhc29uXG4gICAgICAgICAgICB9IDoge31cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocGF5bG9hZFByb21pc2UsIHtcbiAgICAgICAgICBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZDoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoYm91bmRhcnlJZCkge1xuICAgICAgICAgICAgICBkZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkID0gYm91bmRhcnlJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcm1TdGF0ZToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZFByb21pc2UudGhlbihcbiAgICAgICAgICAgICAgICAocGF5bG9hZCkgPT4gcGF5bG9hZC50eXBlID09PSBcInJlbmRlclwiID8gcGF5bG9hZC5mb3JtU3RhdGUgOiB2b2lkIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc2VydmVyUmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvaHRtbFwiKTtcbiAgICAgIGlmICghaHlkcmF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGh0bWwsIHtcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghc2VydmVyUmVzcG9uc2VCPy5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjbG9uZSBzZXJ2ZXIgcmVzcG9uc2VcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5MiA9IGh0bWwucGlwZVRocm91Z2goaW5qZWN0UlNDUGF5bG9hZChzZXJ2ZXJSZXNwb25zZUIuYm9keSkpO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5Miwge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICB0aHJvdyByZWFzb247XG4gIH1cbn1cbmZ1bmN0aW9uIFJTQ1N0YXRpY1JvdXRlcih7IGdldFBheWxvYWQgfSkge1xuICBjb25zdCBkZWNvZGVkID0gZ2V0UGF5bG9hZCgpO1xuICBjb25zdCBwYXlsb2FkID0gdXNlU2FmZShkZWNvZGVkKTtcbiAgaWYgKHBheWxvYWQudHlwZSA9PT0gXCJyZWRpcmVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgIHN0YXR1czogcGF5bG9hZC5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIExvY2F0aW9uOiBwYXlsb2FkLmxvY2F0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKHBheWxvYWQudHlwZSAhPT0gXCJyZW5kZXJcIikgcmV0dXJuIG51bGw7XG4gIGxldCBwYXRjaGVkTG9hZGVyRGF0YSA9IHsgLi4ucGF5bG9hZC5sb2FkZXJEYXRhIH07XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgcGF5bG9hZC5tYXRjaGVzKSB7XG4gICAgaWYgKHNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcihcbiAgICAgIG1hdGNoLmlkLFxuICAgICAgbWF0Y2guY2xpZW50TG9hZGVyLFxuICAgICAgbWF0Y2guaGFzTG9hZGVyLFxuICAgICAgZmFsc2VcbiAgICApICYmIChtYXRjaC5oeWRyYXRlRmFsbGJhY2tFbGVtZW50IHx8ICFtYXRjaC5oYXNMb2FkZXIpKSB7XG4gICAgICBkZWxldGUgcGF0Y2hlZExvYWRlckRhdGFbbWF0Y2guaWRdO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIGdldCBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCgpIHtcbiAgICAgIHJldHVybiBkZWNvZGVkLl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkID8/IG51bGw7XG4gICAgfSxcbiAgICBzZXQgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQoYm91bmRhcnlJZCkge1xuICAgICAgZGVjb2RlZC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IGJvdW5kYXJ5SWQ7XG4gICAgfSxcbiAgICBhY3Rpb25EYXRhOiBwYXlsb2FkLmFjdGlvbkRhdGEsXG4gICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgYmFzZW5hbWU6IHBheWxvYWQuYmFzZW5hbWUsXG4gICAgZXJyb3JzOiBwYXlsb2FkLmVycm9ycyxcbiAgICBsb2FkZXJEYXRhOiBwYXRjaGVkTG9hZGVyRGF0YSxcbiAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICBsb2NhdGlvbjogcGF5bG9hZC5sb2NhdGlvbixcbiAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgbWF0Y2hlczogcGF5bG9hZC5tYXRjaGVzLm1hcCgobWF0Y2gpID0+ICh7XG4gICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbWF0Y2gucGF0aG5hbWVCYXNlLFxuICAgICAgcm91dGU6IHtcbiAgICAgICAgaWQ6IG1hdGNoLmlkLFxuICAgICAgICBhY3Rpb246IG1hdGNoLmhhc0FjdGlvbiB8fCAhIW1hdGNoLmNsaWVudEFjdGlvbixcbiAgICAgICAgaGFuZGxlOiBtYXRjaC5oYW5kbGUsXG4gICAgICAgIGhhc0Vycm9yQm91bmRhcnk6IG1hdGNoLmhhc0Vycm9yQm91bmRhcnksXG4gICAgICAgIGxvYWRlcjogbWF0Y2guaGFzTG9hZGVyIHx8ICEhbWF0Y2guY2xpZW50TG9hZGVyLFxuICAgICAgICBpbmRleDogbWF0Y2guaW5kZXgsXG4gICAgICAgIHBhdGg6IG1hdGNoLnBhdGgsXG4gICAgICAgIHNob3VsZFJldmFsaWRhdGU6IG1hdGNoLnNob3VsZFJldmFsaWRhdGVcbiAgICAgIH1cbiAgICB9KSlcbiAgfTtcbiAgY29uc3Qgcm91dGVyID0gY3JlYXRlU3RhdGljUm91dGVyKFxuICAgIHBheWxvYWQubWF0Y2hlcy5yZWR1Y2VSaWdodCgocHJldmlvdXMsIG1hdGNoKSA9PiB7XG4gICAgICBjb25zdCByb3V0ZSA9IHtcbiAgICAgICAgaWQ6IG1hdGNoLmlkLFxuICAgICAgICBhY3Rpb246IG1hdGNoLmhhc0FjdGlvbiB8fCAhIW1hdGNoLmNsaWVudEFjdGlvbixcbiAgICAgICAgZWxlbWVudDogbWF0Y2guZWxlbWVudCxcbiAgICAgICAgZXJyb3JFbGVtZW50OiBtYXRjaC5lcnJvckVsZW1lbnQsXG4gICAgICAgIGhhbmRsZTogbWF0Y2guaGFuZGxlLFxuICAgICAgICBoYXNFcnJvckJvdW5kYXJ5OiAhIW1hdGNoLmVycm9yRWxlbWVudCxcbiAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDogbWF0Y2guaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCxcbiAgICAgICAgaW5kZXg6IG1hdGNoLmluZGV4LFxuICAgICAgICBsb2FkZXI6IG1hdGNoLmhhc0xvYWRlciB8fCAhIW1hdGNoLmNsaWVudExvYWRlcixcbiAgICAgICAgcGF0aDogbWF0Y2gucGF0aCxcbiAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogbWF0Y2guc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgfTtcbiAgICAgIGlmIChwcmV2aW91cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJvdXRlLmNoaWxkcmVuID0gcHJldmlvdXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3JvdXRlXTtcbiAgICB9LCBbXSksXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCBmcmFtZXdvcmtDb250ZXh0ID0ge1xuICAgIGZ1dHVyZToge1xuICAgICAgLy8gVGhlc2UgZmxhZ3MgaGF2ZSBubyBydW50aW1lIGltcGFjdCBzbyBjYW4gYWx3YXlzIGJlIGZhbHNlLiAgSWYgd2UgYWRkXG4gICAgICAvLyBmbGFncyB0aGF0IGRyaXZlIHJ1bnRpbWUgYmVoYXZpb3IgdGhleSdsbCBuZWVkIHRvIGJlIHByb3hpZWQgdGhyb3VnaC5cbiAgICAgIHY4X21pZGRsZXdhcmU6IGZhbHNlLFxuICAgICAgdW5zdGFibGVfc3ViUmVzb3VyY2VJbnRlZ3JpdHk6IGZhbHNlXG4gICAgfSxcbiAgICBpc1NwYU1vZGU6IGZhbHNlLFxuICAgIHNzcjogdHJ1ZSxcbiAgICBjcml0aWNhbENzczogXCJcIixcbiAgICBtYW5pZmVzdDoge1xuICAgICAgcm91dGVzOiB7fSxcbiAgICAgIHZlcnNpb246IFwiMVwiLFxuICAgICAgdXJsOiBcIlwiLFxuICAgICAgZW50cnk6IHtcbiAgICAgICAgbW9kdWxlOiBcIlwiLFxuICAgICAgICBpbXBvcnRzOiBbXVxuICAgICAgfVxuICAgIH0sXG4gICAgcm91dGVEaXNjb3Zlcnk6IHsgbW9kZTogXCJsYXp5XCIsIG1hbmlmZXN0UGF0aDogXCIvX19tYW5pZmVzdFwiIH0sXG4gICAgcm91dGVNb2R1bGVzOiBjcmVhdGVSU0NSb3V0ZU1vZHVsZXMocGF5bG9hZClcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChSU0NSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0cnVlIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChSU0NSb3V0ZXJHbG9iYWxFcnJvckJvdW5kYXJ5LCB7IGxvY2F0aW9uOiBwYXlsb2FkLmxvY2F0aW9uIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChGcmFtZXdvcmtDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBmcmFtZXdvcmtDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgICB7XG4gICAgICBjb250ZXh0LFxuICAgICAgcm91dGVyLFxuICAgICAgaHlkcmF0ZTogZmFsc2UsXG4gICAgICBub25jZTogcGF5bG9hZC5ub25jZVxuICAgIH1cbiAgKSkpKTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RTZXJ2ZXJSZXF1ZXN0KHVybCkge1xuICByZXR1cm4gdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLnJzY1wiKTtcbn1cbmZ1bmN0aW9uIGlzTWFuaWZlc3RSZXF1ZXN0KHVybCkge1xuICByZXR1cm4gdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLm1hbmlmZXN0XCIpO1xufVxuXG4vLyBsaWIvcnNjL2h0bWwtc3RyZWFtL2Jyb3dzZXIudHNcbmZ1bmN0aW9uIGdldFJTQ1N0cmVhbSgpIHtcbiAgbGV0IGVuY29kZXIzID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBzdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgbGV0IHJzY1N0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGhhbmRsZUNodW5rID0gKGNodW5rKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlcjMuZW5jb2RlKGNodW5rKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5fX0ZMSUdIVF9EQVRBIHx8ICh3aW5kb3cuX19GTElHSFRfREFUQSA9IFtdKTtcbiAgICAgIHdpbmRvdy5fX0ZMSUdIVF9EQVRBLmZvckVhY2goaGFuZGxlQ2h1bmspO1xuICAgICAgd2luZG93Ll9fRkxJR0hUX0RBVEEucHVzaCA9IChjaHVuaykgPT4ge1xuICAgICAgICBoYW5kbGVDaHVuayhjaHVuayk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiB7XG4gICAgICBzdHJlYW1Db250cm9sbGVyPy5jbG9zZSgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbUNvbnRyb2xsZXI/LmNsb3NlKCk7XG4gIH1cbiAgcmV0dXJuIHJzY1N0cmVhbTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZXJyb3JzLnRzXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IHZhbC5zdGFjaztcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5zdGFjayA9IHZhbC5zdGFjaztcbiAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbmV4cG9ydCB7XG4gIFNlcnZlclJvdXRlcixcbiAgY3JlYXRlUm91dGVzU3R1YixcbiAgY3JlYXRlQ29va2llLFxuICBpc0Nvb2tpZSxcbiAgU2VydmVyTW9kZSxcbiAgc2V0RGV2U2VydmVySG9va3MsXG4gIGNyZWF0ZVJlcXVlc3RIYW5kbGVyLFxuICBjcmVhdGVTZXNzaW9uLFxuICBpc1Nlc3Npb24sXG4gIGNyZWF0ZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UsXG4gIGhyZWYsXG4gIGdldEh5ZHJhdGlvbkRhdGEsXG4gIFJTQ0RlZmF1bHRSb290RXJyb3JCb3VuZGFyeSxcbiAgY3JlYXRlQ2FsbFNlcnZlcixcbiAgUlNDSHlkcmF0ZWRSb3V0ZXIsXG4gIHJvdXRlUlNDU2VydmVyUmVxdWVzdCxcbiAgUlNDU3RhdGljUm91dGVyLFxuICBnZXRSU0NTdHJlYW0sXG4gIGRlc2VyaWFsaXplRXJyb3JzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/chunk-65XJMMLO.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router/dist/development/chunk-NISHYRIK.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/react-router/dist/development/chunk-NISHYRIK.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   AwaitContextProvider: () => (/* binding */ AwaitContextProvider),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   CRITICAL_CSS_DATA_ATTRIBUTE: () => (/* binding */ CRITICAL_CSS_DATA_ATTRIBUTE),\n/* harmony export */   DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   ENABLE_DEV_WARNINGS: () => (/* binding */ ENABLE_DEV_WARNINGS),\n/* harmony export */   ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   FetchersContext: () => (/* binding */ FetchersContext),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   FrameworkContext: () => (/* binding */ FrameworkContext),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),\n/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   Links: () => (/* binding */ Links),\n/* harmony export */   LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Meta: () => (/* binding */ Meta),\n/* harmony export */   NO_BODY_STATUS_CODES: () => (/* binding */ NO_BODY_STATUS_CODES),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   PrefetchPageLinks: () => (/* binding */ PrefetchPageLinks),\n/* harmony export */   RSCRouterContext: () => (/* binding */ RSCRouterContext),\n/* harmony export */   RemixErrorBoundary: () => (/* binding */ RemixErrorBoundary),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterContextProvider: () => (/* binding */ RouterContextProvider),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   SINGLE_FETCH_REDIRECT_STATUS: () => (/* binding */ SINGLE_FETCH_REDIRECT_STATUS),\n/* harmony export */   Scripts: () => (/* binding */ Scripts),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   SingleFetchRedirectSymbol: () => (/* binding */ SingleFetchRedirectSymbol),\n/* harmony export */   StaticRouter: () => (/* binding */ StaticRouter),\n/* harmony export */   StaticRouterProvider: () => (/* binding */ StaticRouterProvider),\n/* harmony export */   StreamTransfer: () => (/* binding */ StreamTransfer),\n/* harmony export */   UNSTABLE_TransitionEnabledRouterProvider: () => (/* binding */ UNSTABLE_TransitionEnabledRouterProvider),\n/* harmony export */   ViewTransitionContext: () => (/* binding */ ViewTransitionContext),\n/* harmony export */   WithComponentProps: () => (/* binding */ WithComponentProps),\n/* harmony export */   WithErrorBoundaryProps: () => (/* binding */ WithErrorBoundaryProps),\n/* harmony export */   WithHydrateFallbackProps: () => (/* binding */ WithHydrateFallbackProps),\n/* harmony export */   convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createClientRoutes: () => (/* binding */ createClientRoutes),\n/* harmony export */   createClientRoutesWithHMRRevalidationOptOut: () => (/* binding */ createClientRoutesWithHMRRevalidationOptOut),\n/* harmony export */   createContext: () => (/* binding */ createContext),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   createRequestInit: () => (/* binding */ createRequestInit),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   createServerRoutes: () => (/* binding */ createServerRoutes),\n/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler),\n/* harmony export */   createStaticHandler2: () => (/* binding */ createStaticHandler2),\n/* harmony export */   createStaticRouter: () => (/* binding */ createStaticRouter),\n/* harmony export */   data: () => (/* binding */ data),\n/* harmony export */   decodeViaTurboStream: () => (/* binding */ decodeViaTurboStream),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   escapeHtml: () => (/* binding */ escapeHtml),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   getManifestPath: () => (/* binding */ getManifestPath),\n/* harmony export */   getPatchRoutesOnNavigationFunction: () => (/* binding */ getPatchRoutesOnNavigationFunction),\n/* harmony export */   getSingleFetchDataStrategyImpl: () => (/* binding */ getSingleFetchDataStrategyImpl),\n/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),\n/* harmony export */   getTurboStreamSingleFetchDataStrategy: () => (/* binding */ getTurboStreamSingleFetchDataStrategy),\n/* harmony export */   hydrationRouteProperties: () => (/* binding */ hydrationRouteProperties),\n/* harmony export */   invariant: () => (/* binding */ invariant),\n/* harmony export */   isDataWithResponseInit: () => (/* binding */ isDataWithResponseInit),\n/* harmony export */   isMutationMethod: () => (/* binding */ isMutationMethod),\n/* harmony export */   isRedirectResponse: () => (/* binding */ isRedirectResponse),\n/* harmony export */   isRedirectStatusCode: () => (/* binding */ isRedirectStatusCode),\n/* harmony export */   isResponse: () => (/* binding */ isResponse),\n/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   mapRouteProperties: () => (/* binding */ mapRouteProperties),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   noActionDefinedError: () => (/* binding */ noActionDefinedError),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   redirect: () => (/* binding */ redirect),\n/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   setIsHydrated: () => (/* binding */ setIsHydrated),\n/* harmony export */   shouldHydrateRouteLoader: () => (/* binding */ shouldHydrateRouteLoader),\n/* harmony export */   singleFetchUrl: () => (/* binding */ singleFetchUrl),\n/* harmony export */   stripBasename: () => (/* binding */ stripBasename),\n/* harmony export */   stripIndexParam: () => (/* binding */ stripIndexParam),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* binding */ useBlocker),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFogOFWarDiscovery: () => (/* binding */ useFogOFWarDiscovery),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes),\n/* harmony export */   useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit),\n/* harmony export */   useViewTransitionState: () => (/* binding */ useViewTransitionState),\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce),\n/* harmony export */   withComponentProps: () => (/* binding */ withComponentProps),\n/* harmony export */   withErrorBoundaryProps: () => (/* binding */ withErrorBoundaryProps),\n/* harmony export */   withHydrateFallbackProps: () => (/* binding */ withHydrateFallbackProps)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * react-router v7.9.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n\n// lib/router/history.ts\nvar Action = /* @__PURE__ */ ((Action2) => {\n  Action2[\"Pop\"] = \"POP\";\n  Action2[\"Push\"] = \"PUSH\";\n  Action2[\"Replace\"] = \"REPLACE\";\n  return Action2;\n})(Action || {});\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options = {}) {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries;\n  entries = initialEntries.map(\n    (entry, index2) => createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index2 === 0 ? \"default\" : void 0\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = \"POP\" /* Pop */;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state = null, key) {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n  function createHref2(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref: createHref2,\n    createURL(to) {\n      return new URL(createHref2(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = \"PUSH\" /* Push */;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 1 });\n      }\n    },\n    replace(to, state) {\n      action = \"REPLACE\" /* Replace */;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 0 });\n      }\n    },\n    go(delta) {\n      action = \"POP\" /* Pop */;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({ action, location: nextLocation, delta });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\nfunction createBrowserHistory(options = {}) {\n  function createBrowserLocation(window2, globalHistory) {\n    let { pathname, search, hash } = window2.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createBrowserHref(window2, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\nfunction createHashHistory(options = {}) {\n  function createHashLocation(window2, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window2.location.hash.substring(1));\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      globalHistory.state && globalHistory.state.usr || null,\n      globalHistory.state && globalHistory.state.key || \"default\"\n    );\n  }\n  function createHashHref(window2, to) {\n    let base = window2.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window2.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      throw new Error(message);\n    } catch (e) {\n    }\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substring(2, 10);\n}\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\nfunction createLocation(current, to, state = null, key) {\n  let location = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...typeof to === \"string\" ? parsePath(to) : to,\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  };\n  return location;\n}\nfunction createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\"\n}) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substring(hashIndex);\n      path = path.substring(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substring(searchIndex);\n      path = path.substring(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {\n  let { window: window2 = document.defaultView, v5Compat = false } = options;\n  let globalHistory = window2.history;\n  let action = \"POP\" /* Pop */;\n  let listener = null;\n  let index = getIndex();\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n  function handlePop() {\n    action = \"POP\" /* Pop */;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n  function push(to, state) {\n    action = \"PUSH\" /* Push */;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      window2.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n  function replace2(to, state) {\n    action = \"REPLACE\" /* Replace */;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n  function createURL(to) {\n    return createBrowserURLImpl(to);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window2, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window2.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window2.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref2(window2, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace: replace2,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\nfunction createBrowserURLImpl(to, isAbsolute = false) {\n  let base = \"http://localhost\";\n  if (typeof window !== \"undefined\") {\n    base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n  }\n  invariant(base, \"No window.location.(origin|href) available to create URL\");\n  let href = typeof to === \"string\" ? to : createPath(to);\n  href = href.replace(/ $/, \"%20\");\n  if (!isAbsolute && href.startsWith(\"//\")) {\n    href = base + href;\n  }\n  return new URL(href, base);\n}\n\n// lib/router/utils.ts\nfunction createContext(defaultValue) {\n  return { defaultValue };\n}\nvar _map;\nvar RouterContextProvider = class {\n  /**\n   * Create a new `RouterContextProvider` instance\n   * @param init An optional initial context map to populate the provider with\n   */\n  constructor(init) {\n    __privateAdd(this, _map, /* @__PURE__ */ new Map());\n    if (init) {\n      for (let [context, value] of init) {\n        this.set(context, value);\n      }\n    }\n  }\n  /**\n   * Access a value from the context. If no value has been set for the context,\n   * it will return the context's `defaultValue` if provided, or throw an error\n   * if no `defaultValue` was set.\n   * @param context The context to get the value for\n   * @returns The value for the context, or the context's `defaultValue` if no\n   * value was set\n   */\n  get(context) {\n    if (__privateGet(this, _map).has(context)) {\n      return __privateGet(this, _map).get(context);\n    }\n    if (context.defaultValue !== void 0) {\n      return context.defaultValue;\n    }\n    throw new Error(\"No value found for context\");\n  }\n  /**\n   * Set a value for the context. If the context already has a value set, this\n   * will overwrite it.\n   *\n   * @param context The context to set the value for\n   * @param value The value to set for the context\n   * @returns {void}\n   */\n  set(context, value) {\n    __privateGet(this, _map).set(context, value);\n  }\n};\n_map = new WeakMap();\nvar unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"children\"\n]);\nfunction isUnsupportedLazyRouteObjectKey(key) {\n  return unsupportedLazyRouteObjectKeys.has(\n    key\n  );\n}\nvar unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"middleware\",\n  \"children\"\n]);\nfunction isUnsupportedLazyRouteFunctionKey(key) {\n  return unsupportedLazyRouteFunctionKeys.has(\n    key\n  );\n}\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}, allowInPlaceMutations = false) {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, String(index)];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      allowInPlaceMutations || !manifest[id],\n      `Found a route id collision on id \"${id}\".  Route id's must be globally unique within Data Router usages`\n    );\n    if (isIndexRoute(route)) {\n      let indexRoute = {\n        ...route,\n        ...mapRouteProperties2(route),\n        id\n      };\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = {\n        ...route,\n        ...mapRouteProperties2(route),\n        id,\n        children: void 0\n      };\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(\n          route.children,\n          mapRouteProperties2,\n          treePath,\n          manifest,\n          allowInPlaceMutations\n        );\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\nfunction matchRoutes(routes, locationArg, basename = \"/\") {\n  return matchRoutesImpl(routes, locationArg, basename, false);\n}\nfunction matchRoutesImpl(routes, locationArg, basename, allowPartial) {\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    let decoded = decodePath(pathname);\n    matches = matchRouteBranch(\n      branches[i],\n      decoded,\n      allowPartial\n    );\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    loaderData: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = \"\", _hasParentOptionalSegments = false) {\n  let flattenRoute = (route, index, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {\n    let meta = {\n      relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {\n        return;\n      }\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path \"${parentPath}\" is not valid. An absolute child route path must start with the combined path of all its parent routes.`\n      );\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove all child routes from route path \"${path}\".`\n      );\n      flattenRoutes(\n        route.children,\n        branches,\n        routesMeta,\n        path,\n        hasParentOptionalSegments\n      );\n    }\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, true, exploded);\n      }\n    }\n  });\n  return branches;\n}\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  let isOptional = first.endsWith(\"?\");\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  result.push(\n    ...restExploded.map(\n      (subpath) => subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  return result.map(\n    (exploded) => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\nfunction rankRouteBranches(branches) {\n  branches.sort(\n    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(\n      a.routesMeta.map((meta) => meta.childrenIndex),\n      b.routesMeta.map((meta) => meta.childrenIndex)\n    )\n  );\n}\nvar paramRe = /^:[\\w-]+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s) => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter((s) => !isSplat(s)).reduce(\n    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue),\n    initialScore\n  );\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ? (\n    // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1]\n  ) : (\n    // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0\n  );\n}\nfunction matchRouteBranch(branch, pathname, allowPartial = false) {\n  let { routesMeta } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n    let route = meta.route;\n    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {\n      match = matchPath(\n        {\n          path: meta.relativePath,\n          caseSensitive: meta.caseSensitive,\n          end: false\n        },\n        remainingPathname\n      );\n    }\n    if (!match) {\n      return null;\n    }\n    Object.assign(matchedParams, match.params);\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\nfunction generatePath(originalPath, params = {}) {\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify2 = (p) => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      return stringify2(params[star]);\n    }\n    const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n      return encodeURIComponent(stringify2(param));\n    }\n    return segment.replace(/\\?$/g, \"\");\n  }).filter((segment) => !!segment);\n  return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n  let [matcher, compiledParams] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce(\n    (memo2, { paramName, isOptional }, index) => {\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n      }\n      const value = captureGroups[index];\n      if (isOptional && !value) {\n        memo2[paramName] = void 0;\n      } else {\n        memo2[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n      }\n      return memo2;\n    },\n    {}\n  );\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive = false, end = true) {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(\n    /\\/:([\\w-]+)(\\?)?/g,\n    (_, paramName, isOptional) => {\n      params.push({ paramName, isOptional: isOptional != null });\n      return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    }\n  ).replace(/\\/([\\w-]+)\\?(\\/|$)/g, \"(/$1)?$2\");\n  if (path.endsWith(\"*\")) {\n    params.push({ paramName: \"*\" });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n  } else if (end) {\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n  }\n  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n  return [matcher, params];\n}\nfunction decodePath(value) {\n  try {\n    return value.split(\"/\").map((v) => decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`\n    );\n    return value;\n  }\n}\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\nfunction prependBasename({\n  basename,\n  pathname\n}) {\n  return pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n}\nfunction resolvePath(to, fromPathname = \"/\") {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return `Cannot include a '${char}' character in a manually specified \\`to.${field}\\` field [${JSON.stringify(\n    path\n  )}].  Please separate it out to the \\`to.${dest}\\` field. Alternatively you may provide the full path as a string in <Link to=\"...\"> and the router will parse it for you.`;\n}\nfunction getPathContributingMatches(matches) {\n  return matches.filter(\n    (match, index) => index === 0 || match.route.path && match.route.path.length > 0\n  );\n}\nfunction getResolveToMatches(matches) {\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches.map(\n    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase\n  );\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\nvar joinPaths = (paths) => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname) => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search) => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash) => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar DataWithResponseInit = class {\n  constructor(data2, init) {\n    this.type = \"DataWithResponseInit\";\n    this.data = data2;\n    this.init = init || null;\n  }\n};\nfunction data(data2, init) {\n  return new DataWithResponseInit(\n    data2,\n    typeof init === \"number\" ? { status: init } : init\n  );\n}\nvar redirect = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, { ...responseInit, headers });\n};\nvar redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\nvar replace = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Replace\", \"true\");\n  return response;\n};\nvar ErrorResponseImpl = class {\n  constructor(status, statusText, data2, internal = false) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data2 instanceof Error) {\n      this.data = data2.toString();\n      this.error = data2;\n    } else {\n      this.data = data2;\n    }\n  }\n};\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n\n// lib/router/router.ts\nvar validMutationMethodsArr = [\n  \"POST\",\n  \"PUT\",\n  \"PATCH\",\n  \"DELETE\"\n];\nvar validMutationMethods = new Set(\n  validMutationMethodsArr\n);\nvar validRequestMethodsArr = [\n  \"GET\",\n  ...validMutationMethodsArr\n];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);\nvar IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_FETCHER = {\n  state: \"idle\",\n  data: void 0,\n  formMethod: void 0,\n  formAction: void 0,\n  formEncType: void 0,\n  formData: void 0,\n  json: void 0,\n  text: void 0\n};\nvar IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: void 0,\n  reset: void 0,\n  location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);\nvar defaultMapRouteProperties = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nvar ResetLoaderDataSymbol = Symbol(\"ResetLoaderData\");\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : void 0;\n  const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n  let hydrationRouteProperties2 = init.hydrationRouteProperties || [];\n  let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(\n    init.routes,\n    mapRouteProperties2,\n    void 0,\n    manifest\n  );\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  if (!basename.startsWith(\"/\")) {\n    basename = `/${basename}`;\n  }\n  let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;\n  let future = {\n    ...init.future\n  };\n  let unlistenHistory = null;\n  let subscribers = /* @__PURE__ */ new Set();\n  let savedScrollPositions2 = null;\n  let getScrollRestorationKey2 = null;\n  let getScrollPosition = null;\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialMatchesIsFOW = false;\n  let initialErrors = null;\n  let initialized;\n  if (initialMatches == null && !init.patchRoutesOnNavigation) {\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialized = true;\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  } else {\n    if (initialMatches && !init.hydrationData) {\n      let fogOfWar = checkFogOfWar(\n        initialMatches,\n        dataRoutes,\n        init.history.location.pathname\n      );\n      if (fogOfWar.active) {\n        initialMatches = null;\n      }\n    }\n    if (!initialMatches) {\n      initialized = false;\n      initialMatches = [];\n      let fogOfWar = checkFogOfWar(\n        null,\n        dataRoutes,\n        init.history.location.pathname\n      );\n      if (fogOfWar.active && fogOfWar.matches) {\n        initialMatchesIsFOW = true;\n        initialMatches = fogOfWar.matches;\n      }\n    } else if (initialMatches.some((m) => m.route.lazy)) {\n      initialized = false;\n    } else if (!initialMatches.some((m) => routeHasLoaderOrMiddleware(m.route))) {\n      initialized = true;\n    } else {\n      let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n      let errors = init.hydrationData ? init.hydrationData.errors : null;\n      if (errors) {\n        let idx = initialMatches.findIndex(\n          (m) => errors[m.route.id] !== void 0\n        );\n        initialized = initialMatches.slice(0, idx + 1).every(\n          (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)\n        );\n      } else {\n        initialized = initialMatches.every(\n          (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors)\n        );\n      }\n    }\n  }\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: /* @__PURE__ */ new Map(),\n    blockers: /* @__PURE__ */ new Map()\n  };\n  let pendingAction = \"POP\" /* Pop */;\n  let pendingPreventScrollReset = false;\n  let pendingNavigationController;\n  let pendingViewTransitionEnabled = false;\n  let appliedViewTransitions = /* @__PURE__ */ new Map();\n  let removePageHideEventListener = null;\n  let isUninterruptedRevalidation = false;\n  let isRevalidationRequired = false;\n  let cancelledFetcherLoads = /* @__PURE__ */ new Set();\n  let fetchControllers = /* @__PURE__ */ new Map();\n  let incrementingLoadId = 0;\n  let pendingNavigationLoadId = -1;\n  let fetchReloadIds = /* @__PURE__ */ new Map();\n  let fetchRedirectIds = /* @__PURE__ */ new Set();\n  let fetchLoadMatches = /* @__PURE__ */ new Map();\n  let activeFetchers = /* @__PURE__ */ new Map();\n  let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();\n  let blockerFunctions = /* @__PURE__ */ new Map();\n  let unblockBlockerHistoryUpdate = void 0;\n  let pendingRevalidationDfd = null;\n  function initialize() {\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location, delta }) => {\n        if (unblockBlockerHistoryUpdate) {\n          unblockBlockerHistoryUpdate();\n          unblockBlockerHistoryUpdate = void 0;\n          return;\n        }\n        warning(\n          blockerFunctions.size === 0 || delta != null,\n          \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\"\n        );\n        let blockerKey = shouldBlockNavigation({\n          currentLocation: state.location,\n          nextLocation: location,\n          historyAction\n        });\n        if (blockerKey && delta != null) {\n          let nextHistoryUpdatePromise = new Promise((resolve) => {\n            unblockBlockerHistoryUpdate = resolve;\n          });\n          init.history.go(delta * -1);\n          updateBlocker(blockerKey, {\n            state: \"blocked\",\n            location,\n            proceed() {\n              updateBlocker(blockerKey, {\n                state: \"proceeding\",\n                proceed: void 0,\n                reset: void 0,\n                location\n              });\n              nextHistoryUpdatePromise.then(() => init.history.go(delta));\n            },\n            reset() {\n              let blockers = new Map(state.blockers);\n              blockers.set(blockerKey, IDLE_BLOCKER);\n              updateState({ blockers });\n            }\n          });\n          return;\n        }\n        return startNavigation(historyAction, location);\n      }\n    );\n    if (isBrowser2) {\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    if (!state.initialized) {\n      startNavigation(\"POP\" /* Pop */, state.location, {\n        initialHydration: true\n      });\n    }\n    return router;\n  }\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  function updateState(newState, opts = {}) {\n    if (newState.matches) {\n      newState.matches = newState.matches.map((m) => {\n        let route = manifest[m.route.id];\n        let matchRoute = m.route;\n        if (matchRoute.element !== route.element || matchRoute.errorElement !== route.errorElement || matchRoute.hydrateFallbackElement !== route.hydrateFallbackElement) {\n          return {\n            ...m,\n            route\n          };\n        }\n        return m;\n      });\n    }\n    state = {\n      ...state,\n      ...newState\n    };\n    let unmountedFetchers = [];\n    let mountedFetchers = [];\n    state.fetchers.forEach((fetcher, key) => {\n      if (fetcher.state === \"idle\") {\n        if (fetchersQueuedForDeletion.has(key)) {\n          unmountedFetchers.push(key);\n        } else {\n          mountedFetchers.push(key);\n        }\n      }\n    });\n    fetchersQueuedForDeletion.forEach((key) => {\n      if (!state.fetchers.has(key) && !fetchControllers.has(key)) {\n        unmountedFetchers.push(key);\n      }\n    });\n    [...subscribers].forEach(\n      (subscriber) => subscriber(state, {\n        deletedFetchers: unmountedFetchers,\n        viewTransitionOpts: opts.viewTransitionOpts,\n        flushSync: opts.flushSync === true\n      })\n    );\n    unmountedFetchers.forEach((key) => deleteFetcher(key));\n    mountedFetchers.forEach((key) => state.fetchers.delete(key));\n  }\n  function completeNavigation(location, newState, { flushSync } = {}) {\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && location.state?._isRedirect !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      actionData = state.actionData;\n    } else {\n      actionData = null;\n    }\n    let loaderData = newState.loaderData ? mergeLoaderData(\n      state.loaderData,\n      newState.loaderData,\n      newState.matches || [],\n      newState.errors\n    ) : state.loaderData;\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    let restoreScrollPosition = isUninterruptedRevalidation ? false : getSavedScrollPosition(location, newState.matches || state.matches);\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = void 0;\n    }\n    if (isUninterruptedRevalidation) {\n    } else if (pendingAction === \"POP\" /* Pop */) {\n    } else if (pendingAction === \"PUSH\" /* Push */) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === \"REPLACE\" /* Replace */) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    if (pendingAction === \"POP\" /* Pop */) {\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = /* @__PURE__ */ new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(\n      {\n        ...newState,\n        // matches, errors, fetchers go through as-is\n        actionData,\n        loaderData,\n        historyAction: pendingAction,\n        location,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        revalidation: \"idle\",\n        restoreScrollPosition,\n        preventScrollReset,\n        blockers\n      },\n      {\n        viewTransitionOpts,\n        flushSync: flushSync === true\n      }\n    );\n    pendingAction = \"POP\" /* Pop */;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    pendingRevalidationDfd?.resolve();\n    pendingRevalidationDfd = null;\n  }\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      to,\n      opts?.fromRouteId,\n      opts?.relative\n    );\n    let { path, submission, error } = normalizeNavigateOptions(\n      false,\n      normalizedPath,\n      opts\n    );\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    nextLocation = {\n      ...nextLocation,\n      ...init.history.encodeLocation(nextLocation)\n    };\n    let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n    let historyAction = \"PUSH\" /* Push */;\n    if (userReplace === true) {\n      historyAction = \"REPLACE\" /* Replace */;\n    } else if (userReplace === false) {\n    } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      historyAction = \"REPLACE\" /* Replace */;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n    let flushSync = (opts && opts.flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: void 0,\n            reset: void 0,\n            location: nextLocation\n          });\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({ blockers });\n        }\n      });\n      return;\n    }\n    await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.viewTransition,\n      flushSync\n    });\n  }\n  function revalidate() {\n    if (!pendingRevalidationDfd) {\n      pendingRevalidationDfd = createDeferred();\n    }\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n    let promise = pendingRevalidationDfd.promise;\n    if (state.navigation.state === \"submitting\") {\n      return promise;\n    }\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return promise;\n    }\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      {\n        overrideNavigation: state.navigation,\n        // Proxy through any rending view transition\n        enableViewTransition: pendingViewTransitionEnabled === true\n      }\n    );\n    return promise;\n  }\n  async function startNavigation(historyAction, location, opts) {\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (\n      // `matchRoutes()` has already been called if we're in here via `router.initialize()`\n      state.matches\n    ) : matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, { matches }, { flushSync });\n      return;\n    }\n    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);\n    if (fogOfWar.active && fogOfWar.matches) {\n      matches = fogOfWar.matches;\n    }\n    if (!matches) {\n      let { error, notFoundMatches, route } = handleNavigational404(\n        location.pathname\n      );\n      completeNavigation(\n        location,\n        {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error\n          }\n        },\n        { flushSync }\n      );\n      return;\n    }\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      init.history,\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let scopedContext = init.getContext ? await init.getContext() : new RouterContextProvider();\n    let pendingActionResult;\n    if (opts && opts.pendingError) {\n      pendingActionResult = [\n        findNearestBoundary(matches).route.id,\n        { type: \"error\" /* error */, error: opts.pendingError }\n      ];\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      let actionResult = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        scopedContext,\n        fogOfWar.active,\n        opts && opts.initialHydration === true,\n        { replace: opts.replace, flushSync }\n      );\n      if (actionResult.shortCircuited) {\n        return;\n      }\n      if (actionResult.pendingActionResult) {\n        let [routeId, result] = actionResult.pendingActionResult;\n        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {\n          pendingNavigationController = null;\n          completeNavigation(location, {\n            matches: actionResult.matches,\n            loaderData: {},\n            errors: {\n              [routeId]: result.error\n            }\n          });\n          return;\n        }\n      }\n      matches = actionResult.matches || matches;\n      pendingActionResult = actionResult.pendingActionResult;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      fogOfWar.active = false;\n      request = createClientSideRequest(\n        init.history,\n        request.url,\n        request.signal\n      );\n    }\n    let {\n      shortCircuited,\n      matches: updatedMatches,\n      loaderData,\n      errors\n    } = await handleLoaders(\n      request,\n      location,\n      matches,\n      scopedContext,\n      fogOfWar.active,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.fetcherSubmission,\n      opts && opts.replace,\n      opts && opts.initialHydration === true,\n      flushSync,\n      pendingActionResult\n    );\n    if (shortCircuited) {\n      return;\n    }\n    pendingNavigationController = null;\n    completeNavigation(location, {\n      matches: updatedMatches || matches,\n      ...getActionDataForCommit(pendingActionResult),\n      loaderData,\n      errors\n    });\n  }\n  async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {\n    interruptActiveLoads();\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({ navigation }, { flushSync: opts.flushSync === true });\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        matches,\n        location.pathname,\n        request.signal\n      );\n      if (discoverResult.type === \"aborted\") {\n        return { shortCircuited: true };\n      } else if (discoverResult.type === \"error\") {\n        if (discoverResult.partialMatches.length === 0) {\n          let { matches: matches2, route } = getShortCircuitMatches(dataRoutes);\n          return {\n            matches: matches2,\n            pendingActionResult: [\n              route.id,\n              {\n                type: \"error\" /* error */,\n                error: discoverResult.error\n              }\n            ]\n          };\n        }\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n        return {\n          matches: discoverResult.partialMatches,\n          pendingActionResult: [\n            boundaryId,\n            {\n              type: \"error\" /* error */,\n              error: discoverResult.error\n            }\n          ]\n        };\n      } else if (!discoverResult.matches) {\n        let { notFoundMatches, error, route } = handleNavigational404(\n          location.pathname\n        );\n        return {\n          matches: notFoundMatches,\n          pendingActionResult: [\n            route.id,\n            {\n              type: \"error\" /* error */,\n              error\n            }\n          ]\n        };\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: \"error\" /* error */,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      let dsMatches = getTargetedDataStrategyMatches(\n        mapRouteProperties2,\n        manifest,\n        request,\n        matches,\n        actionMatch,\n        initialHydration ? [] : hydrationRouteProperties2,\n        scopedContext\n      );\n      let results = await callDataStrategy(\n        request,\n        dsMatches,\n        scopedContext,\n        null\n      );\n      result = results[actionMatch.route.id];\n      if (!result) {\n        for (let match of matches) {\n          if (results[match.route.id]) {\n            result = results[match.route.id];\n            break;\n          }\n        }\n      }\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace2;\n      if (opts && opts.replace != null) {\n        replace2 = opts.replace;\n      } else {\n        let location2 = normalizeRedirectLocation(\n          result.response.headers.get(\"Location\"),\n          new URL(request.url),\n          basename\n        );\n        replace2 = location2 === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(request, result, true, {\n        submission,\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      if ((opts && opts.replace) !== true) {\n        pendingAction = \"PUSH\" /* Push */;\n      }\n      return {\n        matches,\n        pendingActionResult: [\n          boundaryMatch.route.id,\n          result,\n          actionMatch.route.id\n        ]\n      };\n    }\n    return {\n      matches,\n      pendingActionResult: [actionMatch.route.id, result]\n    };\n  }\n  async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;\n    if (isFogOfWar) {\n      if (shouldUpdateNavigationState) {\n        let actionData = getUpdatedActionData(pendingActionResult);\n        updateState(\n          {\n            navigation: loadingNavigation,\n            ...actionData !== void 0 ? { actionData } : {}\n          },\n          {\n            flushSync\n          }\n        );\n      }\n      let discoverResult = await discoverRoutes(\n        matches,\n        location.pathname,\n        request.signal\n      );\n      if (discoverResult.type === \"aborted\") {\n        return { shortCircuited: true };\n      } else if (discoverResult.type === \"error\") {\n        if (discoverResult.partialMatches.length === 0) {\n          let { matches: matches2, route } = getShortCircuitMatches(dataRoutes);\n          return {\n            matches: matches2,\n            loaderData: {},\n            errors: {\n              [route.id]: discoverResult.error\n            }\n          };\n        }\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n        return {\n          matches: discoverResult.partialMatches,\n          loaderData: {},\n          errors: {\n            [boundaryId]: discoverResult.error\n          }\n        };\n      } else if (!discoverResult.matches) {\n        let { error, notFoundMatches, route } = handleNavigational404(\n          location.pathname\n        );\n        return {\n          matches: notFoundMatches,\n          loaderData: {},\n          errors: {\n            [route.id]: error\n          }\n        };\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let { dsMatches, revalidatingFetchers } = getMatchesToLoad(\n      request,\n      scopedContext,\n      mapRouteProperties2,\n      manifest,\n      init.history,\n      state,\n      matches,\n      activeSubmission,\n      location,\n      initialHydration ? [] : hydrationRouteProperties2,\n      initialHydration === true,\n      isRevalidationRequired,\n      cancelledFetcherLoads,\n      fetchersQueuedForDeletion,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      init.patchRoutesOnNavigation != null,\n      pendingActionResult\n    );\n    pendingNavigationLoadId = ++incrementingLoadId;\n    if (!init.dataStrategy && !dsMatches.some((m) => m.shouldLoad) && !dsMatches.some(\n      (m) => m.route.middleware && m.route.middleware.length > 0\n    ) && revalidatingFetchers.length === 0) {\n      let updatedFetchers2 = markFetchRedirectsDone();\n      completeNavigation(\n        location,\n        {\n          matches,\n          loaderData: {},\n          // Commit pending error if we're short circuiting\n          errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,\n          ...getActionDataForCommit(pendingActionResult),\n          ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}\n        },\n        { flushSync }\n      );\n      return { shortCircuited: true };\n    }\n    if (shouldUpdateNavigationState) {\n      let updates = {};\n      if (!isFogOfWar) {\n        updates.navigation = loadingNavigation;\n        let actionData = getUpdatedActionData(pendingActionResult);\n        if (actionData !== void 0) {\n          updates.actionData = actionData;\n        }\n      }\n      if (revalidatingFetchers.length > 0) {\n        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);\n      }\n      updateState(updates, { flushSync });\n    }\n    revalidatingFetchers.forEach((rf) => {\n      abortFetcher(rf.key);\n      if (rf.controller) {\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(\n      dsMatches,\n      revalidatingFetchers,\n      request,\n      scopedContext\n    );\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n    let redirect2 = findRedirect(loaderResults);\n    if (redirect2) {\n      await startRedirectNavigation(request, redirect2.result, true, {\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    redirect2 = findRedirect(fetcherResults);\n    if (redirect2) {\n      fetchRedirectIds.add(redirect2.key);\n      await startRedirectNavigation(request, redirect2.result, true, {\n        replace: replace2\n      });\n      return { shortCircuited: true };\n    }\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      loaderResults,\n      pendingActionResult,\n      revalidatingFetchers,\n      fetcherResults\n    );\n    if (initialHydration && state.errors) {\n      errors = { ...state.errors, ...errors };\n    }\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return {\n      matches,\n      loaderData,\n      errors,\n      ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}\n    };\n  }\n  function getUpdatedActionData(pendingActionResult) {\n    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n      return {\n        [pendingActionResult[0]]: pendingActionResult[1].data\n      };\n    } else if (state.actionData) {\n      if (Object.keys(state.actionData).length === 0) {\n        return null;\n      } else {\n        return state.actionData;\n      }\n    }\n  }\n  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {\n    revalidatingFetchers.forEach((rf) => {\n      let fetcher = state.fetchers.get(rf.key);\n      let revalidatingFetcher = getLoadingFetcher(\n        void 0,\n        fetcher ? fetcher.data : void 0\n      );\n      state.fetchers.set(rf.key, revalidatingFetcher);\n    });\n    return new Map(state.fetchers);\n  }\n  async function fetch2(key, routeId, href, opts) {\n    abortFetcher(key);\n    let flushSync = (opts && opts.flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      href,\n      routeId,\n      opts?.relative\n    );\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);\n    if (fogOfWar.active && fogOfWar.matches) {\n      matches = fogOfWar.matches;\n    }\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: normalizedPath }),\n        { flushSync }\n      );\n      return;\n    }\n    let { path, submission, error } = normalizeNavigateOptions(\n      true,\n      normalizedPath,\n      opts\n    );\n    if (error) {\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n    let scopedContext = init.getContext ? await init.getContext() : new RouterContextProvider();\n    let preventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      await handleFetcherAction(\n        key,\n        routeId,\n        path,\n        matches,\n        scopedContext,\n        fogOfWar.active,\n        flushSync,\n        preventScrollReset,\n        submission\n      );\n      return;\n    }\n    fetchLoadMatches.set(key, { routeId, path });\n    await handleFetcherLoader(\n      key,\n      routeId,\n      path,\n      matches,\n      scopedContext,\n      fogOfWar.active,\n      flushSync,\n      preventScrollReset,\n      submission\n    );\n  }\n  async function handleFetcherAction(key, routeId, path, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal,\n      submission\n    );\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        requestMatches,\n        new URL(fetchRequest.url).pathname,\n        fetchRequest.signal,\n        key\n      );\n      if (discoverResult.type === \"aborted\") {\n        return;\n      } else if (discoverResult.type === \"error\") {\n        setFetcherError(key, routeId, discoverResult.error, { flushSync });\n        return;\n      } else if (!discoverResult.matches) {\n        setFetcherError(\n          key,\n          routeId,\n          getInternalRouterError(404, { pathname: path }),\n          { flushSync }\n        );\n        return;\n      } else {\n        requestMatches = discoverResult.matches;\n      }\n    }\n    let match = getTargetMatch(requestMatches, path);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId\n      });\n      setFetcherError(key, routeId, error, { flushSync });\n      return;\n    }\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let fetchMatches = getTargetedDataStrategyMatches(\n      mapRouteProperties2,\n      manifest,\n      fetchRequest,\n      requestMatches,\n      match,\n      hydrationRouteProperties2,\n      scopedContext\n    );\n    let actionResults = await callDataStrategy(\n      fetchRequest,\n      fetchMatches,\n      scopedContext,\n      key\n    );\n    let actionResult = actionResults[match.route.id];\n    if (fetchRequest.signal.aborted) {\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (fetchersQueuedForDeletion.has(key)) {\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      }\n    } else {\n      if (isRedirectResult(actionResult)) {\n        fetchControllers.delete(key);\n        if (pendingNavigationLoadId > originatingLoadId) {\n          updateFetcherState(key, getDoneFetcher(void 0));\n          return;\n        } else {\n          fetchRedirectIds.add(key);\n          updateFetcherState(key, getLoadingFetcher(submission));\n          return startRedirectNavigation(fetchRequest, actionResult, false, {\n            fetcherSubmission: submission,\n            preventScrollReset\n          });\n        }\n      }\n      if (isErrorResult(actionResult)) {\n        setFetcherError(key, routeId, actionResult.error);\n        return;\n      }\n    }\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      init.history,\n      nextLocation,\n      abortController.signal\n    );\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let { dsMatches, revalidatingFetchers } = getMatchesToLoad(\n      revalidationRequest,\n      scopedContext,\n      mapRouteProperties2,\n      manifest,\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      hydrationRouteProperties2,\n      false,\n      isRevalidationRequired,\n      cancelledFetcherLoads,\n      fetchersQueuedForDeletion,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      init.patchRoutesOnNavigation != null,\n      [match.route.id, actionResult]\n    );\n    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {\n      let staleKey = rf.key;\n      let existingFetcher2 = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(\n        void 0,\n        existingFetcher2 ? existingFetcher2.data : void 0\n      );\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      abortFetcher(staleKey);\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({ fetchers: new Map(state.fetchers) });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n    let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(\n      dsMatches,\n      revalidatingFetchers,\n      revalidationRequest,\n      scopedContext\n    );\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    let redirect2 = findRedirect(loaderResults);\n    if (redirect2) {\n      return startRedirectNavigation(\n        revalidationRequest,\n        redirect2.result,\n        false,\n        { preventScrollReset }\n      );\n    }\n    redirect2 = findRedirect(fetcherResults);\n    if (redirect2) {\n      fetchRedirectIds.add(redirect2.key);\n      return startRedirectNavigation(\n        revalidationRequest,\n        redirect2.result,\n        false,\n        { preventScrollReset }\n      );\n    }\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      loaderResults,\n      void 0,\n      revalidatingFetchers,\n      fetcherResults\n    );\n    abortStaleFetchLoads(loadId);\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  async function handleFetcherLoader(key, routeId, path, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(\n      key,\n      getLoadingFetcher(\n        submission,\n        existingFetcher ? existingFetcher.data : void 0\n      ),\n      { flushSync }\n    );\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal\n    );\n    if (isFogOfWar) {\n      let discoverResult = await discoverRoutes(\n        matches,\n        new URL(fetchRequest.url).pathname,\n        fetchRequest.signal,\n        key\n      );\n      if (discoverResult.type === \"aborted\") {\n        return;\n      } else if (discoverResult.type === \"error\") {\n        setFetcherError(key, routeId, discoverResult.error, { flushSync });\n        return;\n      } else if (!discoverResult.matches) {\n        setFetcherError(\n          key,\n          routeId,\n          getInternalRouterError(404, { pathname: path }),\n          { flushSync }\n        );\n        return;\n      } else {\n        matches = discoverResult.matches;\n      }\n    }\n    let match = getTargetMatch(matches, path);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let dsMatches = getTargetedDataStrategyMatches(\n      mapRouteProperties2,\n      manifest,\n      fetchRequest,\n      matches,\n      match,\n      hydrationRouteProperties2,\n      scopedContext\n    );\n    let results = await callDataStrategy(\n      fetchRequest,\n      dsMatches,\n      scopedContext,\n      key\n    );\n    let result = results[match.route.id];\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (fetchersQueuedForDeletion.has(key)) {\n      updateFetcherState(key, getDoneFetcher(void 0));\n      return;\n    }\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        updateFetcherState(key, getDoneFetcher(void 0));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(fetchRequest, result, false, {\n          preventScrollReset\n        });\n        return;\n      }\n    }\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  async function startRedirectNavigation(request, redirect2, isNavigation, {\n    submission,\n    fetcherSubmission,\n    preventScrollReset,\n    replace: replace2\n  } = {}) {\n    if (redirect2.response.headers.has(\"X-Remix-Revalidate\")) {\n      isRevalidationRequired = true;\n    }\n    let location = redirect2.response.headers.get(\"Location\");\n    invariant(location, \"Expected a Location header on the redirect Response\");\n    location = normalizeRedirectLocation(\n      location,\n      new URL(request.url),\n      basename\n    );\n    let redirectLocation = createLocation(state.location, location, {\n      _isRedirect: true\n    });\n    if (isBrowser2) {\n      let isDocumentReload = false;\n      if (redirect2.response.headers.has(\"X-Remix-Reload-Document\")) {\n        isDocumentReload = true;\n      } else if (isAbsoluteUrl(location)) {\n        const url = createBrowserURLImpl(location, true);\n        isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace2) {\n          routerWindow.location.replace(location);\n        } else {\n          routerWindow.location.assign(location);\n        }\n        return;\n      }\n    }\n    pendingNavigationController = null;\n    let redirectNavigationType = replace2 === true || redirect2.response.headers.has(\"X-Remix-Replace\") ? \"REPLACE\" /* Replace */ : \"PUSH\" /* Push */;\n    let { formMethod, formAction, formEncType } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectNavigationType, redirectLocation, {\n        submission: {\n          ...activeSubmission,\n          formAction: location\n        },\n        // Preserve these flags across redirects\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n      });\n    } else {\n      let overrideNavigation = getLoadingNavigation(\n        redirectLocation,\n        submission\n      );\n      await startNavigation(redirectNavigationType, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve these flags across redirects\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n      });\n    }\n  }\n  async function callDataStrategy(request, matches, scopedContext, fetcherKey) {\n    let results;\n    let dataResults = {};\n    try {\n      results = await callDataStrategyImpl(\n        dataStrategyImpl,\n        request,\n        matches,\n        fetcherKey,\n        scopedContext,\n        false\n      );\n    } catch (e) {\n      matches.filter((m) => m.shouldLoad).forEach((m) => {\n        dataResults[m.route.id] = {\n          type: \"error\" /* error */,\n          error: e\n        };\n      });\n      return dataResults;\n    }\n    if (request.signal.aborted) {\n      return dataResults;\n    }\n    for (let [routeId, result] of Object.entries(results)) {\n      if (isRedirectDataStrategyResult(result)) {\n        let response = result.result;\n        dataResults[routeId] = {\n          type: \"redirect\" /* redirect */,\n          response: normalizeRelativeRoutingRedirectResponse(\n            response,\n            request,\n            routeId,\n            matches,\n            basename\n          )\n        };\n      } else {\n        dataResults[routeId] = await convertDataStrategyResultToDataResult(result);\n      }\n    }\n    return dataResults;\n  }\n  async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {\n    let loaderResultsPromise = callDataStrategy(\n      request,\n      matches,\n      scopedContext,\n      null\n    );\n    let fetcherResultsPromise = Promise.all(\n      fetchersToLoad.map(async (f) => {\n        if (f.matches && f.match && f.request && f.controller) {\n          let results = await callDataStrategy(\n            f.request,\n            f.matches,\n            scopedContext,\n            f.key\n          );\n          let result = results[f.match.route.id];\n          return { [f.key]: result };\n        } else {\n          return Promise.resolve({\n            [f.key]: {\n              type: \"error\" /* error */,\n              error: getInternalRouterError(404, {\n                pathname: f.path\n              })\n            }\n          });\n        }\n      })\n    );\n    let loaderResults = await loaderResultsPromise;\n    let fetcherResults = (await fetcherResultsPromise).reduce(\n      (acc, r) => Object.assign(acc, r),\n      {}\n    );\n    return {\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    isRevalidationRequired = true;\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.add(key);\n      }\n      abortFetcher(key);\n    });\n  }\n  function updateFetcherState(key, fetcher, opts = {}) {\n    state.fetchers.set(key, fetcher);\n    updateState(\n      { fetchers: new Map(state.fetchers) },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n  function setFetcherError(key, routeId, error, opts = {}) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState(\n      {\n        errors: {\n          [boundaryMatch.route.id]: error\n        },\n        fetchers: new Map(state.fetchers)\n      },\n      { flushSync: (opts && opts.flushSync) === true }\n    );\n  }\n  function getFetcher(key) {\n    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n    if (fetchersQueuedForDeletion.has(key)) {\n      fetchersQueuedForDeletion.delete(key);\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function resetFetcher(key, opts) {\n    abortFetcher(key, opts?.reason);\n    updateFetcherState(key, getDoneFetcher(null));\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    fetchersQueuedForDeletion.delete(key);\n    cancelledFetcherLoads.delete(key);\n    state.fetchers.delete(key);\n  }\n  function queueFetcherForDeletion(key) {\n    let count = (activeFetchers.get(key) || 0) - 1;\n    if (count <= 0) {\n      activeFetchers.delete(key);\n      fetchersQueuedForDeletion.add(key);\n    } else {\n      activeFetchers.set(key, count);\n    }\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n  function abortFetcher(key, reason) {\n    let controller = fetchControllers.get(key);\n    if (controller) {\n      controller.abort(reason);\n      fetchControllers.delete(key);\n    }\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    invariant(\n      blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\",\n      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`\n    );\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({ blockers });\n  }\n  function shouldBlockNavigation({\n    currentLocation,\n    nextLocation,\n    historyAction\n  }) {\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      return;\n    }\n    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {\n      return blockerKey;\n    }\n  }\n  function handleNavigational404(pathname) {\n    let error = getInternalRouterError(404, { pathname });\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let { matches, route } = getShortCircuitMatches(routesToUse);\n    return { notFoundMatches: matches, route, error };\n  }\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions2 = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey2 = getKey || null;\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n    return () => {\n      savedScrollPositions2 = null;\n      getScrollPosition = null;\n      getScrollRestorationKey2 = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey2) {\n      let key = getScrollRestorationKey2(\n        location,\n        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))\n      );\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions2 && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions2[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions2) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions2[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function checkFogOfWar(matches, routesToUse, pathname) {\n    if (init.patchRoutesOnNavigation) {\n      if (!matches) {\n        let fogMatches = matchRoutesImpl(\n          routesToUse,\n          pathname,\n          basename,\n          true\n        );\n        return { active: true, matches: fogMatches || [] };\n      } else {\n        if (Object.keys(matches[0].params).length > 0) {\n          let partialMatches = matchRoutesImpl(\n            routesToUse,\n            pathname,\n            basename,\n            true\n          );\n          return { active: true, matches: partialMatches };\n        }\n      }\n    }\n    return { active: false, matches: null };\n  }\n  async function discoverRoutes(matches, pathname, signal, fetcherKey) {\n    if (!init.patchRoutesOnNavigation) {\n      return { type: \"success\", matches };\n    }\n    let partialMatches = matches;\n    while (true) {\n      let isNonHMR = inFlightDataRoutes == null;\n      let routesToUse = inFlightDataRoutes || dataRoutes;\n      let localManifest = manifest;\n      try {\n        await init.patchRoutesOnNavigation({\n          signal,\n          path: pathname,\n          matches: partialMatches,\n          fetcherKey,\n          patch: (routeId, children) => {\n            if (signal.aborted) return;\n            patchRoutesImpl(\n              routeId,\n              children,\n              routesToUse,\n              localManifest,\n              mapRouteProperties2,\n              false\n            );\n          }\n        });\n      } catch (e) {\n        return { type: \"error\", error: e, partialMatches };\n      } finally {\n        if (isNonHMR && !signal.aborted) {\n          dataRoutes = [...dataRoutes];\n        }\n      }\n      if (signal.aborted) {\n        return { type: \"aborted\" };\n      }\n      let newMatches = matchRoutes(routesToUse, pathname, basename);\n      if (newMatches) {\n        return { type: \"success\", matches: newMatches };\n      }\n      let newPartialMatches = matchRoutesImpl(\n        routesToUse,\n        pathname,\n        basename,\n        true\n      );\n      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(\n        (m, i) => m.route.id === newPartialMatches[i].route.id\n      )) {\n        return { type: \"success\", matches: null };\n      }\n      partialMatches = newPartialMatches;\n    }\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(\n      newRoutes,\n      mapRouteProperties2,\n      void 0,\n      manifest\n    );\n  }\n  function patchRoutes(routeId, children, unstable_allowElementMutations = false) {\n    let isNonHMR = inFlightDataRoutes == null;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    patchRoutesImpl(\n      routeId,\n      children,\n      routesToUse,\n      manifest,\n      mapRouteProperties2,\n      unstable_allowElementMutations\n    );\n    if (isNonHMR) {\n      dataRoutes = [...dataRoutes];\n      updateState({});\n    }\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get future() {\n      return future;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch: fetch2,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to) => init.history.createHref(to),\n    encodeLocation: (to) => init.history.encodeLocation(to),\n    getFetcher,\n    resetFetcher,\n    deleteFetcher: queueFetcherForDeletion,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    patchRoutes,\n    _internalFetchControllers: fetchControllers,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes,\n    _internalSetStateDoNotUseOrYouWillBreakYourApp(newState) {\n      updateState(newState);\n    }\n  };\n  return router;\n}\nfunction createStaticHandler(routes, opts) {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties2,\n    void 0,\n    manifest\n  );\n  async function query(request, {\n    requestContext,\n    filterMatchesToLoad,\n    skipLoaderErrorBubbling,\n    skipRevalidation,\n    dataStrategy,\n    generateMiddlewareResponse\n  } = {}) {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    requestContext = requestContext != null ? requestContext : new RouterContextProvider();\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n      let staticContext = {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n      return generateMiddlewareResponse ? generateMiddlewareResponse(() => Promise.resolve(staticContext)) : staticContext;\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n      let staticContext = {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n      return generateMiddlewareResponse ? generateMiddlewareResponse(() => Promise.resolve(staticContext)) : staticContext;\n    }\n    if (generateMiddlewareResponse) {\n      invariant(\n        requestContext instanceof RouterContextProvider,\n        \"When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `RouterContextProvider`\"\n      );\n      try {\n        await loadLazyMiddlewareForMatches(\n          matches,\n          manifest,\n          mapRouteProperties2\n        );\n        let renderedStaticContext;\n        let response = await runServerMiddlewarePipeline(\n          {\n            request,\n            matches,\n            params: matches[0].params,\n            // If we're calling middleware then it must be enabled so we can cast\n            // this to the proper type knowing it's not an `AppLoadContext`\n            context: requestContext\n          },\n          async () => {\n            let res = await generateMiddlewareResponse(\n              async (revalidationRequest, opts2 = {}) => {\n                let result2 = await queryImpl(\n                  revalidationRequest,\n                  location,\n                  matches,\n                  requestContext,\n                  dataStrategy || null,\n                  skipLoaderErrorBubbling === true,\n                  null,\n                  \"filterMatchesToLoad\" in opts2 ? opts2.filterMatchesToLoad ?? null : filterMatchesToLoad ?? null,\n                  skipRevalidation === true\n                );\n                if (isResponse(result2)) {\n                  return result2;\n                }\n                renderedStaticContext = { location, basename, ...result2 };\n                return renderedStaticContext;\n              }\n            );\n            return res;\n          },\n          async (error, routeId) => {\n            if (isRedirectResponse(error)) {\n              return error;\n            }\n            if (isResponse(error)) {\n              try {\n                error = new ErrorResponseImpl(\n                  error.status,\n                  error.statusText,\n                  await parseResponseBody(error)\n                );\n              } catch (e) {\n                error = e;\n              }\n            }\n            if (isDataWithResponseInit(error)) {\n              error = dataWithResponseInitToErrorResponse(error);\n            }\n            if (renderedStaticContext) {\n              if (routeId in renderedStaticContext.loaderData) {\n                renderedStaticContext.loaderData[routeId] = void 0;\n              }\n              let staticContext = getStaticContextFromError(\n                dataRoutes,\n                renderedStaticContext,\n                error,\n                skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, routeId).route.id\n              );\n              return generateMiddlewareResponse(\n                () => Promise.resolve(staticContext)\n              );\n            } else {\n              let boundaryRouteId = skipLoaderErrorBubbling ? routeId : findNearestBoundary(\n                matches,\n                matches.find(\n                  (m) => m.route.id === routeId || m.route.loader\n                )?.route.id || routeId\n              ).route.id;\n              let staticContext = {\n                matches,\n                location,\n                basename,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                  [boundaryRouteId]: error\n                },\n                statusCode: isRouteErrorResponse(error) ? error.status : 500,\n                actionHeaders: {},\n                loaderHeaders: {}\n              };\n              return generateMiddlewareResponse(\n                () => Promise.resolve(staticContext)\n              );\n            }\n          }\n        );\n        invariant(isResponse(response), \"Expected a response in query()\");\n        return response;\n      } catch (e) {\n        if (isResponse(e)) {\n          return e;\n        }\n        throw e;\n      }\n    }\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      dataStrategy || null,\n      skipLoaderErrorBubbling === true,\n      null,\n      filterMatchesToLoad || null,\n      skipRevalidation === true\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n    return { location, basename, ...result };\n  }\n  async function queryRoute(request, {\n    routeId,\n    requestContext,\n    dataStrategy,\n    generateMiddlewareResponse\n  } = {}) {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    requestContext = requestContext != null ? requestContext : new RouterContextProvider();\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n    let match = routeId ? matches.find((m) => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n    if (generateMiddlewareResponse) {\n      invariant(\n        requestContext instanceof RouterContextProvider,\n        \"When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `RouterContextProvider`\"\n      );\n      await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);\n      let response = await runServerMiddlewarePipeline(\n        {\n          request,\n          matches,\n          params: matches[0].params,\n          // If we're calling middleware then it must be enabled so we can cast\n          // this to the proper type knowing it's not an `AppLoadContext`\n          context: requestContext\n        },\n        async () => {\n          let res = await generateMiddlewareResponse(\n            async (innerRequest) => {\n              let result2 = await queryImpl(\n                innerRequest,\n                location,\n                matches,\n                requestContext,\n                dataStrategy || null,\n                false,\n                match,\n                null,\n                false\n              );\n              let processed = handleQueryResult(result2);\n              return isResponse(processed) ? processed : typeof processed === \"string\" ? new Response(processed) : Response.json(processed);\n            }\n          );\n          return res;\n        },\n        (error) => {\n          if (isDataWithResponseInit(error)) {\n            return Promise.resolve(dataWithResponseInitToResponse(error));\n          }\n          if (isResponse(error)) {\n            return Promise.resolve(error);\n          }\n          throw error;\n        }\n      );\n      return response;\n    }\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      dataStrategy || null,\n      false,\n      match,\n      null,\n      false\n    );\n    return handleQueryResult(result);\n    function handleQueryResult(result2) {\n      if (isResponse(result2)) {\n        return result2;\n      }\n      let error = result2.errors ? Object.values(result2.errors)[0] : void 0;\n      if (error !== void 0) {\n        throw error;\n      }\n      if (result2.actionData) {\n        return Object.values(result2.actionData)[0];\n      }\n      if (result2.loaderData) {\n        return Object.values(result2.loaderData)[0];\n      }\n      return void 0;\n    }\n  }\n  async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n    try {\n      if (isMutationMethod(request.method)) {\n        let result2 = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          dataStrategy,\n          skipLoaderErrorBubbling,\n          routeMatch != null,\n          filterMatchesToLoad,\n          skipRevalidation\n        );\n        return result2;\n      }\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        dataStrategy,\n        skipLoaderErrorBubbling,\n        routeMatch,\n        filterMatchesToLoad\n      );\n      return isResponse(result) ? result : {\n        ...result,\n        actionData: null,\n        actionHeaders: {}\n      };\n    } catch (e) {\n      if (isDataStrategyResult(e) && isResponse(e.result)) {\n        if (e.type === \"error\" /* error */) {\n          throw e.result;\n        }\n        return e.result;\n      }\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: \"error\" /* error */,\n        error\n      };\n    } else {\n      let dsMatches = getTargetedDataStrategyMatches(\n        mapRouteProperties2,\n        manifest,\n        request,\n        matches,\n        actionMatch,\n        [],\n        requestContext\n      );\n      let results = await callDataStrategy(\n        request,\n        dsMatches,\n        isRouteRequest,\n        requestContext,\n        dataStrategy\n      );\n      result = results[actionMatch.route.id];\n      if (request.signal.aborted) {\n        throwStaticHandlerAbortedError(request, isRouteRequest);\n      }\n    }\n    if (isRedirectResult(result)) {\n      throw new Response(null, {\n        status: result.response.status,\n        headers: {\n          Location: result.response.headers.get(\"Location\")\n        }\n      });\n    }\n    if (isRouteRequest) {\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {}\n      };\n    }\n    if (skipRevalidation) {\n      if (isErrorResult(result)) {\n        let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n        return {\n          statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n          actionData: null,\n          actionHeaders: {\n            ...result.headers ? { [actionMatch.route.id]: result.headers } : {}\n          },\n          matches,\n          loaderData: {},\n          errors: {\n            [boundaryMatch.route.id]: result.error\n          },\n          loaderHeaders: {}\n        };\n      } else {\n        return {\n          actionData: {\n            [actionMatch.route.id]: result.data\n          },\n          actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {},\n          matches,\n          loaderData: {},\n          errors: null,\n          statusCode: result.statusCode || 200,\n          loaderHeaders: {}\n        };\n      }\n    }\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    if (isErrorResult(result)) {\n      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n      let handlerContext2 = await loadRouteData(\n        loaderRequest,\n        matches,\n        requestContext,\n        dataStrategy,\n        skipLoaderErrorBubbling,\n        null,\n        filterMatchesToLoad,\n        [boundaryMatch.route.id, result]\n      );\n      return {\n        ...handlerContext2,\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n        actionData: null,\n        actionHeaders: {\n          ...result.headers ? { [actionMatch.route.id]: result.headers } : {}\n        }\n      };\n    }\n    let handlerContext = await loadRouteData(\n      loaderRequest,\n      matches,\n      requestContext,\n      dataStrategy,\n      skipLoaderErrorBubbling,\n      null,\n      filterMatchesToLoad\n    );\n    return {\n      ...handlerContext,\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      // action status codes take precedence over loader status codes\n      ...result.statusCode ? { statusCode: result.statusCode } : {},\n      actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {}\n    };\n  }\n  async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {\n    let isRouteRequest = routeMatch != null;\n    if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id\n      });\n    }\n    let dsMatches;\n    if (routeMatch) {\n      dsMatches = getTargetedDataStrategyMatches(\n        mapRouteProperties2,\n        manifest,\n        request,\n        matches,\n        routeMatch,\n        [],\n        requestContext\n      );\n    } else {\n      let maxIdx = pendingActionResult && isErrorResult(pendingActionResult[1]) ? (\n        // Up to but not including the boundary\n        matches.findIndex((m) => m.route.id === pendingActionResult[0]) - 1\n      ) : void 0;\n      dsMatches = matches.map((match, index) => {\n        if (maxIdx != null && index > maxIdx) {\n          return getDataStrategyMatch(\n            mapRouteProperties2,\n            manifest,\n            request,\n            match,\n            [],\n            requestContext,\n            false\n          );\n        }\n        return getDataStrategyMatch(\n          mapRouteProperties2,\n          manifest,\n          request,\n          match,\n          [],\n          requestContext,\n          (match.route.loader || match.route.lazy) != null && (!filterMatchesToLoad || filterMatchesToLoad(match))\n        );\n      });\n    }\n    if (!dataStrategy && !dsMatches.some((m) => m.shouldLoad)) {\n      return {\n        matches,\n        loaderData: {},\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n          [pendingActionResult[0]]: pendingActionResult[1].error\n        } : null,\n        statusCode: 200,\n        loaderHeaders: {}\n      };\n    }\n    let results = await callDataStrategy(\n      request,\n      dsMatches,\n      isRouteRequest,\n      requestContext,\n      dataStrategy\n    );\n    if (request.signal.aborted) {\n      throwStaticHandlerAbortedError(request, isRouteRequest);\n    }\n    let handlerContext = processRouteLoaderData(\n      matches,\n      results,\n      pendingActionResult,\n      true,\n      skipLoaderErrorBubbling\n    );\n    return {\n      ...handlerContext,\n      matches\n    };\n  }\n  async function callDataStrategy(request, matches, isRouteRequest, requestContext, dataStrategy) {\n    let results = await callDataStrategyImpl(\n      dataStrategy || defaultDataStrategy,\n      request,\n      matches,\n      null,\n      requestContext,\n      true\n    );\n    let dataResults = {};\n    await Promise.all(\n      matches.map(async (match) => {\n        if (!(match.route.id in results)) {\n          return;\n        }\n        let result = results[match.route.id];\n        if (isRedirectDataStrategyResult(result)) {\n          let response = result.result;\n          throw normalizeRelativeRoutingRedirectResponse(\n            response,\n            request,\n            match.route.id,\n            matches,\n            basename\n          );\n        }\n        if (isRouteRequest) {\n          if (isResponse(result.result)) {\n            throw result;\n          } else if (isDataWithResponseInit(result.result)) {\n            throw dataWithResponseInitToResponse(result.result);\n          }\n        }\n        dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);\n      })\n    );\n    return dataResults;\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\nfunction getStaticContextFromError(routes, handlerContext, error, boundaryId) {\n  let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;\n  return {\n    ...handlerContext,\n    statusCode: isRouteErrorResponse(error) ? error.status : 500,\n    errors: {\n      [errorBoundaryId]: error\n    }\n  };\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest) {\n  if (request.signal.reason !== void 0) {\n    throw request.signal.reason;\n  }\n  let method = isRouteRequest ? \"queryRoute\" : \"query\";\n  throw new Error(\n    `${method}() call aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`\n  );\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  let path = resolveTo(\n    to ? to : \".\",\n    getResolveToMatches(contextualMatches),\n    stripBasename(location.pathname, basename) || location.pathname,\n    relative === \"path\"\n  );\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch) {\n    let nakedIndex = hasNakedIndexQuery(path.search);\n    if (activeRouteMatch.route.index && !nakedIndex) {\n      path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    } else if (!activeRouteMatch.route.index && nakedIndex) {\n      let params = new URLSearchParams(path.search);\n      let indexValues = params.getAll(\"index\");\n      params.delete(\"index\");\n      indexValues.filter((v) => v).forEach((v) => params.append(\"index\", v));\n      let qs = params.toString();\n      path.search = qs ? `?${qs}` : \"\";\n    }\n  }\n  if (basename !== \"/\") {\n    path.pathname = prependBasename({ basename, pathname: path.pathname });\n  }\n  return createPath(path);\n}\nfunction normalizeNavigateOptions(isFetcher, path, opts) {\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, { type: \"invalid-body\" })\n  });\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = rawFormMethod.toUpperCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== void 0) {\n    if (opts.formEncType === \"text/plain\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n        Array.from(opts.body.entries()).reduce(\n          (acc, [name, value]) => `${acc}${name}=${value}\n`,\n          \"\"\n        )\n      ) : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: void 0,\n          json: void 0,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: void 0,\n            json,\n            text: void 0\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(\n    typeof FormData === \"function\",\n    \"FormData is not available in this environment\"\n  );\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: void 0,\n    text: void 0\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return { path, submission };\n  }\n  let parsedPath = parsePath(path);\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = `?${searchParams}`;\n  return { path: createPath(parsedPath), submission };\n}\nfunction getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, hasPatchRoutesOnNavigation, pendingActionResult) {\n  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  let maxIdx;\n  if (initialHydration && state.errors) {\n    let boundaryId = Object.keys(state.errors)[0];\n    maxIdx = matches.findIndex((m) => m.route.id === boundaryId);\n  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {\n    let boundaryId = pendingActionResult[0];\n    maxIdx = matches.findIndex((m) => m.route.id === boundaryId) - 1;\n  }\n  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;\n  let shouldSkipRevalidation = actionStatus && actionStatus >= 400;\n  let baseShouldRevalidateArgs = {\n    currentUrl,\n    currentParams: state.matches[0]?.params || {},\n    nextUrl,\n    nextParams: matches[0].params,\n    ...submission,\n    actionResult,\n    actionStatus\n  };\n  let dsMatches = matches.map((match, index) => {\n    let { route } = match;\n    let forceShouldLoad = null;\n    if (maxIdx != null && index > maxIdx) {\n      forceShouldLoad = false;\n    } else if (route.lazy) {\n      forceShouldLoad = true;\n    } else if (!routeHasLoaderOrMiddleware(route)) {\n      forceShouldLoad = false;\n    } else if (initialHydration) {\n      forceShouldLoad = shouldLoadRouteOnHydration(\n        route,\n        state.loaderData,\n        state.errors\n      );\n    } else if (isNewLoader(state.loaderData, state.matches[index], match)) {\n      forceShouldLoad = true;\n    }\n    if (forceShouldLoad !== null) {\n      return getDataStrategyMatch(\n        mapRouteProperties2,\n        manifest,\n        request,\n        match,\n        lazyRoutePropertiesToSkip,\n        scopedContext,\n        forceShouldLoad\n      );\n    }\n    let defaultShouldRevalidate = shouldSkipRevalidation ? false : (\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match)\n    );\n    let shouldRevalidateArgs = {\n      ...baseShouldRevalidateArgs,\n      defaultShouldRevalidate\n    };\n    let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);\n    return getDataStrategyMatch(\n      mapRouteProperties2,\n      manifest,\n      request,\n      match,\n      lazyRoutePropertiesToSkip,\n      scopedContext,\n      shouldLoad,\n      shouldRevalidateArgs\n    );\n  });\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    if (initialHydration || !matches.some((m) => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {\n      return;\n    }\n    let fetcher = state.fetchers.get(key);\n    let isMidInitialLoad = fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0;\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    if (!fetcherMatches) {\n      if (hasPatchRoutesOnNavigation && isMidInitialLoad) {\n        return;\n      }\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        request: null,\n        controller: null\n      });\n      return;\n    }\n    if (fetchRedirectIds.has(key)) {\n      return;\n    }\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let fetchController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      history,\n      f.path,\n      fetchController.signal\n    );\n    let fetcherDsMatches = null;\n    if (cancelledFetcherLoads.has(key)) {\n      cancelledFetcherLoads.delete(key);\n      fetcherDsMatches = getTargetedDataStrategyMatches(\n        mapRouteProperties2,\n        manifest,\n        fetchRequest,\n        fetcherMatches,\n        fetcherMatch,\n        lazyRoutePropertiesToSkip,\n        scopedContext\n      );\n    } else if (isMidInitialLoad) {\n      if (isRevalidationRequired) {\n        fetcherDsMatches = getTargetedDataStrategyMatches(\n          mapRouteProperties2,\n          manifest,\n          fetchRequest,\n          fetcherMatches,\n          fetcherMatch,\n          lazyRoutePropertiesToSkip,\n          scopedContext\n        );\n      }\n    } else {\n      let shouldRevalidateArgs = {\n        ...baseShouldRevalidateArgs,\n        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\n      };\n      if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {\n        fetcherDsMatches = getTargetedDataStrategyMatches(\n          mapRouteProperties2,\n          manifest,\n          fetchRequest,\n          fetcherMatches,\n          fetcherMatch,\n          lazyRoutePropertiesToSkip,\n          scopedContext,\n          shouldRevalidateArgs\n        );\n      }\n    }\n    if (fetcherDsMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherDsMatches,\n        match: fetcherMatch,\n        request: fetchRequest,\n        controller: fetchController\n      });\n    }\n  });\n  return { dsMatches, revalidatingFetchers };\n}\nfunction routeHasLoaderOrMiddleware(route) {\n  return route.loader != null || route.middleware != null && route.middleware.length > 0;\n}\nfunction shouldLoadRouteOnHydration(route, loaderData, errors) {\n  if (route.lazy) {\n    return true;\n  }\n  if (!routeHasLoaderOrMiddleware(route)) {\n    return false;\n  }\n  let hasData = loaderData != null && route.id in loaderData;\n  let hasError = errors != null && errors[route.id] !== void 0;\n  if (!hasData && hasError) {\n    return false;\n  }\n  if (typeof route.loader === \"function\" && route.loader.hydrate === true) {\n    return true;\n  }\n  return !hasData && !hasError;\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew = (\n    // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id\n  );\n  let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\nfunction patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2, allowElementMutations) {\n  let childrenToPatch;\n  if (routeId) {\n    let route = manifest[routeId];\n    invariant(\n      route,\n      `No route found to patch children into: routeId = ${routeId}`\n    );\n    if (!route.children) {\n      route.children = [];\n    }\n    childrenToPatch = route.children;\n  } else {\n    childrenToPatch = routesToUse;\n  }\n  let uniqueChildren = [];\n  let existingChildren = [];\n  children.forEach((newRoute) => {\n    let existingRoute = childrenToPatch.find(\n      (existingRoute2) => isSameRoute(newRoute, existingRoute2)\n    );\n    if (existingRoute) {\n      existingChildren.push({ existingRoute, newRoute });\n    } else {\n      uniqueChildren.push(newRoute);\n    }\n  });\n  if (uniqueChildren.length > 0) {\n    let newRoutes = convertRoutesToDataRoutes(\n      uniqueChildren,\n      mapRouteProperties2,\n      [routeId || \"_\", \"patch\", String(childrenToPatch?.length || \"0\")],\n      manifest\n    );\n    childrenToPatch.push(...newRoutes);\n  }\n  if (allowElementMutations && existingChildren.length > 0) {\n    for (let i = 0; i < existingChildren.length; i++) {\n      let { existingRoute, newRoute } = existingChildren[i];\n      let existingRouteTyped = existingRoute;\n      let [newRouteTyped] = convertRoutesToDataRoutes(\n        [newRoute],\n        mapRouteProperties2,\n        [],\n        // Doesn't matter for mutated routes since they already have an id\n        {},\n        // Don't touch the manifest here since we're updating in place\n        true\n      );\n      Object.assign(existingRouteTyped, {\n        element: newRouteTyped.element ? newRouteTyped.element : existingRouteTyped.element,\n        errorElement: newRouteTyped.errorElement ? newRouteTyped.errorElement : existingRouteTyped.errorElement,\n        hydrateFallbackElement: newRouteTyped.hydrateFallbackElement ? newRouteTyped.hydrateFallbackElement : existingRouteTyped.hydrateFallbackElement\n      });\n    }\n  }\n}\nfunction isSameRoute(newRoute, existingRoute) {\n  if (\"id\" in newRoute && \"id\" in existingRoute && newRoute.id === existingRoute.id) {\n    return true;\n  }\n  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {\n    return false;\n  }\n  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {\n    return true;\n  }\n  return newRoute.children.every(\n    (aChild, i) => existingRoute.children?.some((bChild) => isSameRoute(aChild, bChild))\n  );\n}\nvar lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();\nvar loadLazyRouteProperty = ({\n  key,\n  route,\n  manifest,\n  mapRouteProperties: mapRouteProperties2\n}) => {\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== \"object\") {\n    return;\n  }\n  let lazyFn = routeToUpdate.lazy[key];\n  if (!lazyFn) {\n    return;\n  }\n  let cache = lazyRoutePropertyCache.get(routeToUpdate);\n  if (!cache) {\n    cache = {};\n    lazyRoutePropertyCache.set(routeToUpdate, cache);\n  }\n  let cachedPromise = cache[key];\n  if (cachedPromise) {\n    return cachedPromise;\n  }\n  let propertyPromise = (async () => {\n    let isUnsupported = isUnsupportedLazyRouteObjectKey(key);\n    let staticRouteValue = routeToUpdate[key];\n    let isStaticallyDefined = staticRouteValue !== void 0 && key !== \"hasErrorBoundary\";\n    if (isUnsupported) {\n      warning(\n        !isUnsupported,\n        \"Route property \" + key + \" is not a supported lazy route property. This property will be ignored.\"\n      );\n      cache[key] = Promise.resolve();\n    } else if (isStaticallyDefined) {\n      warning(\n        false,\n        `Route \"${routeToUpdate.id}\" has a static property \"${key}\" defined. The lazy property will be ignored.`\n      );\n    } else {\n      let value = await lazyFn();\n      if (value != null) {\n        Object.assign(routeToUpdate, { [key]: value });\n        Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));\n      }\n    }\n    if (typeof routeToUpdate.lazy === \"object\") {\n      routeToUpdate.lazy[key] = void 0;\n      if (Object.values(routeToUpdate.lazy).every((value) => value === void 0)) {\n        routeToUpdate.lazy = void 0;\n      }\n    }\n  })();\n  cache[key] = propertyPromise;\n  return propertyPromise;\n};\nvar lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();\nfunction loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  if (!route.lazy) {\n    return {\n      lazyRoutePromise: void 0,\n      lazyHandlerPromise: void 0\n    };\n  }\n  if (typeof route.lazy === \"function\") {\n    let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);\n    if (cachedPromise) {\n      return {\n        lazyRoutePromise: cachedPromise,\n        lazyHandlerPromise: cachedPromise\n      };\n    }\n    let lazyRoutePromise2 = (async () => {\n      invariant(\n        typeof route.lazy === \"function\",\n        \"No lazy route function found\"\n      );\n      let lazyRoute = await route.lazy();\n      let routeUpdates = {};\n      for (let lazyRouteProperty in lazyRoute) {\n        let lazyValue = lazyRoute[lazyRouteProperty];\n        if (lazyValue === void 0) {\n          continue;\n        }\n        let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);\n        let staticRouteValue = routeToUpdate[lazyRouteProperty];\n        let isStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n        // on the route updates\n        lazyRouteProperty !== \"hasErrorBoundary\";\n        if (isUnsupported) {\n          warning(\n            !isUnsupported,\n            \"Route property \" + lazyRouteProperty + \" is not a supported property to be returned from a lazy route function. This property will be ignored.\"\n          );\n        } else if (isStaticallyDefined) {\n          warning(\n            !isStaticallyDefined,\n            `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" defined but its lazy function is also returning a value for this property. The lazy route property \"${lazyRouteProperty}\" will be ignored.`\n          );\n        } else {\n          routeUpdates[lazyRouteProperty] = lazyValue;\n        }\n      }\n      Object.assign(routeToUpdate, routeUpdates);\n      Object.assign(routeToUpdate, {\n        // To keep things framework agnostic, we use the provided `mapRouteProperties`\n        // function to set the framework-aware properties (`element`/`hasErrorBoundary`)\n        // since the logic will differ between frameworks.\n        ...mapRouteProperties2(routeToUpdate),\n        lazy: void 0\n      });\n    })();\n    lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);\n    lazyRoutePromise2.catch(() => {\n    });\n    return {\n      lazyRoutePromise: lazyRoutePromise2,\n      lazyHandlerPromise: lazyRoutePromise2\n    };\n  }\n  let lazyKeys = Object.keys(route.lazy);\n  let lazyPropertyPromises = [];\n  let lazyHandlerPromise = void 0;\n  for (let key of lazyKeys) {\n    if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key)) {\n      continue;\n    }\n    let promise = loadLazyRouteProperty({\n      key,\n      route,\n      manifest,\n      mapRouteProperties: mapRouteProperties2\n    });\n    if (promise) {\n      lazyPropertyPromises.push(promise);\n      if (key === type) {\n        lazyHandlerPromise = promise;\n      }\n    }\n  }\n  let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(() => {\n  }) : void 0;\n  lazyRoutePromise?.catch(() => {\n  });\n  lazyHandlerPromise?.catch(() => {\n  });\n  return {\n    lazyRoutePromise,\n    lazyHandlerPromise\n  };\n}\nfunction isNonNullable(value) {\n  return value !== void 0;\n}\nfunction loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2) {\n  let promises = matches.map(({ route }) => {\n    if (typeof route.lazy !== \"object\" || !route.lazy.middleware) {\n      return void 0;\n    }\n    return loadLazyRouteProperty({\n      key: \"middleware\",\n      route,\n      manifest,\n      mapRouteProperties: mapRouteProperties2\n    });\n  }).filter(isNonNullable);\n  return promises.length > 0 ? Promise.all(promises) : void 0;\n}\nasync function defaultDataStrategy(args) {\n  let matchesToLoad = args.matches.filter((m) => m.shouldLoad);\n  let keyedResults = {};\n  let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));\n  results.forEach((result, i) => {\n    keyedResults[matchesToLoad[i].route.id] = result;\n  });\n  return keyedResults;\n}\nasync function defaultDataStrategyWithMiddleware(args) {\n  if (!args.matches.some((m) => m.route.middleware)) {\n    return defaultDataStrategy(args);\n  }\n  return runClientMiddlewarePipeline(args, () => defaultDataStrategy(args));\n}\nfunction runServerMiddlewarePipeline(args, handler, errorHandler) {\n  return runMiddlewarePipeline(\n    args,\n    handler,\n    processResult,\n    isResponse,\n    errorHandler\n  );\n  function processResult(result) {\n    return isDataWithResponseInit(result) ? dataWithResponseInitToResponse(result) : result;\n  }\n}\nfunction runClientMiddlewarePipeline(args, handler) {\n  return runMiddlewarePipeline(\n    args,\n    handler,\n    (r) => r,\n    // No post-processing needed on the client\n    isDataStrategyResults,\n    errorHandler\n  );\n  function errorHandler(error, routeId, nextResult) {\n    if (nextResult) {\n      return Promise.resolve(\n        Object.assign(nextResult.value, {\n          [routeId]: { type: \"error\", result: error }\n        })\n      );\n    } else {\n      let { matches } = args;\n      let maxBoundaryIdx = Math.min(\n        // Throwing route\n        Math.max(\n          matches.findIndex((m) => m.route.id === routeId),\n          0\n        ),\n        // or the shallowest route that needs to load data\n        Math.max(\n          matches.findIndex((m) => m.unstable_shouldCallHandler()),\n          0\n        )\n      );\n      let boundaryRouteId = findNearestBoundary(\n        matches,\n        matches[maxBoundaryIdx].route.id\n      ).route.id;\n      return Promise.resolve({\n        [boundaryRouteId]: { type: \"error\", result: error }\n      });\n    }\n  }\n}\nasync function runMiddlewarePipeline(args, handler, processResult, isResult, errorHandler) {\n  let { matches, request, params, context } = args;\n  let tuples = matches.flatMap(\n    (m) => m.route.middleware ? m.route.middleware.map((fn) => [m.route.id, fn]) : []\n  );\n  let result = await callRouteMiddleware(\n    { request, params, context },\n    tuples,\n    handler,\n    processResult,\n    isResult,\n    errorHandler\n  );\n  return result;\n}\nasync function callRouteMiddleware(args, middlewares, handler, processResult, isResult, errorHandler, idx = 0) {\n  let { request } = args;\n  if (request.signal.aborted) {\n    throw request.signal.reason ?? new Error(`Request aborted: ${request.method} ${request.url}`);\n  }\n  let tuple = middlewares[idx];\n  if (!tuple) {\n    let result = await handler();\n    return result;\n  }\n  let [routeId, middleware] = tuple;\n  let nextResult;\n  let next = async () => {\n    if (nextResult) {\n      throw new Error(\"You may only call `next()` once per middleware\");\n    }\n    try {\n      let result = await callRouteMiddleware(\n        args,\n        middlewares,\n        handler,\n        processResult,\n        isResult,\n        errorHandler,\n        idx + 1\n      );\n      nextResult = { value: result };\n      return nextResult.value;\n    } catch (error) {\n      nextResult = { value: await errorHandler(error, routeId, nextResult) };\n      return nextResult.value;\n    }\n  };\n  try {\n    let value = await middleware(args, next);\n    let result = value != null ? processResult(value) : void 0;\n    if (isResult(result)) {\n      return result;\n    } else if (nextResult) {\n      return result ?? nextResult.value;\n    } else {\n      nextResult = { value: await next() };\n      return nextResult.value;\n    }\n  } catch (error) {\n    let response = await errorHandler(error, routeId, nextResult);\n    return response;\n  }\n}\nfunction getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {\n  let lazyMiddlewarePromise = loadLazyRouteProperty({\n    key: \"middleware\",\n    route: match.route,\n    manifest,\n    mapRouteProperties: mapRouteProperties2\n  });\n  let lazyRoutePromises = loadLazyRoute(\n    match.route,\n    isMutationMethod(request.method) ? \"action\" : \"loader\",\n    manifest,\n    mapRouteProperties2,\n    lazyRoutePropertiesToSkip\n  );\n  return {\n    middleware: lazyMiddlewarePromise,\n    route: lazyRoutePromises.lazyRoutePromise,\n    handler: lazyRoutePromises.lazyHandlerPromise\n  };\n}\nfunction getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {\n  let isUsingNewApi = false;\n  let _lazyPromises = getDataStrategyMatchLazyPromises(\n    mapRouteProperties2,\n    manifest,\n    request,\n    match,\n    lazyRoutePropertiesToSkip\n  );\n  return {\n    ...match,\n    _lazyPromises,\n    shouldLoad,\n    unstable_shouldRevalidateArgs,\n    unstable_shouldCallHandler(defaultShouldRevalidate) {\n      isUsingNewApi = true;\n      if (!unstable_shouldRevalidateArgs) {\n        return shouldLoad;\n      }\n      if (typeof defaultShouldRevalidate === \"boolean\") {\n        return shouldRevalidateLoader(match, {\n          ...unstable_shouldRevalidateArgs,\n          defaultShouldRevalidate\n        });\n      }\n      return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);\n    },\n    resolve(handlerOverride) {\n      let { lazy, loader, middleware } = match.route;\n      let callHandler = isUsingNewApi || shouldLoad || handlerOverride && !isMutationMethod(request.method) && (lazy || loader);\n      let isMiddlewareOnlyRoute = middleware && middleware.length > 0 && !loader && !lazy;\n      if (callHandler && !isMiddlewareOnlyRoute) {\n        return callLoaderOrAction({\n          request,\n          match,\n          lazyHandlerPromise: _lazyPromises?.handler,\n          lazyRoutePromise: _lazyPromises?.route,\n          handlerOverride,\n          scopedContext\n        });\n      }\n      return Promise.resolve({ type: \"data\" /* data */, result: void 0 });\n    }\n  };\n}\nfunction getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {\n  return matches.map((match) => {\n    if (match.route.id !== targetMatch.route.id) {\n      return {\n        ...match,\n        shouldLoad: false,\n        unstable_shouldRevalidateArgs: shouldRevalidateArgs,\n        unstable_shouldCallHandler: () => false,\n        _lazyPromises: getDataStrategyMatchLazyPromises(\n          mapRouteProperties2,\n          manifest,\n          request,\n          match,\n          lazyRoutePropertiesToSkip\n        ),\n        resolve: () => Promise.resolve({ type: \"data\", result: void 0 })\n      };\n    }\n    return getDataStrategyMatch(\n      mapRouteProperties2,\n      manifest,\n      request,\n      match,\n      lazyRoutePropertiesToSkip,\n      scopedContext,\n      true,\n      shouldRevalidateArgs\n    );\n  });\n}\nasync function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {\n  if (matches.some((m) => m._lazyPromises?.middleware)) {\n    await Promise.all(matches.map((m) => m._lazyPromises?.middleware));\n  }\n  let dataStrategyArgs = {\n    request,\n    params: matches[0].params,\n    context: scopedContext,\n    matches\n  };\n  let runClientMiddleware = isStaticHandler ? () => {\n    throw new Error(\n      \"You cannot call `runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`\"\n    );\n  } : (cb) => {\n    let typedDataStrategyArgs = dataStrategyArgs;\n    return runClientMiddlewarePipeline(typedDataStrategyArgs, () => {\n      return cb({\n        ...typedDataStrategyArgs,\n        fetcherKey,\n        runClientMiddleware: () => {\n          throw new Error(\n            \"Cannot call `runClientMiddleware()` from within an `runClientMiddleware` handler\"\n          );\n        }\n      });\n    });\n  };\n  let results = await dataStrategyImpl({\n    ...dataStrategyArgs,\n    fetcherKey,\n    runClientMiddleware\n  });\n  try {\n    await Promise.all(\n      matches.flatMap((m) => [\n        m._lazyPromises?.handler,\n        m._lazyPromises?.route\n      ])\n    );\n  } catch (e) {\n  }\n  return results;\n}\nasync function callLoaderOrAction({\n  request,\n  match,\n  lazyHandlerPromise,\n  lazyRoutePromise,\n  handlerOverride,\n  scopedContext\n}) {\n  let result;\n  let onReject;\n  let isAction = isMutationMethod(request.method);\n  let type = isAction ? \"action\" : \"loader\";\n  let runHandler = (handler) => {\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    let actualHandler = (ctx) => {\n      if (typeof handler !== \"function\") {\n        return Promise.reject(\n          new Error(\n            `You cannot call the handler for a route which defines a boolean \"${type}\" [routeId: ${match.route.id}]`\n          )\n        );\n      }\n      return handler(\n        {\n          request,\n          params: match.params,\n          context: scopedContext\n        },\n        ...ctx !== void 0 ? [ctx] : []\n      );\n    };\n    let handlerPromise = (async () => {\n      try {\n        let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());\n        return { type: \"data\", result: val };\n      } catch (e) {\n        return { type: \"error\", result: e };\n      }\n    })();\n    return Promise.race([handlerPromise, abortPromise]);\n  };\n  try {\n    let handler = isAction ? match.route.action : match.route.loader;\n    if (lazyHandlerPromise || lazyRoutePromise) {\n      if (handler) {\n        let handlerError;\n        let [value] = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          // Ensure all lazy route promises are resolved before continuing\n          lazyHandlerPromise,\n          lazyRoutePromise\n        ]);\n        if (handlerError !== void 0) {\n          throw handlerError;\n        }\n        result = value;\n      } else {\n        await lazyHandlerPromise;\n        let handler2 = isAction ? match.route.action : match.route.loader;\n        if (handler2) {\n          [result] = await Promise.all([runHandler(handler2), lazyRoutePromise]);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          return { type: \"data\" /* data */, result: void 0 };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n  } catch (e) {\n    return { type: \"error\" /* error */, result: e };\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  return result;\n}\nasync function parseResponseBody(response) {\n  let contentType = response.headers.get(\"Content-Type\");\n  if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n    return response.body == null ? null : response.json();\n  }\n  return response.text();\n}\nasync function convertDataStrategyResultToDataResult(dataStrategyResult) {\n  let { result, type } = dataStrategyResult;\n  if (isResponse(result)) {\n    let data2;\n    try {\n      data2 = await parseResponseBody(result);\n    } catch (e) {\n      return { type: \"error\" /* error */, error: e };\n    }\n    if (type === \"error\" /* error */) {\n      return {\n        type: \"error\" /* error */,\n        error: new ErrorResponseImpl(result.status, result.statusText, data2),\n        statusCode: result.status,\n        headers: result.headers\n      };\n    }\n    return {\n      type: \"data\" /* data */,\n      data: data2,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (type === \"error\" /* error */) {\n    if (isDataWithResponseInit(result)) {\n      if (result.data instanceof Error) {\n        return {\n          type: \"error\" /* error */,\n          error: result.data,\n          statusCode: result.init?.status,\n          headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n        };\n      }\n      return {\n        type: \"error\" /* error */,\n        error: new ErrorResponseImpl(\n          result.init?.status || 500,\n          void 0,\n          result.data\n        ),\n        statusCode: isRouteErrorResponse(result) ? result.status : void 0,\n        headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n      };\n    }\n    return {\n      type: \"error\" /* error */,\n      error: result,\n      statusCode: isRouteErrorResponse(result) ? result.status : void 0\n    };\n  }\n  if (isDataWithResponseInit(result)) {\n    return {\n      type: \"data\" /* data */,\n      data: result.data,\n      statusCode: result.init?.status,\n      headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n    };\n  }\n  return { type: \"data\" /* data */, data: result };\n}\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {\n  let location = response.headers.get(\"Location\");\n  invariant(\n    location,\n    \"Redirects returned/thrown from loaders/actions must have a Location header\"\n  );\n  if (!isAbsoluteUrl(location)) {\n    let trimmedMatches = matches.slice(\n      0,\n      matches.findIndex((m) => m.route.id === routeId) + 1\n    );\n    location = normalizeTo(\n      new URL(request.url),\n      trimmedMatches,\n      basename,\n      location\n    );\n    response.headers.set(\"Location\", location);\n  }\n  return response;\n}\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\n  if (isAbsoluteUrl(location)) {\n    let normalizedLocation = location;\n    let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\n    let isSameBasename = stripBasename(url.pathname, basename) != null;\n    if (url.origin === currentUrl.origin && isSameBasename) {\n      return url.pathname + url.search + url.hash;\n    }\n  }\n  return location;\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = { signal };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType } = submission;\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({ \"Content-Type\": formEncType });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;\n  matches.forEach((match) => {\n    if (!(match.route.id in results)) {\n      return;\n    }\n    let id = match.route.id;\n    let result = results[id];\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      let error = result.error;\n      if (pendingError !== void 0) {\n        error = pendingError;\n        pendingError = void 0;\n      }\n      errors = errors || {};\n      if (skipLoaderErrorBubbling) {\n        errors[id] = error;\n      } else {\n        let boundaryMatch = findNearestBoundary(matches, id);\n        if (errors[boundaryMatch.route.id] == null) {\n          errors[boundaryMatch.route.id] = error;\n        }\n      }\n      if (!isStaticHandler) {\n        loaderData[id] = ResetLoaderDataSymbol;\n      }\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      loaderData[id] = result.data;\n      if (result.statusCode && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  if (pendingError !== void 0 && pendingActionResult) {\n    errors = { [pendingActionResult[0]]: pendingError };\n    if (pendingActionResult[2]) {\n      loaderData[pendingActionResult[2]] = void 0;\n    }\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    results,\n    pendingActionResult\n  );\n  revalidatingFetchers.filter((f) => !f.matches || f.matches.some((m) => m.shouldLoad)).forEach((rf) => {\n    let { key, match, controller } = rf;\n    if (controller && controller.signal.aborted) {\n      return;\n    }\n    let result = fetcherResults[key];\n    invariant(result, \"Did not find corresponding fetcher result\");\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  });\n  return { loaderData, errors };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {\n    merged[k] = v;\n    return merged;\n  }, {});\n  for (let match of matches) {\n    let id = match.route.id;\n    if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\nfunction getActionDataForCommit(pendingActionResult) {\n  if (!pendingActionResult) {\n    return {};\n  }\n  return isErrorResult(pendingActionResult[1]) ? {\n    // Clear out prior actionData on errors\n    actionData: {}\n  } : {\n    actionData: {\n      [pendingActionResult[0]]: pendingActionResult[1].data\n    }\n  };\n}\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  let route = routes.length === 1 ? routes[0] : routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: `__shim-error-route__`\n  };\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route\n      }\n    ],\n    route\n  };\n}\nfunction getInternalRouterError(status, {\n  pathname,\n  routeId,\n  method,\n  type,\n  message\n} = {}) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = `You made a ${method} request to \"${pathname}\" but did not provide a \\`loader\\` for route \"${routeId}\", so there is no way to handle the request.`;\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = `You made a ${method.toUpperCase()} request to \"${pathname}\" but did not provide an \\`action\\` for route \"${routeId}\", so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n  return new ErrorResponseImpl(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\nfunction findRedirect(results) {\n  let entries = Object.entries(results);\n  for (let i = entries.length - 1; i >= 0; i--) {\n    let [key, result] = entries[i];\n    if (isRedirectResult(result)) {\n      return { key, result };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    return true;\n  } else if (b.hash !== \"\") {\n    return true;\n  }\n  return false;\n}\nfunction dataWithResponseInitToResponse(data2) {\n  return Response.json(data2.data, data2.init ?? void 0);\n}\nfunction dataWithResponseInitToErrorResponse(data2) {\n  return new ErrorResponseImpl(\n    data2.init?.status ?? 500,\n    data2.init?.statusText ?? \"Internal Server Error\",\n    data2.data\n  );\n}\nfunction isDataStrategyResults(result) {\n  return result != null && typeof result === \"object\" && Object.entries(result).every(\n    ([key, value]) => typeof key === \"string\" && isDataStrategyResult(value)\n  );\n}\nfunction isDataStrategyResult(result) {\n  return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === \"data\" /* data */ || result.type === \"error\" /* error */);\n}\nfunction isRedirectDataStrategyResult(result) {\n  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\n}\nfunction isErrorResult(result) {\n  return result.type === \"error\" /* error */;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === \"redirect\" /* redirect */;\n}\nfunction isDataWithResponseInit(value) {\n  return typeof value === \"object\" && value != null && \"type\" in value && \"data\" in value && \"init\" in value && value.type === \"DataWithResponseInit\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectStatusCode(statusCode) {\n  return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(result) {\n  return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has(\"Location\");\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toUpperCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toUpperCase());\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    return matches[matches.length - 1];\n  }\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json: void 0,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: void 0,\n      text: void 0\n    };\n  } else if (json !== void 0) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: void 0,\n      json,\n      text: void 0\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data2) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data: data2\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: void 0,\n      formAction: void 0,\n      formEncType: void 0,\n      formData: void 0,\n      json: void 0,\n      text: void 0,\n      data: data2\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : void 0\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data2) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0,\n    data: data2\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(\n      TRANSITIONS_STORAGE_KEY\n    );\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(\n        TRANSITIONS_STORAGE_KEY,\n        JSON.stringify(json)\n      );\n    } catch (error) {\n      warning(\n        false,\n        `Failed to save applied view transitions in sessionStorage (${error}).`\n      );\n    }\n  }\n}\nfunction createDeferred() {\n  let resolve;\n  let reject;\n  let promise = new Promise((res, rej) => {\n    resolve = async (val) => {\n      res(val);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n    reject = async (error) => {\n      rej(error);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n  });\n  return {\n    promise,\n    //@ts-ignore\n    resolve,\n    //@ts-ignore\n    reject\n  };\n}\n\n// lib/context.ts\n\nvar DataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nDataRouterContext.displayName = \"DataRouter\";\nvar DataRouterStateContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nDataRouterStateContext.displayName = \"DataRouterState\";\nvar RSCRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(false);\nfunction useIsRSCRouterContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(RSCRouterContext);\n}\nvar ViewTransitionContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  isTransitioning: false\n});\nViewTransitionContext.displayName = \"ViewTransition\";\nvar FetchersContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(\n  /* @__PURE__ */ new Map()\n);\nFetchersContext.displayName = \"Fetchers\";\nvar AwaitContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nAwaitContext.displayName = \"Await\";\nvar AwaitContextProvider = (props) => react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, props);\nvar NavigationContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(\n  null\n);\nNavigationContext.displayName = \"Navigation\";\nvar LocationContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(\n  null\n);\nLocationContext.displayName = \"Location\";\nvar RouteContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nRouteContext.displayName = \"Route\";\nvar RouteErrorContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nRouteErrorContext.displayName = \"RouteError\";\nvar ENABLE_DEV_WARNINGS = true;\n\n// lib/hooks.tsx\n\nfunction useHref(to, { relative } = {}) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n  let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to, { relative });\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\nfunction useInRouterContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n  let { pathname } = useLocation();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => matchPath(pattern, decodePath(pathname)),\n    [pathname, pattern]\n  );\n}\nvar navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\n  if (!isStatic) {\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n  }\n}\nfunction useNavigate() {\n  let { isDataRoute } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (to, options = {}) => {\n      warning(activeRef.current, navigateEffectWarning);\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        options.relative === \"path\"\n      );\n      if (dataRouterContext == null && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n      }\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state,\n        options\n      );\n    },\n    [\n      basename,\n      navigator,\n      routePathnamesJson,\n      locationPathname,\n      dataRouterContext\n    ]\n  );\n  return navigate;\n}\nvar OutletContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useOutletContext() {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n  let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => outlet && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, { value: context }, outlet),\n    [outlet, context]\n  );\n}\nfunction useParams() {\n  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, { relative } = {}) {\n  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => resolveTo(\n      to,\n      JSON.parse(routePathnamesJson),\n      locationPathname,\n      relative === \"path\"\n    ),\n    [to, routePathnamesJson, locationPathname, relative]\n  );\n}\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, unstable_onError, future) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n  let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let { matches: parentMatches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (ENABLE_DEV_WARNINGS) {\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\") || parentPath.endsWith(\"*?\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at \"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    invariant(\n      parentPathnameBase === \"/\" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = pathname;\n  if (parentPathnameBase !== \"/\") {\n    let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n    let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n    remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n  }\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n  if (ENABLE_DEV_WARNINGS) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n    warning(\n      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n  let renderedMatches = _renderMatches(\n    matches && matches.map(\n      (match) => Object.assign({}, match, {\n        params: Object.assign({}, parentParams, match.params),\n        pathname: joinPaths([\n          parentPathnameBase,\n          // Re-encode pathnames that were decoded inside matchRoutes.\n          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses\n          // `new URL()` internally and we need to prevent it from treating\n          // them as separators\n          navigator.encodeLocation ? navigator.encodeLocation(\n            match.pathname.replace(/\\?/g, \"%3F\").replace(/#/g, \"%23\")\n          ).pathname : match.pathname\n        ]),\n        pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n          parentPathnameBase,\n          // Re-encode pathnames that were decoded inside matchRoutes\n          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses\n          // `new URL()` internally and we need to prevent it from treating\n          // them as separators\n          navigator.encodeLocation ? navigator.encodeLocation(\n            match.pathnameBase.replace(/\\?/g, \"%3F\").replace(/#/g, \"%23\")\n          ).pathname : match.pathnameBase\n        ])\n      })\n    ),\n    parentMatches,\n    dataRouterState,\n    unstable_onError,\n    future\n  );\n  if (locationArg && renderedMatches) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      LocationContext.Provider,\n      {\n        value: {\n          location: {\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\",\n            ...location\n          },\n          navigationType: \"POP\" /* Pop */\n        }\n      },\n      renderedMatches\n    );\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = { padding: \"0.5rem\", backgroundColor: lightgrey };\n  let codeStyles = { padding: \"2px 4px\", backgroundColor: lightgrey };\n  let devInfo = null;\n  if (ENABLE_DEV_WARNINGS) {\n    console.error(\n      \"Error handled by React Router default ErrorBoundary:\",\n      error\n    );\n    devInfo = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\u{1F4BF} Hey developer \\u{1F44B}\"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", { style: codeStyles }, \"ErrorBoundary\"), \" or\", \" \", /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", { style: codeStyles }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", { style: { fontStyle: \"italic\" } }, message), stack ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", { style: preStyles }, stack) : null, devInfo);\n}\nvar defaultErrorElement = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n    return {\n      error: props.error !== void 0 ? props.error : state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    if (this.props.unstable_onError) {\n      this.props.unstable_onError(error, errorInfo);\n    } else {\n      console.error(\n        \"React Router caught the following error during render\",\n        error\n      );\n    }\n  }\n  render() {\n    return this.state.error !== void 0 ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      RouteErrorContext.Provider,\n      {\n        value: this.state.error,\n        children: this.props.component\n      }\n    )) : this.props.children;\n  }\n};\nfunction RenderedRoute({ routeContext, match, children }) {\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, { value: routeContext }, children);\n}\nfunction _renderMatches(matches, parentMatches = [], dataRouterState = null, unstable_onError = null, future = null) {\n  if (matches == null) {\n    if (!dataRouterState) {\n      return null;\n    }\n    if (dataRouterState.errors) {\n      matches = dataRouterState.matches;\n    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n  let errors = dataRouterState?.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(\n      (m) => m.route.id && errors?.[m.route.id] !== void 0\n    );\n    invariant(\n      errorIndex >= 0,\n      `Could not find a matching route for errors on route IDs: ${Object.keys(\n        errors\n      ).join(\",\")}`\n    );\n    renderedMatches = renderedMatches.slice(\n      0,\n      Math.min(renderedMatches.length, errorIndex + 1)\n    );\n  }\n  let renderFallback = false;\n  let fallbackIndex = -1;\n  if (dataRouterState) {\n    for (let i = 0; i < renderedMatches.length; i++) {\n      let match = renderedMatches[i];\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n        fallbackIndex = i;\n      }\n      if (match.route.id) {\n        let { loaderData, errors: errors2 } = dataRouterState;\n        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);\n        if (match.route.lazy || needsToRunLoader) {\n          renderFallback = true;\n          if (fallbackIndex >= 0) {\n            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n          } else {\n            renderedMatches = [renderedMatches[0]];\n          }\n          break;\n        }\n      }\n    }\n  }\n  return renderedMatches.reduceRight(\n    (outlet, match, index) => {\n      let error;\n      let shouldRenderHydrateFallback = false;\n      let errorElement = null;\n      let hydrateFallbackElement = null;\n      if (dataRouterState) {\n        error = errors && match.route.id ? errors[match.route.id] : void 0;\n        errorElement = match.route.errorElement || defaultErrorElement;\n        if (renderFallback) {\n          if (fallbackIndex < 0 && index === 0) {\n            warningOnce(\n              \"route-fallback\",\n              false,\n              \"No `HydrateFallback` element provided to render during initial hydration\"\n            );\n            shouldRenderHydrateFallback = true;\n            hydrateFallbackElement = null;\n          } else if (fallbackIndex === index) {\n            shouldRenderHydrateFallback = true;\n            hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n          }\n        }\n      }\n      let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n      let getChildren = () => {\n        let children;\n        if (error) {\n          children = errorElement;\n        } else if (shouldRenderHydrateFallback) {\n          children = hydrateFallbackElement;\n        } else if (match.route.Component) {\n          children = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n        } else if (match.route.element) {\n          children = match.route.element;\n        } else {\n          children = outlet;\n        }\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n          RenderedRoute,\n          {\n            match,\n            routeContext: {\n              outlet,\n              matches: matches2,\n              isDataRoute: dataRouterState != null\n            },\n            children\n          }\n        );\n      };\n      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        RenderErrorBoundary,\n        {\n          location: dataRouterState.location,\n          revalidation: dataRouterState.revalidation,\n          component: errorElement,\n          error,\n          children: getChildren(),\n          routeContext: { outlet: null, matches: matches2, isDataRoute: true },\n          unstable_onError\n        }\n      ) : getChildren();\n    },\n    null\n  );\n}\nfunction getDataRouterConsoleError(hookName) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  invariant(route, getDataRouterConsoleError(hookName));\n  return route;\n}\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  invariant(\n    thisRoute.route.id,\n    `${hookName} can only be used on routes that contain a unique \"id\"`\n  );\n  return thisRoute.route.id;\n}\nfunction useRouteId() {\n  return useCurrentRouteId(\"useRouteId\" /* UseRouteId */);\n}\nfunction useNavigation() {\n  let state = useDataRouterState(\"useNavigation\" /* UseNavigation */);\n  return state.navigation;\n}\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(\"useRevalidator\" /* UseRevalidator */);\n  let state = useDataRouterState(\"useRevalidator\" /* UseRevalidator */);\n  let revalidate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {\n    await dataRouterContext.router.revalidate();\n  }, [dataRouterContext.router]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({ revalidate, state: state.revalidation }),\n    [revalidate, state.revalidation]\n  );\n}\nfunction useMatches() {\n  let { matches, loaderData } = useDataRouterState(\n    \"useMatches\" /* UseMatches */\n  );\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => matches.map((m) => convertRouteMatchToUiMatch(m, loaderData)),\n    [matches, loaderData]\n  );\n}\nfunction useLoaderData() {\n  let state = useDataRouterState(\"useLoaderData\" /* UseLoaderData */);\n  let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */);\n  return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(\"useRouteLoaderData\" /* UseRouteLoaderData */);\n  return state.loaderData[routeId];\n}\nfunction useActionData() {\n  let state = useDataRouterState(\"useActionData\" /* UseActionData */);\n  let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */);\n  return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n  let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n  let state = useDataRouterState(\"useRouteError\" /* UseRouteError */);\n  let routeId = useCurrentRouteId(\"useRouteError\" /* UseRouteError */);\n  if (error !== void 0) {\n    return error;\n  }\n  return state.errors?.[routeId];\n}\nfunction useAsyncValue() {\n  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n  return value?._data;\n}\nfunction useAsyncError() {\n  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n  return value?._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n  let { router, basename } = useDataRouterContext(\"useBlocker\" /* UseBlocker */);\n  let state = useDataRouterState(\"useBlocker\" /* UseBlocker */);\n  let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\");\n  let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (arg) => {\n      if (typeof shouldBlock !== \"function\") {\n        return !!shouldBlock;\n      }\n      if (basename === \"/\") {\n        return shouldBlock(arg);\n      }\n      let { currentLocation, nextLocation, historyAction } = arg;\n      return shouldBlock({\n        currentLocation: {\n          ...currentLocation,\n          pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n        },\n        nextLocation: {\n          ...nextLocation,\n          pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n        },\n        historyAction\n      });\n    },\n    [basename, shouldBlock]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n  let { router } = useDataRouterContext(\"useNavigate\" /* UseNavigateStable */);\n  let id = useCurrentRouteId(\"useNavigate\" /* UseNavigateStable */);\n  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (to, options = {}) => {\n      warning(activeRef.current, navigateEffectWarning);\n      if (!activeRef.current) return;\n      if (typeof to === \"number\") {\n        router.navigate(to);\n      } else {\n        await router.navigate(to, { fromRouteId: id, ...options });\n      }\n    },\n    [router, id]\n  );\n  return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\n// lib/components.tsx\n\n\n// lib/server-runtime/warnings.ts\nvar alreadyWarned2 = {};\nfunction warnOnce(condition, message) {\n  if (!condition && !alreadyWarned2[message]) {\n    alreadyWarned2[message] = true;\n    console.warn(message);\n  }\n}\n\n// lib/components.tsx\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (ENABLE_DEV_WARNINGS) {\n      if (route.element) {\n        warning(\n          false,\n          \"You should not include both `Component` and `element` on your route - `Component` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      element: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n      Component: void 0\n    });\n  }\n  if (route.HydrateFallback) {\n    if (ENABLE_DEV_WARNINGS) {\n      if (route.hydrateFallbackElement) {\n        warning(\n          false,\n          \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      hydrateFallbackElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),\n      HydrateFallback: void 0\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (ENABLE_DEV_WARNINGS) {\n      if (route.errorElement) {\n        warning(\n          false,\n          \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      errorElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n      ErrorBoundary: void 0\n    });\n  }\n  return updates;\n}\nvar hydrationRouteProperties = [\n  \"HydrateFallback\",\n  \"hydrateFallbackElement\"\n];\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    getContext: opts?.getContext,\n    future: opts?.future,\n    history: createMemoryHistory({\n      initialEntries: opts?.initialEntries,\n      initialIndex: opts?.initialIndex\n    }),\n    hydrationData: opts?.hydrationData,\n    routes,\n    hydrationRouteProperties,\n    mapRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation\n  }).initialize();\n}\nvar Deferred = class {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (value) => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = (reason) => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n};\nfunction shallowDiff(a, b) {\n  if (a === b) {\n    return false;\n  }\n  let aKeys = Object.keys(a);\n  let bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return true;\n  }\n  for (let key of aKeys) {\n    if (a[key] !== b[key]) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction UNSTABLE_TransitionEnabledRouterProvider({\n  router,\n  flushSync: reactDomFlushSyncImpl,\n  unstable_onError\n}) {\n  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */ new Map());\n  let [revalidating, startRevalidation] = react__WEBPACK_IMPORTED_MODULE_0__.useTransition();\n  let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n  router.__setPendingRerender = (promise) => startRevalidation(\n    // @ts-expect-error - need react 19 types for this to be async\n    async () => {\n      const rerender = await promise;\n      startRevalidation(() => {\n        rerender();\n      });\n    }\n  );\n  let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state2, opts) => router.navigate(to, {\n        state: state2,\n        preventScrollReset: opts?.preventScrollReset\n      }),\n      replace: (to, state2, opts) => router.navigate(to, {\n        replace: true,\n        state: state2,\n        preventScrollReset: opts?.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({\n      router,\n      navigator,\n      static: false,\n      basename,\n      unstable_onError\n    }),\n    [router, navigator, basename, unstable_onError]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    return router.subscribe(\n      (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {\n        newState.fetchers.forEach((fetcher, key) => {\n          if (fetcher.data !== void 0) {\n            fetcherData.current.set(key, fetcher.data);\n          }\n        });\n        deletedFetchers.forEach((key) => fetcherData.current.delete(key));\n        const diff = shallowDiff(state, newState);\n        if (!diff) return;\n        if (flushSync) {\n          if (reactDomFlushSyncImpl) {\n            reactDomFlushSyncImpl(() => setState(newState));\n          } else {\n            setState(newState);\n          }\n        } else {\n          react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => {\n            setState(newState);\n          });\n        }\n      }\n    );\n  }, [router, reactDomFlushSyncImpl, state]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    DataRouterStateContext.Provider,\n    {\n      value: {\n        ...state,\n        revalidation: revalidating ? \"loading\" : state.revalidation\n      }\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      Router,\n      {\n        basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator\n      },\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        MemoizedDataRoutes,\n        {\n          routes: router.routes,\n          future: router.future,\n          state,\n          unstable_onError\n        }\n      )\n    ))\n  )), null);\n}\nfunction RouterProvider({\n  router,\n  flushSync: reactDomFlushSyncImpl,\n  unstable_onError\n}) {\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n  let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */ new Map());\n  let logErrorsAndSetState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (newState) => {\n      setStateImpl((prevState) => {\n        if (newState.errors && unstable_onError) {\n          Object.entries(newState.errors).forEach(([routeId, error]) => {\n            if (prevState.errors?.[routeId] !== error) {\n              unstable_onError(error);\n            }\n          });\n        }\n        return newState;\n      });\n    },\n    [unstable_onError]\n  );\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {\n      newState.fetchers.forEach((fetcher, key) => {\n        if (fetcher.data !== void 0) {\n          fetcherData.current.set(key, fetcher.data);\n        }\n      });\n      deletedFetchers.forEach((key) => fetcherData.current.delete(key));\n      warnOnce(\n        flushSync === false || reactDomFlushSyncImpl != null,\n        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from \"react-router/dom\"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'\n      );\n      let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === \"function\";\n      warnOnce(\n        viewTransitionOpts == null || isViewTransitionAvailable,\n        \"You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.\"\n      );\n      if (!viewTransitionOpts || !isViewTransitionAvailable) {\n        if (reactDomFlushSyncImpl && flushSync) {\n          reactDomFlushSyncImpl(() => logErrorsAndSetState(newState));\n        } else {\n          react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => logErrorsAndSetState(newState));\n        }\n        return;\n      }\n      if (reactDomFlushSyncImpl && flushSync) {\n        reactDomFlushSyncImpl(() => {\n          if (transition) {\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n          }\n          setVtContext({\n            isTransitioning: true,\n            flushSync: true,\n            currentLocation: viewTransitionOpts.currentLocation,\n            nextLocation: viewTransitionOpts.nextLocation\n          });\n        });\n        let t = router.window.document.startViewTransition(() => {\n          reactDomFlushSyncImpl(() => logErrorsAndSetState(newState));\n        });\n        t.finished.finally(() => {\n          reactDomFlushSyncImpl(() => {\n            setRenderDfd(void 0);\n            setTransition(void 0);\n            setPendingState(void 0);\n            setVtContext({ isTransitioning: false });\n          });\n        });\n        reactDomFlushSyncImpl(() => setTransition(t));\n        return;\n      }\n      if (transition) {\n        renderDfd && renderDfd.resolve();\n        transition.skipTransition();\n        setInterruption({\n          state: newState,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      } else {\n        setPendingState(newState);\n        setVtContext({\n          isTransitioning: true,\n          flushSync: false,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      }\n    },\n    [\n      router.window,\n      reactDomFlushSyncImpl,\n      transition,\n      renderDfd,\n      logErrorsAndSetState\n    ]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition2 = router.window.document.startViewTransition(async () => {\n        react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => logErrorsAndSetState(newState));\n        await renderPromise;\n      });\n      transition2.finished.finally(() => {\n        setRenderDfd(void 0);\n        setTransition(void 0);\n        setPendingState(void 0);\n        setVtContext({ isTransitioning: false });\n      });\n      setTransition(transition2);\n    }\n  }, [pendingState, renderDfd, router.window, logErrorsAndSetState]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(void 0);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state2, opts) => router.navigate(to, {\n        state: state2,\n        preventScrollReset: opts?.preventScrollReset\n      }),\n      replace: (to, state2, opts) => router.navigate(to, {\n        replace: true,\n        state: state2,\n        preventScrollReset: opts?.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({\n      router,\n      navigator,\n      static: false,\n      basename,\n      unstable_onError\n    }),\n    [router, navigator, basename, unstable_onError]\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    Router,\n    {\n      basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      MemoizedDataRoutes,\n      {\n        routes: router.routes,\n        future: router.future,\n        state,\n        unstable_onError\n      }\n    )\n  ))))), null);\n}\nvar MemoizedDataRoutes = react__WEBPACK_IMPORTED_MODULE_0__.memo(DataRoutes);\nfunction DataRoutes({\n  routes,\n  future,\n  state,\n  unstable_onError\n}) {\n  return useRoutesImpl(routes, void 0, state, unstable_onError, future);\n}\nfunction MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex\n}) {\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (newState) => {\n      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction Navigate({\n  to,\n  replace: replace2,\n  state,\n  relative\n}) {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n  let { static: isStatic } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  warning(\n    !isStatic,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`\n  );\n  let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let navigate = useNavigate();\n  let path = resolveTo(\n    to,\n    getResolveToMatches(matches),\n    locationPathname,\n    relative === \"path\"\n  );\n  let jsonPath = JSON.stringify(path);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });\n  }, [navigate, jsonPath, relative, replace2, state]);\n  return null;\n}\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\nfunction Route(props) {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\nfunction Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = \"POP\" /* Pop */,\n  navigator,\n  static: staticProp = false\n}) {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`\n  );\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({\n      basename,\n      navigator,\n      static: staticProp,\n      future: {}\n    }),\n    [basename, navigator, staticProp]\n  );\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  warning(\n    locationContext != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL \"${pathname}${search}${hash}\" because it does not start with the basename, so the <Router> won't render anything.`\n  );\n  if (locationContext == null) {\n    return null;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, { children, value: locationContext }));\n}\nfunction Routes({\n  children,\n  location\n}) {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await({\n  children,\n  errorElement,\n  resolve\n}) {\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    AwaitErrorBoundary,\n    {\n      resolve,\n      errorElement,\n      unstable_onError: dataRouterContext?.unstable_onError\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children)\n  );\n}\nvar AwaitErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: null };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  componentDidCatch(error, errorInfo) {\n    if (this.props.unstable_onError) {\n      this.props.unstable_onError(error, errorInfo);\n    } else {\n      console.error(\n        \"<Await> caught the following error during render\",\n        error,\n        errorInfo\n      );\n    }\n  }\n  render() {\n    let { children, errorElement, resolve } = this.props;\n    let promise = null;\n    let status = 0 /* pending */;\n    if (!(resolve instanceof Promise)) {\n      status = 1 /* success */;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_data\", { get: () => resolve });\n    } else if (this.state.error) {\n      status = 2 /* error */;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {\n      });\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_error\", { get: () => renderError });\n    } else if (resolve._tracked) {\n      promise = resolve;\n      status = \"_error\" in promise ? 2 /* error */ : \"_data\" in promise ? 1 /* success */ : 0 /* pending */;\n    } else {\n      status = 0 /* pending */;\n      Object.defineProperty(resolve, \"_tracked\", { get: () => true });\n      promise = resolve.then(\n        (data2) => Object.defineProperty(resolve, \"_data\", { get: () => data2 }),\n        (error) => {\n          this.props.unstable_onError?.(error);\n          Object.defineProperty(resolve, \"_error\", { get: () => error });\n        }\n      );\n    }\n    if (status === 2 /* error */ && !errorElement) {\n      throw promise._error;\n    }\n    if (status === 2 /* error */) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, { value: promise, children: errorElement });\n    }\n    if (status === 1 /* success */) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, { value: promise, children });\n    }\n    throw promise;\n  }\n};\nfunction ResolveAwait({\n  children\n}) {\n  let data2 = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data2) : children;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath = []) {\n  let routes = [];\n  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index) => {\n    if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children, treePath)\n      );\n      return;\n    }\n    invariant(\n      element.type === Route,\n      `[${typeof element.type === \"string\" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n    invariant(\n      !element.props.index || !element.props.children,\n      \"An index route cannot have child routes.\"\n    );\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      middleware: element.props.middleware,\n      loader: element.props.loader,\n      action: element.props.action,\n      hydrateFallbackElement: element.props.hydrateFallbackElement,\n      HydrateFallback: element.props.HydrateFallback,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(\n        element.props.children,\n        treePath\n      );\n    }\n    routes.push(route);\n  });\n  return routes;\n}\nvar createRoutesFromElements = createRoutesFromChildren;\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\nfunction useRouteComponentProps() {\n  return {\n    params: useParams(),\n    loaderData: useLoaderData(),\n    actionData: useActionData(),\n    matches: useMatches()\n  };\n}\nfunction WithComponentProps({\n  children\n}) {\n  const props = useRouteComponentProps();\n  return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(children, props);\n}\nfunction withComponentProps(Component4) {\n  return function WithComponentProps2() {\n    const props = useRouteComponentProps();\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component4, props);\n  };\n}\nfunction useHydrateFallbackProps() {\n  return {\n    params: useParams(),\n    loaderData: useLoaderData(),\n    actionData: useActionData()\n  };\n}\nfunction WithHydrateFallbackProps({\n  children\n}) {\n  const props = useHydrateFallbackProps();\n  return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(children, props);\n}\nfunction withHydrateFallbackProps(HydrateFallback) {\n  return function WithHydrateFallbackProps2() {\n    const props = useHydrateFallbackProps();\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(HydrateFallback, props);\n  };\n}\nfunction useErrorBoundaryProps() {\n  return {\n    params: useParams(),\n    loaderData: useLoaderData(),\n    actionData: useActionData(),\n    error: useRouteError()\n  };\n}\nfunction WithErrorBoundaryProps({\n  children\n}) {\n  const props = useErrorBoundaryProps();\n  return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(children, props);\n}\nfunction withErrorBoundaryProps(ErrorBoundary) {\n  return function WithErrorBoundaryProps2() {\n    const props = useErrorBoundaryProps();\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ErrorBoundary, props);\n  };\n}\n\n// lib/dom/dom.ts\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && // Ignore everything but left clicks\n  (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event);\n}\nfunction createSearchParams(init = \"\") {\n  return new URLSearchParams(\n    typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {\n      let value = init[key];\n      return memo2.concat(\n        Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]\n      );\n    }, [])\n  );\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(\n        document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0\n      );\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\n  \"application/x-www-form-urlencoded\",\n  \"multipart/form-data\",\n  \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    warning(\n      false,\n      `\"${encType}\" is not a valid \\`encType\\` for \\`<Form>\\`/\\`<fetcher.Form>\\` and will default to \"${defaultEncType}\"`\n    );\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\n        `Cannot submit a <button> or <input type=\"submit\"> without a <form>`\n      );\n    }\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(form, target);\n    if (!isFormDataSubmitterSupported()) {\n      let { name, type, value } = target;\n      if (type === \"image\") {\n        let prefix = name ? `${name}.` : \"\";\n        formData.append(`${prefix}x`, \"0\");\n        formData.append(`${prefix}y`, \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\n      `Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`\n    );\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = void 0;\n  }\n  return { action, method: method.toLowerCase(), encType, formData, body };\n}\n\n// lib/dom/ssr/single-fetch.tsx\n\n\n// vendor/turbo-stream-v2/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred2 = class {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n};\nfunction createLineSplittingTransform() {\n  const decoder = new TextDecoder();\n  let leftover = \"\";\n  return new TransformStream({\n    transform(chunk, controller) {\n      const str = decoder.decode(chunk, { stream: true });\n      const parts = (leftover + str).split(\"\\n\");\n      leftover = parts.pop() || \"\";\n      for (const part of parts) {\n        controller.enqueue(part);\n      }\n    },\n    flush(controller) {\n      if (leftover) {\n        controller.enqueue(leftover);\n      }\n    }\n  });\n}\n\n// vendor/turbo-stream-v2/flatten.ts\nfunction flatten(input) {\n  const { indices } = this;\n  const existing = indices.get(input);\n  if (existing) return [existing];\n  if (input === void 0) return UNDEFINED;\n  if (input === null) return NULL;\n  if (Number.isNaN(input)) return NAN;\n  if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;\n  if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;\n  if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;\n  const index = this.index++;\n  indices.set(input, index);\n  stringify.call(this, input, index);\n  return index;\n}\nfunction stringify(input, index) {\n  const { deferred, plugins, postPlugins } = this;\n  const str = this.stringified;\n  const stack = [[input, index]];\n  while (stack.length > 0) {\n    const [input2, index2] = stack.pop();\n    const partsForObj = (obj) => Object.keys(obj).map((k) => `\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n    let error = null;\n    switch (typeof input2) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        str[index2] = JSON.stringify(input2);\n        break;\n      case \"bigint\":\n        str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n        break;\n      case \"symbol\": {\n        const keyFor = Symbol.keyFor(input2);\n        if (!keyFor) {\n          error = new Error(\n            \"Cannot encode symbol unless created with Symbol.for()\"\n          );\n        } else {\n          str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n        }\n        break;\n      }\n      case \"object\": {\n        if (!input2) {\n          str[index2] = `${NULL}`;\n          break;\n        }\n        const isArray = Array.isArray(input2);\n        let pluginHandled = false;\n        if (!isArray && plugins) {\n          for (const plugin of plugins) {\n            const pluginResult = plugin(input2);\n            if (Array.isArray(pluginResult)) {\n              pluginHandled = true;\n              const [pluginIdentifier, ...rest] = pluginResult;\n              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n              if (rest.length > 0) {\n                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n              }\n              str[index2] += \"]\";\n              break;\n            }\n          }\n        }\n        if (!pluginHandled) {\n          let result = isArray ? \"[\" : \"{\";\n          if (isArray) {\n            for (let i = 0; i < input2.length; i++)\n              result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n            str[index2] = `${result}]`;\n          } else if (input2 instanceof Date) {\n            const dateTime = input2.getTime();\n            str[index2] = `[\"${TYPE_DATE}\",${Number.isNaN(dateTime) ? JSON.stringify(\"invalid\") : dateTime}]`;\n          } else if (input2 instanceof URL) {\n            str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n          } else if (input2 instanceof RegExp) {\n            str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(\n              input2.source\n            )},${JSON.stringify(input2.flags)}]`;\n          } else if (input2 instanceof Set) {\n            if (input2.size > 0) {\n              str[index2] = `[\"${TYPE_SET}\",${[...input2].map((val) => flatten.call(this, val)).join(\",\")}]`;\n            } else {\n              str[index2] = `[\"${TYPE_SET}\"]`;\n            }\n          } else if (input2 instanceof Map) {\n            if (input2.size > 0) {\n              str[index2] = `[\"${TYPE_MAP}\",${[...input2].flatMap(([k, v]) => [\n                flatten.call(this, k),\n                flatten.call(this, v)\n              ]).join(\",\")}]`;\n            } else {\n              str[index2] = `[\"${TYPE_MAP}\"]`;\n            }\n          } else if (input2 instanceof Promise) {\n            str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n            deferred[index2] = input2;\n          } else if (input2 instanceof Error) {\n            str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n            if (input2.name !== \"Error\") {\n              str[index2] += `,${JSON.stringify(input2.name)}`;\n            }\n            str[index2] += \"]\";\n          } else if (Object.getPrototypeOf(input2) === null) {\n            str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n          } else if (isPlainObject(input2)) {\n            str[index2] = `{${partsForObj(input2)}}`;\n          } else {\n            error = new Error(\"Cannot encode object with prototype\");\n          }\n        }\n        break;\n      }\n      default: {\n        const isArray = Array.isArray(input2);\n        let pluginHandled = false;\n        if (!isArray && plugins) {\n          for (const plugin of plugins) {\n            const pluginResult = plugin(input2);\n            if (Array.isArray(pluginResult)) {\n              pluginHandled = true;\n              const [pluginIdentifier, ...rest] = pluginResult;\n              str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n              if (rest.length > 0) {\n                str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n              }\n              str[index2] += \"]\";\n              break;\n            }\n          }\n        }\n        if (!pluginHandled) {\n          error = new Error(\"Cannot encode function or unexpected type\");\n        }\n      }\n    }\n    if (error) {\n      let pluginHandled = false;\n      if (postPlugins) {\n        for (const plugin of postPlugins) {\n          const pluginResult = plugin(input2);\n          if (Array.isArray(pluginResult)) {\n            pluginHandled = true;\n            const [pluginIdentifier, ...rest] = pluginResult;\n            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n            if (rest.length > 0) {\n              str[index2] += `,${rest.map((v) => flatten.call(this, v)).join(\",\")}`;\n            }\n            str[index2] += \"]\";\n            break;\n          }\n        }\n      }\n      if (!pluginHandled) {\n        throw error;\n      }\n    }\n  }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\0\");\nfunction isPlainObject(thing) {\n  const proto = Object.getPrototypeOf(thing);\n  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\0\") === objectProtoNames;\n}\n\n// vendor/turbo-stream-v2/unflatten.ts\nvar globalObj = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n  const { hydrated, values } = this;\n  if (typeof parsed === \"number\") return hydrate.call(this, parsed);\n  if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();\n  const startIndex = values.length;\n  for (const value of parsed) {\n    values.push(value);\n  }\n  hydrated.length = values.length;\n  return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n  const { hydrated, values, deferred, plugins } = this;\n  let result;\n  const stack = [\n    [\n      index,\n      (v) => {\n        result = v;\n      }\n    ]\n  ];\n  let postRun = [];\n  while (stack.length > 0) {\n    const [index2, set] = stack.pop();\n    switch (index2) {\n      case UNDEFINED:\n        set(void 0);\n        continue;\n      case NULL:\n        set(null);\n        continue;\n      case NAN:\n        set(NaN);\n        continue;\n      case POSITIVE_INFINITY:\n        set(Infinity);\n        continue;\n      case NEGATIVE_INFINITY:\n        set(-Infinity);\n        continue;\n      case NEGATIVE_ZERO:\n        set(-0);\n        continue;\n    }\n    if (hydrated[index2]) {\n      set(hydrated[index2]);\n      continue;\n    }\n    const value = values[index2];\n    if (!value || typeof value !== \"object\") {\n      hydrated[index2] = value;\n      set(value);\n      continue;\n    }\n    if (Array.isArray(value)) {\n      if (typeof value[0] === \"string\") {\n        const [type, b, c] = value;\n        switch (type) {\n          case TYPE_DATE:\n            set(hydrated[index2] = new Date(b));\n            continue;\n          case TYPE_URL:\n            set(hydrated[index2] = new URL(b));\n            continue;\n          case TYPE_BIGINT:\n            set(hydrated[index2] = BigInt(b));\n            continue;\n          case TYPE_REGEXP:\n            set(hydrated[index2] = new RegExp(b, c));\n            continue;\n          case TYPE_SYMBOL:\n            set(hydrated[index2] = Symbol.for(b));\n            continue;\n          case TYPE_SET:\n            const newSet = /* @__PURE__ */ new Set();\n            hydrated[index2] = newSet;\n            for (let i = value.length - 1; i > 0; i--)\n              stack.push([\n                value[i],\n                (v) => {\n                  newSet.add(v);\n                }\n              ]);\n            set(newSet);\n            continue;\n          case TYPE_MAP:\n            const map = /* @__PURE__ */ new Map();\n            hydrated[index2] = map;\n            for (let i = value.length - 2; i > 0; i -= 2) {\n              const r = [];\n              stack.push([\n                value[i + 1],\n                (v) => {\n                  r[1] = v;\n                }\n              ]);\n              stack.push([\n                value[i],\n                (k) => {\n                  r[0] = k;\n                }\n              ]);\n              postRun.push(() => {\n                map.set(r[0], r[1]);\n              });\n            }\n            set(map);\n            continue;\n          case TYPE_NULL_OBJECT:\n            const obj = /* @__PURE__ */ Object.create(null);\n            hydrated[index2] = obj;\n            for (const key of Object.keys(b).reverse()) {\n              const r = [];\n              stack.push([\n                b[key],\n                (v) => {\n                  r[1] = v;\n                }\n              ]);\n              stack.push([\n                Number(key.slice(1)),\n                (k) => {\n                  r[0] = k;\n                }\n              ]);\n              postRun.push(() => {\n                obj[r[0]] = r[1];\n              });\n            }\n            set(obj);\n            continue;\n          case TYPE_PROMISE:\n            if (hydrated[b]) {\n              set(hydrated[index2] = hydrated[b]);\n            } else {\n              const d = new Deferred2();\n              deferred[b] = d;\n              set(hydrated[index2] = d.promise);\n            }\n            continue;\n          case TYPE_ERROR:\n            const [, message, errorType] = value;\n            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n            hydrated[index2] = error;\n            set(error);\n            continue;\n          case TYPE_PREVIOUS_RESOLVED:\n            set(hydrated[index2] = hydrated[b]);\n            continue;\n          default:\n            if (Array.isArray(plugins)) {\n              const r = [];\n              const vals = value.slice(1);\n              for (let i = 0; i < vals.length; i++) {\n                const v = vals[i];\n                stack.push([\n                  v,\n                  (v2) => {\n                    r[i] = v2;\n                  }\n                ]);\n              }\n              postRun.push(() => {\n                for (const plugin of plugins) {\n                  const result2 = plugin(value[0], ...r);\n                  if (result2) {\n                    set(hydrated[index2] = result2.value);\n                    return;\n                  }\n                }\n                throw new SyntaxError();\n              });\n              continue;\n            }\n            throw new SyntaxError();\n        }\n      } else {\n        const array = [];\n        hydrated[index2] = array;\n        for (let i = 0; i < value.length; i++) {\n          const n = value[i];\n          if (n !== HOLE) {\n            stack.push([\n              n,\n              (v) => {\n                array[i] = v;\n              }\n            ]);\n          }\n        }\n        set(array);\n        continue;\n      }\n    } else {\n      const object = {};\n      hydrated[index2] = object;\n      for (const key of Object.keys(value).reverse()) {\n        const r = [];\n        stack.push([\n          value[key],\n          (v) => {\n            r[1] = v;\n          }\n        ]);\n        stack.push([\n          Number(key.slice(1)),\n          (k) => {\n            r[0] = k;\n          }\n        ]);\n        postRun.push(() => {\n          object[r[0]] = r[1];\n        });\n      }\n      set(object);\n      continue;\n    }\n  }\n  while (postRun.length > 0) {\n    postRun.pop()();\n  }\n  return result;\n}\n\n// vendor/turbo-stream-v2/turbo-stream.ts\nasync function decode(readable, options) {\n  const { plugins } = options ?? {};\n  const done = new Deferred2();\n  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n  const decoder = {\n    values: [],\n    hydrated: [],\n    deferred: {},\n    plugins\n  };\n  const decoded = await decodeInitial.call(decoder, reader);\n  let donePromise = done.promise;\n  if (decoded.done) {\n    done.resolve();\n  } else {\n    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) => {\n      for (const deferred of Object.values(decoder.deferred)) {\n        deferred.reject(reason);\n      }\n      done.reject(reason);\n    });\n  }\n  return {\n    done: donePromise.then(() => reader.closed),\n    value: decoded.value\n  };\n}\nasync function decodeInitial(reader) {\n  const read = await reader.read();\n  if (!read.value) {\n    throw new SyntaxError();\n  }\n  let line;\n  try {\n    line = JSON.parse(read.value);\n  } catch (reason) {\n    throw new SyntaxError();\n  }\n  return {\n    done: read.done,\n    value: unflatten.call(this, line)\n  };\n}\nasync function decodeDeferred(reader) {\n  let read = await reader.read();\n  while (!read.done) {\n    if (!read.value) continue;\n    const line = read.value;\n    switch (line[0]) {\n      case TYPE_PROMISE: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.resolve(value);\n        break;\n      }\n      case TYPE_ERROR: {\n        const colonIndex = line.indexOf(\":\");\n        const deferredId = Number(line.slice(1, colonIndex));\n        const deferred = this.deferred[deferredId];\n        if (!deferred) {\n          throw new Error(`Deferred ID ${deferredId} not found in stream`);\n        }\n        const lineData = line.slice(colonIndex + 1);\n        let jsonLine;\n        try {\n          jsonLine = JSON.parse(lineData);\n        } catch (reason) {\n          throw new SyntaxError();\n        }\n        const value = unflatten.call(this, jsonLine);\n        deferred.reject(value);\n        break;\n      }\n      default:\n        throw new SyntaxError();\n    }\n    read = await reader.read();\n  }\n}\nfunction encode(input, options) {\n  const { plugins, postPlugins, signal } = options ?? {};\n  const encoder = {\n    deferred: {},\n    index: 0,\n    indices: /* @__PURE__ */ new Map(),\n    stringified: [],\n    plugins,\n    postPlugins,\n    signal\n  };\n  const textEncoder = new TextEncoder();\n  let lastSentIndex = 0;\n  const readable = new ReadableStream({\n    async start(controller) {\n      const id = flatten.call(encoder, input);\n      if (Array.isArray(id)) {\n        throw new Error(\"This should never happen\");\n      }\n      if (id < 0) {\n        controller.enqueue(textEncoder.encode(`${id}\n`));\n      } else {\n        controller.enqueue(\n          textEncoder.encode(`[${encoder.stringified.join(\",\")}]\n`)\n        );\n        lastSentIndex = encoder.stringified.length - 1;\n      }\n      const seenPromises = /* @__PURE__ */ new WeakSet();\n      if (Object.keys(encoder.deferred).length) {\n        let raceDone;\n        const racePromise = new Promise((resolve, reject) => {\n          raceDone = resolve;\n          if (signal) {\n            const rejectPromise = () => reject(signal.reason || new Error(\"Signal was aborted.\"));\n            if (signal.aborted) {\n              rejectPromise();\n            } else {\n              signal.addEventListener(\"abort\", (event) => {\n                rejectPromise();\n              });\n            }\n          }\n        });\n        while (Object.keys(encoder.deferred).length > 0) {\n          for (const [deferredId, deferred] of Object.entries(\n            encoder.deferred\n          )) {\n            if (seenPromises.has(deferred)) continue;\n            seenPromises.add(\n              // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n              encoder.deferred[Number(deferredId)] = Promise.race([\n                racePromise,\n                deferred\n              ]).then(\n                (resolved) => {\n                  const id2 = flatten.call(encoder, resolved);\n                  if (Array.isArray(id2)) {\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                      )\n                    );\n                    encoder.index++;\n                    lastSentIndex++;\n                  } else if (id2 < 0) {\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_PROMISE}${deferredId}:${id2}\n`\n                      )\n                    );\n                  } else {\n                    const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_PROMISE}${deferredId}:[${values}]\n`\n                      )\n                    );\n                    lastSentIndex = encoder.stringified.length - 1;\n                  }\n                },\n                (reason) => {\n                  if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                    reason = new Error(\"An unknown error occurred\");\n                  }\n                  const id2 = flatten.call(encoder, reason);\n                  if (Array.isArray(id2)) {\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`\n                      )\n                    );\n                    encoder.index++;\n                    lastSentIndex++;\n                  } else if (id2 < 0) {\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_ERROR}${deferredId}:${id2}\n`\n                      )\n                    );\n                  } else {\n                    const values = encoder.stringified.slice(lastSentIndex + 1).join(\",\");\n                    controller.enqueue(\n                      textEncoder.encode(\n                        `${TYPE_ERROR}${deferredId}:[${values}]\n`\n                      )\n                    );\n                    lastSentIndex = encoder.stringified.length - 1;\n                  }\n                }\n              ).finally(() => {\n                delete encoder.deferred[Number(deferredId)];\n              })\n            );\n          }\n          await Promise.race(Object.values(encoder.deferred));\n        }\n        raceDone();\n      }\n      await Promise.all(Object.values(encoder.deferred));\n      controller.close();\n    }\n  });\n  return readable;\n}\n\n// lib/dom/ssr/data.ts\nasync function createRequestInit(request) {\n  let init = { signal: request.signal };\n  if (request.method !== \"GET\") {\n    init.method = request.method;\n    let contentType = request.headers.get(\"Content-Type\");\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      init.headers = { \"Content-Type\": contentType };\n      init.body = JSON.stringify(await request.json());\n    } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n      init.headers = { \"Content-Type\": contentType };\n      init.body = await request.text();\n    } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n      init.body = new URLSearchParams(await request.text());\n    } else {\n      init.body = await request.formData();\n    }\n  }\n  return init;\n}\n\n// lib/dom/ssr/markup.ts\nvar ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);\n}\n\n// lib/dom/ssr/invariant.ts\nfunction invariant2(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\n// lib/dom/ssr/single-fetch.tsx\nvar SingleFetchRedirectSymbol = Symbol(\"SingleFetchRedirect\");\nvar SingleFetchNoResultError = class extends Error {\n};\nvar SINGLE_FETCH_REDIRECT_STATUS = 202;\nvar NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205]);\nfunction StreamTransfer({\n  context,\n  identifier,\n  reader,\n  textDecoder,\n  nonce\n}) {\n  if (!context.renderMeta || !context.renderMeta.didRenderScripts) {\n    return null;\n  }\n  if (!context.renderMeta.streamCache) {\n    context.renderMeta.streamCache = {};\n  }\n  let { streamCache } = context.renderMeta;\n  let promise = streamCache[identifier];\n  if (!promise) {\n    promise = streamCache[identifier] = reader.read().then((result) => {\n      streamCache[identifier].result = {\n        done: result.done,\n        value: textDecoder.decode(result.value, { stream: true })\n      };\n    }).catch((e) => {\n      streamCache[identifier].error = e;\n    });\n  }\n  if (promise.error) {\n    throw promise.error;\n  }\n  if (promise.result === void 0) {\n    throw promise;\n  }\n  let { done, value } = promise.result;\n  let scriptTag = value ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"script\",\n    {\n      nonce,\n      dangerouslySetInnerHTML: {\n        __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(\n          JSON.stringify(value)\n        )});`\n      }\n    }\n  ) : null;\n  if (done) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, scriptTag, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"script\",\n      {\n        nonce,\n        dangerouslySetInnerHTML: {\n          __html: `window.__reactRouterContext.streamController.close();`\n        }\n      }\n    ));\n  } else {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, scriptTag, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      StreamTransfer,\n      {\n        context,\n        identifier: identifier + 1,\n        reader,\n        textDecoder,\n        nonce\n      }\n    )));\n  }\n}\nfunction getTurboStreamSingleFetchDataStrategy(getRouter, manifest, routeModules, ssr, basename) {\n  let dataStrategy = getSingleFetchDataStrategyImpl(\n    getRouter,\n    (match) => {\n      let manifestRoute = manifest.routes[match.route.id];\n      invariant2(manifestRoute, \"Route not found in manifest\");\n      let routeModule = routeModules[match.route.id];\n      return {\n        hasLoader: manifestRoute.hasLoader,\n        hasClientLoader: manifestRoute.hasClientLoader,\n        hasShouldRevalidate: Boolean(routeModule?.shouldRevalidate)\n      };\n    },\n    fetchAndDecodeViaTurboStream,\n    ssr,\n    basename\n  );\n  return async (args) => args.runClientMiddleware(dataStrategy);\n}\nfunction getSingleFetchDataStrategyImpl(getRouter, getRouteInfo, fetchAndDecode, ssr, basename, shouldAllowOptOut = () => true) {\n  return async (args) => {\n    let { request, matches, fetcherKey } = args;\n    let router = getRouter();\n    if (request.method !== \"GET\") {\n      return singleFetchActionStrategy(args, fetchAndDecode, basename);\n    }\n    let foundRevalidatingServerLoader = matches.some((m) => {\n      let { hasLoader, hasClientLoader } = getRouteInfo(m);\n      return m.unstable_shouldCallHandler() && hasLoader && !hasClientLoader;\n    });\n    if (!ssr && !foundRevalidatingServerLoader) {\n      return nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename);\n    }\n    if (fetcherKey) {\n      return singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename);\n    }\n    return singleFetchLoaderNavigationStrategy(\n      args,\n      router,\n      getRouteInfo,\n      fetchAndDecode,\n      ssr,\n      basename,\n      shouldAllowOptOut\n    );\n  };\n}\nasync function singleFetchActionStrategy(args, fetchAndDecode, basename) {\n  let actionMatch = args.matches.find((m) => m.unstable_shouldCallHandler());\n  invariant2(actionMatch, \"No action match found\");\n  let actionStatus = void 0;\n  let result = await actionMatch.resolve(async (handler) => {\n    let result2 = await handler(async () => {\n      let { data: data2, status } = await fetchAndDecode(args, basename, [\n        actionMatch.route.id\n      ]);\n      actionStatus = status;\n      return unwrapSingleFetchResult(data2, actionMatch.route.id);\n    });\n    return result2;\n  });\n  if (isResponse(result.result) || isRouteErrorResponse(result.result) || isDataWithResponseInit(result.result)) {\n    return { [actionMatch.route.id]: result };\n  }\n  return {\n    [actionMatch.route.id]: {\n      type: result.type,\n      result: data(result.result, actionStatus)\n    }\n  };\n}\nasync function nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename) {\n  let matchesToLoad = args.matches.filter(\n    (m) => m.unstable_shouldCallHandler()\n  );\n  let results = {};\n  await Promise.all(\n    matchesToLoad.map(\n      (m) => m.resolve(async (handler) => {\n        try {\n          let { hasClientLoader } = getRouteInfo(m);\n          let routeId = m.route.id;\n          let result = hasClientLoader ? await handler(async () => {\n            let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);\n            return unwrapSingleFetchResult(data2, routeId);\n          }) : await handler();\n          results[m.route.id] = { type: \"data\", result };\n        } catch (e) {\n          results[m.route.id] = { type: \"error\", result: e };\n        }\n      })\n    )\n  );\n  return results;\n}\nasync function singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename, shouldAllowOptOut = () => true) {\n  let routesParams = /* @__PURE__ */ new Set();\n  let foundOptOutRoute = false;\n  let routeDfds = args.matches.map(() => createDeferred2());\n  let singleFetchDfd = createDeferred2();\n  let results = {};\n  let resolvePromise = Promise.all(\n    args.matches.map(\n      async (m, i) => m.resolve(async (handler) => {\n        routeDfds[i].resolve();\n        let routeId = m.route.id;\n        let { hasLoader, hasClientLoader, hasShouldRevalidate } = getRouteInfo(m);\n        let defaultShouldRevalidate = !m.unstable_shouldRevalidateArgs || m.unstable_shouldRevalidateArgs.actionStatus == null || m.unstable_shouldRevalidateArgs.actionStatus < 400;\n        let shouldCall = m.unstable_shouldCallHandler(defaultShouldRevalidate);\n        if (!shouldCall) {\n          foundOptOutRoute || (foundOptOutRoute = m.unstable_shouldRevalidateArgs != null && // This is a revalidation,\n          hasLoader && // for a route with a server loader,\n          hasShouldRevalidate === true);\n          return;\n        }\n        if (shouldAllowOptOut(m) && hasClientLoader) {\n          if (hasLoader) {\n            foundOptOutRoute = true;\n          }\n          try {\n            let result = await handler(async () => {\n              let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);\n              return unwrapSingleFetchResult(data2, routeId);\n            });\n            results[routeId] = { type: \"data\", result };\n          } catch (e) {\n            results[routeId] = { type: \"error\", result: e };\n          }\n          return;\n        }\n        if (hasLoader) {\n          routesParams.add(routeId);\n        }\n        try {\n          let result = await handler(async () => {\n            let data2 = await singleFetchDfd.promise;\n            return unwrapSingleFetchResult(data2, routeId);\n          });\n          results[routeId] = { type: \"data\", result };\n        } catch (e) {\n          results[routeId] = { type: \"error\", result: e };\n        }\n      })\n    )\n  );\n  await Promise.all(routeDfds.map((d) => d.promise));\n  let isInitialLoad = !router.state.initialized && router.state.navigation.state === \"idle\";\n  if ((isInitialLoad || routesParams.size === 0) && !window.__reactRouterHdrActive) {\n    singleFetchDfd.resolve({ routes: {} });\n  } else {\n    let targetRoutes = ssr && foundOptOutRoute && routesParams.size > 0 ? [...routesParams.keys()] : void 0;\n    try {\n      let data2 = await fetchAndDecode(args, basename, targetRoutes);\n      singleFetchDfd.resolve(data2.data);\n    } catch (e) {\n      singleFetchDfd.reject(e);\n    }\n  }\n  await resolvePromise;\n  await bubbleMiddlewareErrors(\n    singleFetchDfd.promise,\n    args.matches,\n    routesParams,\n    results\n  );\n  return results;\n}\nasync function bubbleMiddlewareErrors(singleFetchPromise, matches, routesParams, results) {\n  try {\n    let middlewareError;\n    let fetchedData = await singleFetchPromise;\n    if (\"routes\" in fetchedData) {\n      for (let match of matches) {\n        if (match.route.id in fetchedData.routes) {\n          let routeResult = fetchedData.routes[match.route.id];\n          if (\"error\" in routeResult) {\n            middlewareError = routeResult.error;\n            if (results[match.route.id]?.result == null) {\n              results[match.route.id] = {\n                type: \"error\",\n                result: middlewareError\n              };\n            }\n            break;\n          }\n        }\n      }\n    }\n    if (middlewareError !== void 0) {\n      Array.from(routesParams.values()).forEach((routeId) => {\n        if (results[routeId].result instanceof SingleFetchNoResultError) {\n          results[routeId].result = middlewareError;\n        }\n      });\n    }\n  } catch (e) {\n  }\n}\nasync function singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename) {\n  let fetcherMatch = args.matches.find((m) => m.unstable_shouldCallHandler());\n  invariant2(fetcherMatch, \"No fetcher match found\");\n  let routeId = fetcherMatch.route.id;\n  let result = await fetcherMatch.resolve(\n    async (handler) => handler(async () => {\n      let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);\n      return unwrapSingleFetchResult(data2, routeId);\n    })\n  );\n  return { [fetcherMatch.route.id]: result };\n}\nfunction stripIndexParam(url) {\n  let indexValues = url.searchParams.getAll(\"index\");\n  url.searchParams.delete(\"index\");\n  let indexValuesToKeep = [];\n  for (let indexValue of indexValues) {\n    if (indexValue) {\n      indexValuesToKeep.push(indexValue);\n    }\n  }\n  for (let toKeep of indexValuesToKeep) {\n    url.searchParams.append(\"index\", toKeep);\n  }\n  return url;\n}\nfunction singleFetchUrl(reqUrl, basename, extension) {\n  let url = typeof reqUrl === \"string\" ? new URL(\n    reqUrl,\n    // This can be called during the SSR flow via PrefetchPageLinksImpl so\n    // don't assume window is available\n    typeof window === \"undefined\" ? \"server://singlefetch/\" : window.location.origin\n  ) : reqUrl;\n  if (url.pathname === \"/\") {\n    url.pathname = `_root.${extension}`;\n  } else if (basename && stripBasename(url.pathname, basename) === \"/\") {\n    url.pathname = `${basename.replace(/\\/$/, \"\")}/_root.${extension}`;\n  } else {\n    url.pathname = `${url.pathname.replace(/\\/$/, \"\")}.${extension}`;\n  }\n  return url;\n}\nasync function fetchAndDecodeViaTurboStream(args, basename, targetRoutes) {\n  let { request } = args;\n  let url = singleFetchUrl(request.url, basename, \"data\");\n  if (request.method === \"GET\") {\n    url = stripIndexParam(url);\n    if (targetRoutes) {\n      url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n    }\n  }\n  let res = await fetch(url, await createRequestInit(request));\n  if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\n    throw new ErrorResponseImpl(res.status, res.statusText, await res.text());\n  }\n  if (res.status === 204 && res.headers.has(\"X-Remix-Redirect\")) {\n    return {\n      status: SINGLE_FETCH_REDIRECT_STATUS,\n      data: {\n        redirect: {\n          redirect: res.headers.get(\"X-Remix-Redirect\"),\n          status: Number(res.headers.get(\"X-Remix-Status\") || \"302\"),\n          revalidate: res.headers.get(\"X-Remix-Revalidate\") === \"true\",\n          reload: res.headers.get(\"X-Remix-Reload-Document\") === \"true\",\n          replace: res.headers.get(\"X-Remix-Replace\") === \"true\"\n        }\n      }\n    };\n  }\n  if (NO_BODY_STATUS_CODES.has(res.status)) {\n    let routes = {};\n    if (targetRoutes && request.method !== \"GET\") {\n      routes[targetRoutes[0]] = { data: void 0 };\n    }\n    return {\n      status: res.status,\n      data: { routes }\n    };\n  }\n  invariant2(res.body, \"No response body to decode\");\n  try {\n    let decoded = await decodeViaTurboStream(res.body, window);\n    let data2;\n    if (request.method === \"GET\") {\n      let typed = decoded.value;\n      if (SingleFetchRedirectSymbol in typed) {\n        data2 = { redirect: typed[SingleFetchRedirectSymbol] };\n      } else {\n        data2 = { routes: typed };\n      }\n    } else {\n      let typed = decoded.value;\n      let routeId = targetRoutes?.[0];\n      invariant2(routeId, \"No routeId found for single fetch call decoding\");\n      if (\"redirect\" in typed) {\n        data2 = { redirect: typed };\n      } else {\n        data2 = { routes: { [routeId]: typed } };\n      }\n    }\n    return { status: res.status, data: data2 };\n  } catch (e) {\n    throw new Error(\"Unable to decode turbo-stream response\");\n  }\n}\nfunction decodeViaTurboStream(body, global) {\n  return decode(body, {\n    plugins: [\n      (type, ...rest) => {\n        if (type === \"SanitizedError\") {\n          let [name, message, stack] = rest;\n          let Constructor = Error;\n          if (name && name in global && typeof global[name] === \"function\") {\n            Constructor = global[name];\n          }\n          let error = new Constructor(message);\n          error.stack = stack;\n          return { value: error };\n        }\n        if (type === \"ErrorResponse\") {\n          let [data2, status, statusText] = rest;\n          return {\n            value: new ErrorResponseImpl(status, statusText, data2)\n          };\n        }\n        if (type === \"SingleFetchRedirect\") {\n          return { value: { [SingleFetchRedirectSymbol]: rest[0] } };\n        }\n        if (type === \"SingleFetchClassInstance\") {\n          return { value: rest[0] };\n        }\n        if (type === \"SingleFetchFallback\") {\n          return { value: void 0 };\n        }\n      }\n    ]\n  });\n}\nfunction unwrapSingleFetchResult(result, routeId) {\n  if (\"redirect\" in result) {\n    let {\n      redirect: location,\n      revalidate,\n      reload,\n      replace: replace2,\n      status\n    } = result.redirect;\n    throw redirect(location, {\n      status,\n      headers: {\n        // Three R's of redirecting (lol Veep)\n        ...revalidate ? { \"X-Remix-Revalidate\": \"yes\" } : null,\n        ...reload ? { \"X-Remix-Reload-Document\": \"yes\" } : null,\n        ...replace2 ? { \"X-Remix-Replace\": \"yes\" } : null\n      }\n    });\n  }\n  let routeResult = result.routes[routeId];\n  if (routeResult == null) {\n    throw new SingleFetchNoResultError(\n      `No result found for routeId \"${routeId}\"`\n    );\n  } else if (\"error\" in routeResult) {\n    throw routeResult.error;\n  } else if (\"data\" in routeResult) {\n    return routeResult.data;\n  } else {\n    throw new Error(`Invalid response found for routeId \"${routeId}\"`);\n  }\n}\nfunction createDeferred2() {\n  let resolve;\n  let reject;\n  let promise = new Promise((res, rej) => {\n    resolve = async (val) => {\n      res(val);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n    reject = async (error) => {\n      rej(error);\n      try {\n        await promise;\n      } catch (e) {\n      }\n    };\n  });\n  return {\n    promise,\n    //@ts-ignore\n    resolve,\n    //@ts-ignore\n    reject\n  };\n}\n\n// lib/dom/ssr/errorBoundaries.tsx\n\n\n// lib/dom/ssr/components.tsx\n\n\n// lib/dom/ssr/routeModules.ts\nasync function loadRouteModule(route, routeModulesCache) {\n  if (route.id in routeModulesCache) {\n    return routeModulesCache[route.id];\n  }\n  try {\n    let routeModule = await import(\n      /* @vite-ignore */\n      /* webpackIgnore: true */\n      route.module\n    );\n    routeModulesCache[route.id] = routeModule;\n    return routeModule;\n  } catch (error) {\n    console.error(\n      `Error loading route module \\`${route.module}\\`, reloading page...`\n    );\n    console.error(error);\n    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error\n    /* unsupported import.meta.hot */ undefined) {}\n    window.location.reload();\n    return new Promise(() => {\n    });\n  }\n}\n\n// lib/dom/ssr/links.ts\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n  let descriptors = matches.map((match) => {\n    let module = routeModules[match.route.id];\n    let route = manifest.routes[match.route.id];\n    return [\n      route && route.css ? route.css.map((href) => ({ rel: \"stylesheet\", href })) : [],\n      module?.links?.() || []\n    ];\n  }).flat(2);\n  let preloads = getModuleLinkHrefs(matches, manifest);\n  return dedupeLinkDescriptors(descriptors, preloads);\n}\nfunction getRouteCssDescriptors(route) {\n  if (!route.css) return [];\n  return route.css.map((href) => ({ rel: \"stylesheet\", href }));\n}\nasync function prefetchRouteCss(route) {\n  if (!route.css) return;\n  let descriptors = getRouteCssDescriptors(route);\n  await Promise.all(descriptors.map(prefetchStyleLink));\n}\nasync function prefetchStyleLinks(route, routeModule) {\n  if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n  let descriptors = [];\n  if (route.css) {\n    descriptors.push(...getRouteCssDescriptors(route));\n  }\n  if (routeModule.links) {\n    descriptors.push(...routeModule.links());\n  }\n  if (descriptors.length === 0) return;\n  let styleLinks = [];\n  for (let descriptor of descriptors) {\n    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n      styleLinks.push({\n        ...descriptor,\n        rel: \"preload\",\n        as: \"style\"\n      });\n    }\n  }\n  await Promise.all(styleLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n  return new Promise((resolve) => {\n    if (descriptor.media && !window.matchMedia(descriptor.media).matches || document.querySelector(\n      `link[rel=\"stylesheet\"][href=\"${descriptor.href}\"]`\n    )) {\n      return resolve();\n    }\n    let link = document.createElement(\"link\");\n    Object.assign(link, descriptor);\n    function removeLink() {\n      if (document.head.contains(link)) {\n        document.head.removeChild(link);\n      }\n    }\n    link.onload = () => {\n      removeLink();\n      resolve();\n    };\n    link.onerror = () => {\n      removeLink();\n      resolve();\n    };\n    document.head.appendChild(link);\n  });\n}\nfunction isPageLinkDescriptor(object) {\n  return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n  if (object == null) {\n    return false;\n  }\n  if (object.href == null) {\n    return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n  }\n  return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n  let links = await Promise.all(\n    matches.map(async (match) => {\n      let route = manifest.routes[match.route.id];\n      if (route) {\n        let mod = await loadRouteModule(route, routeModules);\n        return mod.links ? mod.links() : [];\n      }\n      return [];\n    })\n  );\n  return dedupeLinkDescriptors(\n    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === \"stylesheet\" || link.rel === \"preload\").map(\n      (link) => link.rel === \"stylesheet\" ? { ...link, rel: \"prefetch\", as: \"style\" } : { ...link, rel: \"prefetch\" }\n    )\n  );\n}\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n  let isNew = (match, index) => {\n    if (!currentMatches[index]) return true;\n    return match.route.id !== currentMatches[index].route.id;\n  };\n  let matchPathChanged = (match, index) => {\n    return (\n      // param change, /users/123 -> /users/456\n      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path\n      // e.g. /files/images/avatar.jpg -> files/finances.xls\n      currentMatches[index].route.path?.endsWith(\"*\") && currentMatches[index].params[\"*\"] !== match.params[\"*\"]\n    );\n  };\n  if (mode === \"assets\") {\n    return nextMatches.filter(\n      (match, index) => isNew(match, index) || matchPathChanged(match, index)\n    );\n  }\n  if (mode === \"data\") {\n    return nextMatches.filter((match, index) => {\n      let manifestRoute = manifest.routes[match.route.id];\n      if (!manifestRoute || !manifestRoute.hasLoader) {\n        return false;\n      }\n      if (isNew(match, index) || matchPathChanged(match, index)) {\n        return true;\n      }\n      if (match.route.shouldRevalidate) {\n        let routeChoice = match.route.shouldRevalidate({\n          currentUrl: new URL(\n            location.pathname + location.search + location.hash,\n            window.origin\n          ),\n          currentParams: currentMatches[0]?.params || {},\n          nextUrl: new URL(page, window.origin),\n          nextParams: match.params,\n          defaultShouldRevalidate: true\n        });\n        if (typeof routeChoice === \"boolean\") {\n          return routeChoice;\n        }\n      }\n      return true;\n    });\n  }\n  return [];\n}\nfunction getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {\n  return dedupeHrefs(\n    matches.map((match) => {\n      let route = manifest.routes[match.route.id];\n      if (!route) return [];\n      let hrefs = [route.module];\n      if (route.clientActionModule) {\n        hrefs = hrefs.concat(route.clientActionModule);\n      }\n      if (route.clientLoaderModule) {\n        hrefs = hrefs.concat(route.clientLoaderModule);\n      }\n      if (includeHydrateFallback && route.hydrateFallbackModule) {\n        hrefs = hrefs.concat(route.hydrateFallbackModule);\n      }\n      if (route.imports) {\n        hrefs = hrefs.concat(route.imports);\n      }\n      return hrefs;\n    }).flat(1)\n  );\n}\nfunction dedupeHrefs(hrefs) {\n  return [...new Set(hrefs)];\n}\nfunction sortKeys(obj) {\n  let sorted = {};\n  let keys = Object.keys(obj).sort();\n  for (let key of keys) {\n    sorted[key] = obj[key];\n  }\n  return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n  let set = /* @__PURE__ */ new Set();\n  let preloadsSet = new Set(preloads);\n  return descriptors.reduce((deduped, descriptor) => {\n    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n    if (alreadyModulePreload) {\n      return deduped;\n    }\n    let key = JSON.stringify(sortKeys(descriptor));\n    if (!set.has(key)) {\n      set.add(key);\n      deduped.push({ key, link: descriptor });\n    }\n    return deduped;\n  }, []);\n}\nvar _isPreloadSupported;\nfunction isPreloadSupported() {\n  if (_isPreloadSupported !== void 0) {\n    return _isPreloadSupported;\n  }\n  let el = document.createElement(\"link\");\n  _isPreloadSupported = el.relList.supports(\"preload\");\n  el = null;\n  return _isPreloadSupported;\n}\n\n// lib/dom/ssr/fog-of-war.ts\n\n\n// lib/dom/ssr/routes.tsx\n\n\n// lib/dom/ssr/fallback.tsx\n\nfunction RemixRootDefaultHydrateFallback() {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, { title: \"Loading...\", renderScripts: true }, ENABLE_DEV_WARNINGS ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n              console.log(\n                \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this \" +\n                \"when your app is loading JS modules and/or running \\`clientLoader\\` \" +\n                \"functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback \" +\n                \"for more information.\"\n              );\n            `\n      }\n    }\n  ) : null);\n}\n\n// lib/dom/ssr/routes.tsx\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach((route) => {\n    if (route) {\n      let parentId = route.parentId || \"\";\n      if (!routes[parentId]) {\n        routes[parentId] = [];\n      }\n      routes[parentId].push(route);\n    }\n  });\n  return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n  let Component4 = getRouteModuleComponent(routeModule);\n  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : void 0;\n  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixRootDefaultErrorBoundary, { error: useRouteError() }) : void 0;\n  if (route.id === \"root\" && routeModule.Layout) {\n    return {\n      ...Component4 ? {\n        element: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component4, null))\n      } : { Component: Component4 },\n      ...ErrorBoundary ? {\n        errorElement: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ErrorBoundary, null))\n      } : { ErrorBoundary },\n      ...HydrateFallback ? {\n        hydrateFallbackElement: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HydrateFallback, null))\n      } : { HydrateFallback }\n    };\n  }\n  return { Component: Component4, ErrorBoundary, HydrateFallback };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({ Component: () => null })) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let routeModule = routeModules[route.id];\n    invariant2(\n      routeModule,\n      \"No `routeModule` available to create server routes\"\n    );\n    let dataRoute = {\n      ...getRouteComponents(route, routeModule, isSpaMode),\n      caseSensitive: route.caseSensitive,\n      id: route.id,\n      index: route.index,\n      path: route.path,\n      handle: routeModule.handle,\n      // For SPA Mode, all routes are lazy except root.  However we tell the\n      // router root is also lazy here too since we don't need a full\n      // implementation - we just need a `lazy` prop to tell the RR rendering\n      // where to stop which is always at the root route in SPA mode\n      lazy: isSpaMode ? () => spaModeLazyPromise : void 0,\n      // For partial hydration rendering, we need to indicate when the route\n      // has a loader/clientLoader, but it won't ever be called during the static\n      // render, so just give it a no-op function so we can render down to the\n      // proper fallback\n      loader: route.hasLoader || route.hasClientLoader ? () => null : void 0\n      // We don't need middleware/action/shouldRevalidate on these routes since\n      // they're for a static render\n    };\n    let children = createServerRoutes(\n      manifest,\n      routeModules,\n      future,\n      isSpaMode,\n      route.id,\n      routesByParentId,\n      spaModeLazyPromise\n    );\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {\n  return createClientRoutes(\n    manifest,\n    routeModulesCache,\n    initialState,\n    ssr,\n    isSpaMode,\n    \"\",\n    groupRoutesByParentId(manifest),\n    needsRevalidation\n  );\n}\nfunction preventInvalidServerHandlerCall(type, route) {\n  if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${route.id}\")`;\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nfunction noActionDefinedError(type, routeId) {\n  let article = type === \"clientAction\" ? \"a\" : \"an\";\n  let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n  console.error(msg);\n  throw new ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n  return (routesByParentId[parentId] || []).map((route) => {\n    let routeModule = routeModulesCache[route.id];\n    function fetchServerHandler(singleFetch) {\n      invariant2(\n        typeof singleFetch === \"function\",\n        \"No single fetch function available for route handler\"\n      );\n      return singleFetch();\n    }\n    function fetchServerLoader(singleFetch) {\n      if (!route.hasLoader) return Promise.resolve(null);\n      return fetchServerHandler(singleFetch);\n    }\n    function fetchServerAction(singleFetch) {\n      if (!route.hasAction) {\n        throw noActionDefinedError(\"action\", route.id);\n      }\n      return fetchServerHandler(singleFetch);\n    }\n    function prefetchModule(modulePath) {\n      import(\n        /* @vite-ignore */\n        /* webpackIgnore: true */\n        modulePath\n      );\n    }\n    function prefetchRouteModuleChunks(route2) {\n      if (route2.clientActionModule) {\n        prefetchModule(route2.clientActionModule);\n      }\n      if (route2.clientLoaderModule) {\n        prefetchModule(route2.clientLoaderModule);\n      }\n    }\n    async function prefetchStylesAndCallHandler(handler) {\n      let cachedModule = routeModulesCache[route.id];\n      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n      try {\n        return handler();\n      } finally {\n        await linkPrefetchPromise;\n      }\n    }\n    let dataRoute = {\n      id: route.id,\n      index: route.index,\n      path: route.path\n    };\n    if (routeModule) {\n      Object.assign(dataRoute, {\n        ...dataRoute,\n        ...getRouteComponents(route, routeModule, isSpaMode),\n        middleware: routeModule.clientMiddleware,\n        handle: routeModule.handle,\n        shouldRevalidate: getShouldRevalidateFunction(\n          dataRoute.path,\n          routeModule,\n          route,\n          ssr,\n          needsRevalidation\n        )\n      });\n      let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;\n      let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;\n      let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;\n      let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;\n      let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);\n      dataRoute.loader = async ({ request, params, context }, singleFetch) => {\n        try {\n          let result = await prefetchStylesAndCallHandler(async () => {\n            invariant2(\n              routeModule,\n              \"No `routeModule` available for critical-route loader\"\n            );\n            if (!routeModule.clientLoader) {\n              return fetchServerLoader(singleFetch);\n            }\n            return routeModule.clientLoader({\n              request,\n              params,\n              context,\n              async serverLoader() {\n                preventInvalidServerHandlerCall(\"loader\", route);\n                if (isHydrationRequest) {\n                  if (hasInitialData) {\n                    return initialData;\n                  }\n                  if (hasInitialError) {\n                    throw initialError;\n                  }\n                }\n                return fetchServerLoader(singleFetch);\n              }\n            });\n          });\n          return result;\n        } finally {\n          isHydrationRequest = false;\n        }\n      };\n      dataRoute.loader.hydrate = shouldHydrateRouteLoader(\n        route.id,\n        routeModule.clientLoader,\n        route.hasLoader,\n        isSpaMode\n      );\n      dataRoute.action = ({ request, params, context }, singleFetch) => {\n        return prefetchStylesAndCallHandler(async () => {\n          invariant2(\n            routeModule,\n            \"No `routeModule` available for critical-route action\"\n          );\n          if (!routeModule.clientAction) {\n            if (isSpaMode) {\n              throw noActionDefinedError(\"clientAction\", route.id);\n            }\n            return fetchServerAction(singleFetch);\n          }\n          return routeModule.clientAction({\n            request,\n            params,\n            context,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route);\n              return fetchServerAction(singleFetch);\n            }\n          });\n        });\n      };\n    } else {\n      if (!route.hasClientLoader) {\n        dataRoute.loader = (_, singleFetch) => prefetchStylesAndCallHandler(() => {\n          return fetchServerLoader(singleFetch);\n        });\n      }\n      if (!route.hasClientAction) {\n        dataRoute.action = (_, singleFetch) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) {\n            throw noActionDefinedError(\"clientAction\", route.id);\n          }\n          return fetchServerAction(singleFetch);\n        });\n      }\n      let lazyRoutePromise;\n      async function getLazyRoute() {\n        if (lazyRoutePromise) {\n          return await lazyRoutePromise;\n        }\n        lazyRoutePromise = (async () => {\n          if (route.clientLoaderModule || route.clientActionModule) {\n            await new Promise((resolve) => setTimeout(resolve, 0));\n          }\n          let routeModulePromise = loadRouteModuleWithBlockingLinks(\n            route,\n            routeModulesCache\n          );\n          prefetchRouteModuleChunks(route);\n          return await routeModulePromise;\n        })();\n        return await lazyRoutePromise;\n      }\n      dataRoute.lazy = {\n        loader: route.hasClientLoader ? async () => {\n          let { clientLoader } = route.clientLoaderModule ? await import(\n            /* @vite-ignore */\n            /* webpackIgnore: true */\n            route.clientLoaderModule\n          ) : await getLazyRoute();\n          invariant2(clientLoader, \"No `clientLoader` export found\");\n          return (args, singleFetch) => clientLoader({\n            ...args,\n            async serverLoader() {\n              preventInvalidServerHandlerCall(\"loader\", route);\n              return fetchServerLoader(singleFetch);\n            }\n          });\n        } : void 0,\n        action: route.hasClientAction ? async () => {\n          let clientActionPromise = route.clientActionModule ? import(\n            /* @vite-ignore */\n            /* webpackIgnore: true */\n            route.clientActionModule\n          ) : getLazyRoute();\n          prefetchRouteModuleChunks(route);\n          let { clientAction } = await clientActionPromise;\n          invariant2(clientAction, \"No `clientAction` export found\");\n          return (args, singleFetch) => clientAction({\n            ...args,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route);\n              return fetchServerAction(singleFetch);\n            }\n          });\n        } : void 0,\n        middleware: route.hasClientMiddleware ? async () => {\n          let { clientMiddleware } = route.clientMiddlewareModule ? await import(\n            /* @vite-ignore */\n            /* webpackIgnore: true */\n            route.clientMiddlewareModule\n          ) : await getLazyRoute();\n          invariant2(clientMiddleware, \"No `clientMiddleware` export found\");\n          return clientMiddleware;\n        } : void 0,\n        shouldRevalidate: async () => {\n          let lazyRoute = await getLazyRoute();\n          return getShouldRevalidateFunction(\n            dataRoute.path,\n            lazyRoute,\n            route,\n            ssr,\n            needsRevalidation\n          );\n        },\n        handle: async () => (await getLazyRoute()).handle,\n        // No need to wrap these in layout since the root route is never\n        // loaded via route.lazy()\n        Component: async () => (await getLazyRoute()).Component,\n        ErrorBoundary: route.hasErrorBoundary ? async () => (await getLazyRoute()).ErrorBoundary : void 0\n      };\n    }\n    let children = createClientRoutes(\n      manifest,\n      routeModulesCache,\n      initialState,\n      ssr,\n      isSpaMode,\n      route.id,\n      routesByParentId,\n      needsRevalidation\n    );\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction getShouldRevalidateFunction(path, route, manifestRoute, ssr, needsRevalidation) {\n  if (needsRevalidation) {\n    return wrapShouldRevalidateForHdr(\n      manifestRoute.id,\n      route.shouldRevalidate,\n      needsRevalidation\n    );\n  }\n  if (!ssr && manifestRoute.hasLoader && !manifestRoute.hasClientLoader) {\n    let myParams = path ? compilePath(path)[1].map((p) => p.paramName) : [];\n    const didParamsChange = (opts) => myParams.some((p) => opts.currentParams[p] !== opts.nextParams[p]);\n    if (route.shouldRevalidate) {\n      let fn = route.shouldRevalidate;\n      return (opts) => fn({\n        ...opts,\n        defaultShouldRevalidate: didParamsChange(opts)\n      });\n    } else {\n      return (opts) => didParamsChange(opts);\n    }\n  }\n  if (ssr && route.shouldRevalidate) {\n    let fn = route.shouldRevalidate;\n    return (opts) => fn({ ...opts, defaultShouldRevalidate: true });\n  }\n  return route.shouldRevalidate;\n}\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n  let handledRevalidation = false;\n  return (arg) => {\n    if (!handledRevalidation) {\n      handledRevalidation = true;\n      return needsRevalidation.has(routeId);\n    }\n    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n  };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n  let routeModulePromise = loadRouteModule(route, routeModules);\n  let prefetchRouteCssPromise = prefetchRouteCss(route);\n  let routeModule = await routeModulePromise;\n  await Promise.all([\n    prefetchRouteCssPromise,\n    prefetchStyleLinks(route, routeModule)\n  ]);\n  return {\n    Component: getRouteModuleComponent(routeModule),\n    ErrorBoundary: routeModule.ErrorBoundary,\n    clientMiddleware: routeModule.clientMiddleware,\n    clientAction: routeModule.clientAction,\n    clientLoader: routeModule.clientLoader,\n    handle: routeModule.handle,\n    links: routeModule.links,\n    meta: routeModule.meta,\n    shouldRevalidate: routeModule.shouldRevalidate\n  };\n}\nfunction getRouteModuleComponent(routeModule) {\n  if (routeModule.default == null) return void 0;\n  let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n  if (!isEmptyObject) {\n    return routeModule.default;\n  }\n}\nfunction shouldHydrateRouteLoader(routeId, clientLoader, hasLoader, isSpaMode) {\n  return isSpaMode && routeId !== \"root\" || clientLoader != null && (clientLoader.hydrate === true || hasLoader !== true);\n}\n\n// lib/dom/ssr/fog-of-war.ts\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction isFogOfWarEnabled(routeDiscovery, ssr) {\n  return routeDiscovery.mode === \"lazy\" && ssr === true;\n}\nfunction getPartialManifest({ sri, ...manifest }, router) {\n  let routeIds = new Set(router.state.matches.map((m) => m.route.id));\n  let segments = router.state.location.pathname.split(\"/\").filter(Boolean);\n  let paths = [\"/\"];\n  segments.pop();\n  while (segments.length > 0) {\n    paths.push(`/${segments.join(\"/\")}`);\n    segments.pop();\n  }\n  paths.forEach((path) => {\n    let matches = matchRoutes(router.routes, path, router.basename);\n    if (matches) {\n      matches.forEach((m) => routeIds.add(m.route.id));\n    }\n  });\n  let initialRoutes = [...routeIds].reduce(\n    (acc, id) => Object.assign(acc, { [id]: manifest.routes[id] }),\n    {}\n  );\n  return {\n    ...manifest,\n    routes: initialRoutes,\n    sri: sri ? true : void 0\n  };\n}\nfunction getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, routeDiscovery, isSpaMode, basename) {\n  if (!isFogOfWarEnabled(routeDiscovery, ssr)) {\n    return void 0;\n  }\n  return async ({ path, patch, signal, fetcherKey }) => {\n    if (discoveredPaths.has(path)) {\n      return;\n    }\n    await fetchAndApplyManifestPatches(\n      [path],\n      fetcherKey ? window.location.href : path,\n      manifest,\n      routeModules,\n      ssr,\n      isSpaMode,\n      basename,\n      routeDiscovery.manifestPath,\n      patch,\n      signal\n    );\n  };\n}\nfunction useFogOFWarDiscovery(router, manifest, routeModules, ssr, routeDiscovery, isSpaMode) {\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!isFogOfWarEnabled(routeDiscovery, ssr) || // @ts-expect-error - TS doesn't know about this yet\n    window.navigator?.connection?.saveData === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let lazyPaths = Array.from(nextPaths.keys()).filter((path) => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (lazyPaths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(\n          lazyPaths,\n          null,\n          manifest,\n          routeModules,\n          ssr,\n          isSpaMode,\n          router.basename,\n          routeDiscovery.manifestPath,\n          router.patchRoutes\n        );\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n    return () => observer.disconnect();\n  }, [ssr, isSpaMode, manifest, routeModules, router, routeDiscovery]);\n}\nfunction getManifestPath(_manifestPath, basename) {\n  let manifestPath = _manifestPath || \"/__manifest\";\n  if (basename == null) {\n    return manifestPath;\n  }\n  return `${basename}${manifestPath}`.replace(/\\/+/g, \"/\");\n}\nvar MANIFEST_VERSION_STORAGE_KEY = \"react-router-manifest-version\";\nasync function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, manifestPath, patchRoutes, signal) {\n  const searchParams = new URLSearchParams();\n  searchParams.set(\"paths\", paths.sort().join(\",\"));\n  searchParams.set(\"version\", manifest.version);\n  let url = new URL(\n    getManifestPath(manifestPath, basename),\n    window.location.origin\n  );\n  url.search = searchParams.toString();\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let serverPatches;\n  try {\n    let res = await fetch(url, { signal });\n    if (!res.ok) {\n      throw new Error(`${res.status} ${res.statusText}`);\n    } else if (res.status === 204 && res.headers.has(\"X-Remix-Reload-Document\")) {\n      if (!errorReloadPath) {\n        console.warn(\n          \"Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest.\"\n        );\n        return;\n      }\n      try {\n        if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {\n          console.error(\n            \"Unable to discover routes due to manifest version mismatch.\"\n          );\n          return;\n        }\n        sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);\n      } catch {\n      }\n      window.location.href = errorReloadPath;\n      console.warn(\"Detected manifest version mismatch, reloading...\");\n      await new Promise(() => {\n      });\n    } else if (res.status >= 400) {\n      throw new Error(await res.text());\n    }\n    try {\n      sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);\n    } catch {\n    }\n    serverPatches = await res.json();\n  } catch (e) {\n    if (signal?.aborted) return;\n    throw e;\n  }\n  let knownRoutes = new Set(Object.keys(manifest.routes));\n  let patches = Object.values(serverPatches).reduce((acc, route) => {\n    if (route && !knownRoutes.has(route.id)) {\n      acc[route.id] = route;\n    }\n    return acc;\n  }, {});\n  Object.assign(manifest.routes, patches);\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\n  let parentIds = /* @__PURE__ */ new Set();\n  Object.values(patches).forEach((patch) => {\n    if (patch && (!patch.parentId || !patches[patch.parentId])) {\n      parentIds.add(patch.parentId);\n    }\n  });\n  parentIds.forEach(\n    (parentId) => patchRoutes(\n      parentId || null,\n      createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)\n    )\n  );\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return (...args) => {\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\n\n// lib/dom/ssr/components.tsx\nfunction useDataRouterContext2() {\n  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <DataRouterContext.Provider> element\"\n  );\n  return context;\n}\nfunction useDataRouterStateContext() {\n  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <DataRouterStateContext.Provider> element\"\n  );\n  return context;\n}\nvar FrameworkContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nFrameworkContext.displayName = \"FrameworkContext\";\nfunction useFrameworkContext() {\n  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);\n  invariant2(\n    context,\n    \"You must render this element inside a <HydratedRouter> element\"\n  );\n  return context;\n}\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n  let frameworkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);\n  let [maybePrefetch, setMaybePrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  let [shouldPrefetch, setShouldPrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;\n  let ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (prefetch === \"render\") {\n      setShouldPrefetch(true);\n    }\n    if (prefetch === \"viewport\") {\n      let callback = (entries) => {\n        entries.forEach((entry) => {\n          setShouldPrefetch(entry.isIntersecting);\n        });\n      };\n      let observer = new IntersectionObserver(callback, { threshold: 0.5 });\n      if (ref.current) observer.observe(ref.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [prefetch]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (maybePrefetch) {\n      let id = setTimeout(() => {\n        setShouldPrefetch(true);\n      }, 100);\n      return () => {\n        clearTimeout(id);\n      };\n    }\n  }, [maybePrefetch]);\n  let setIntent = () => {\n    setMaybePrefetch(true);\n  };\n  let cancelIntent = () => {\n    setMaybePrefetch(false);\n    setShouldPrefetch(false);\n  };\n  if (!frameworkContext) {\n    return [false, ref, {}];\n  }\n  if (prefetch !== \"intent\") {\n    return [shouldPrefetch, ref, {}];\n  }\n  return [\n    shouldPrefetch,\n    ref,\n    {\n      onFocus: composeEventHandlers(onFocus, setIntent),\n      onBlur: composeEventHandlers(onBlur, cancelIntent),\n      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n      onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n    }\n  ];\n}\nfunction composeEventHandlers(theirHandler, ourHandler) {\n  return (event) => {\n    theirHandler && theirHandler(event);\n    if (!event.defaultPrevented) {\n      ourHandler(event);\n    }\n  };\n}\nfunction getActiveMatches(matches, errors, isSpaMode) {\n  if (isSpaMode && !isHydrated) {\n    return [matches[0]];\n  }\n  if (errors) {\n    let errorIdx = matches.findIndex((m) => errors[m.route.id] !== void 0);\n    return matches.slice(0, errorIdx + 1);\n  }\n  return matches;\n}\nvar CRITICAL_CSS_DATA_ATTRIBUTE = \"data-react-router-critical-css\";\nfunction Links({ nonce }) {\n  let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();\n  let { errors, matches: routerMatches } = useDataRouterStateContext();\n  let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let keyedLinks = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => getKeyedLinksForMatches(matches, routeModules, manifest),\n    [matches, routeModules, manifest]\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, typeof criticalCss === \"string\" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"style\",\n    {\n      ...{ [CRITICAL_CSS_DATA_ATTRIBUTE]: \"\" },\n      dangerouslySetInnerHTML: { __html: criticalCss }\n    }\n  ) : null, typeof criticalCss === \"object\" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"link\",\n    {\n      ...{ [CRITICAL_CSS_DATA_ATTRIBUTE]: \"\" },\n      rel: \"stylesheet\",\n      href: criticalCss.href,\n      nonce\n    }\n  ) : null, keyedLinks.map(\n    ({ key, link }) => isPageLinkDescriptor(link) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, { key, nonce, ...link }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", { key, nonce, ...link })\n  ));\n}\nfunction PrefetchPageLinks({ page, ...linkProps }) {\n  let { router } = useDataRouterContext2();\n  let matches = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => matchRoutes(router.routes, page, router.basename),\n    [router.routes, page, router.basename]\n  );\n  if (!matches) {\n    return null;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinksImpl, { page, matches, ...linkProps });\n}\nfunction useKeyedPrefetchLinks(matches) {\n  let { manifest, routeModules } = useFrameworkContext();\n  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let interrupted = false;\n    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(\n      (links) => {\n        if (!interrupted) {\n          setKeyedPrefetchLinks(links);\n        }\n      }\n    );\n    return () => {\n      interrupted = true;\n    };\n  }, [matches, manifest, routeModules]);\n  return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({\n  page,\n  matches: nextMatches,\n  ...linkProps\n}) {\n  let location = useLocation();\n  let { manifest, routeModules } = useFrameworkContext();\n  let { basename } = useDataRouterContext2();\n  let { loaderData, matches } = useDataRouterStateContext();\n  let newMatchesForData = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => getNewMatchesForLinks(\n      page,\n      nextMatches,\n      matches,\n      manifest,\n      location,\n      \"data\"\n    ),\n    [page, nextMatches, matches, manifest, location]\n  );\n  let newMatchesForAssets = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => getNewMatchesForLinks(\n      page,\n      nextMatches,\n      matches,\n      manifest,\n      location,\n      \"assets\"\n    ),\n    [page, nextMatches, matches, manifest, location]\n  );\n  let dataHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (page === location.pathname + location.search + location.hash) {\n      return [];\n    }\n    let routesParams = /* @__PURE__ */ new Set();\n    let foundOptOutRoute = false;\n    nextMatches.forEach((m) => {\n      let manifestRoute = manifest.routes[m.route.id];\n      if (!manifestRoute || !manifestRoute.hasLoader) {\n        return;\n      }\n      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {\n        foundOptOutRoute = true;\n      } else if (manifestRoute.hasClientLoader) {\n        foundOptOutRoute = true;\n      } else {\n        routesParams.add(m.route.id);\n      }\n    });\n    if (routesParams.size === 0) {\n      return [];\n    }\n    let url = singleFetchUrl(page, basename, \"data\");\n    if (foundOptOutRoute && routesParams.size > 0) {\n      url.searchParams.set(\n        \"_routes\",\n        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(\",\")\n      );\n    }\n    return [url.pathname + url.search];\n  }, [\n    basename,\n    loaderData,\n    location,\n    manifest,\n    newMatchesForData,\n    nextMatches,\n    page,\n    routeModules\n  ]);\n  let moduleHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => getModuleLinkHrefs(newMatchesForAssets, manifest),\n    [newMatchesForAssets, manifest]\n  );\n  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", { key: href, rel: \"prefetch\", as: \"fetch\", href, ...linkProps })), moduleHrefs.map((href) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", { key: href, rel: \"modulepreload\", href, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (\n    // these don't spread `linkProps` because they are full link descriptors\n    // already with their own props\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"link\", { key, nonce: linkProps.nonce, ...link })\n  )));\n}\nfunction Meta() {\n  let { isSpaMode, routeModules } = useFrameworkContext();\n  let {\n    errors,\n    matches: routerMatches,\n    loaderData\n  } = useDataRouterStateContext();\n  let location = useLocation();\n  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let error = null;\n  if (errors) {\n    error = errors[_matches[_matches.length - 1].route.id];\n  }\n  let meta = [];\n  let leafMeta = null;\n  let matches = [];\n  for (let i = 0; i < _matches.length; i++) {\n    let _match = _matches[i];\n    let routeId = _match.route.id;\n    let data2 = loaderData[routeId];\n    let params = _match.params;\n    let routeModule = routeModules[routeId];\n    let routeMeta = [];\n    let match = {\n      id: routeId,\n      data: data2,\n      loaderData: data2,\n      meta: [],\n      params: _match.params,\n      pathname: _match.pathname,\n      handle: _match.route.handle,\n      error\n    };\n    matches[i] = match;\n    if (routeModule?.meta) {\n      routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n        data: data2,\n        loaderData: data2,\n        params,\n        location,\n        matches,\n        error\n      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;\n    } else if (leafMeta) {\n      routeMeta = [...leafMeta];\n    }\n    routeMeta = routeMeta || [];\n    if (!Array.isArray(routeMeta)) {\n      throw new Error(\n        \"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must return an array of meta objects.\\n\\nTo reference the meta function API, see https://remix.run/route/meta\"\n      );\n    }\n    match.meta = routeMeta;\n    matches[i] = match;\n    meta = [...routeMeta];\n    leafMeta = meta;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, meta.flat().map((metaProps) => {\n    if (!metaProps) {\n      return null;\n    }\n    if (\"tagName\" in metaProps) {\n      let { tagName, ...rest } = metaProps;\n      if (!isValidMetaTag(tagName)) {\n        console.warn(\n          `A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`\n        );\n        return null;\n      }\n      let Comp = tagName;\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, { key: JSON.stringify(rest), ...rest });\n    }\n    if (\"title\" in metaProps) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", { key: \"title\" }, String(metaProps.title));\n    }\n    if (\"charset\" in metaProps) {\n      metaProps.charSet ?? (metaProps.charSet = metaProps.charset);\n      delete metaProps.charset;\n    }\n    if (\"charSet\" in metaProps && metaProps.charSet != null) {\n      return typeof metaProps.charSet === \"string\" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"meta\", { key: \"charSet\", charSet: metaProps.charSet }) : null;\n    }\n    if (\"script:ld+json\" in metaProps) {\n      try {\n        let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n          \"script\",\n          {\n            key: `script:ld+json:${json}`,\n            type: \"application/ld+json\",\n            dangerouslySetInnerHTML: { __html: escapeHtml(json) }\n          }\n        );\n      } catch (err) {\n        return null;\n      }\n    }\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"meta\", { key: JSON.stringify(metaProps), ...metaProps });\n  }));\n}\nfunction isValidMetaTag(tagName) {\n  return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nvar isHydrated = false;\nfunction setIsHydrated() {\n  isHydrated = true;\n}\nfunction Scripts(scriptProps) {\n  let {\n    manifest,\n    serverHandoffString,\n    isSpaMode,\n    renderMeta,\n    routeDiscovery,\n    ssr\n  } = useFrameworkContext();\n  let { router, static: isStatic, staticContext } = useDataRouterContext2();\n  let { matches: routerMatches } = useDataRouterStateContext();\n  let isRSCRouterContext = useIsRSCRouterContext();\n  let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);\n  if (renderMeta) {\n    renderMeta.didRenderScripts = true;\n  }\n  let matches = getActiveMatches(routerMatches, null, isSpaMode);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    setIsHydrated();\n  }, []);\n  let initialScripts = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (isRSCRouterContext) {\n      return null;\n    }\n    let streamScript = \"window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());\";\n    let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : \" \";\n    let routeModulesScript = !isStatic ? \" \" : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : \"\"};\n${matches.map((match, routeIndex) => {\n      let routeVarName = `route${routeIndex}`;\n      let manifestEntry = manifest.routes[match.route.id];\n      invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);\n      let {\n        clientActionModule,\n        clientLoaderModule,\n        clientMiddlewareModule,\n        hydrateFallbackModule,\n        module\n      } = manifestEntry;\n      let chunks = [\n        ...clientActionModule ? [\n          {\n            module: clientActionModule,\n            varName: `${routeVarName}_clientAction`\n          }\n        ] : [],\n        ...clientLoaderModule ? [\n          {\n            module: clientLoaderModule,\n            varName: `${routeVarName}_clientLoader`\n          }\n        ] : [],\n        ...clientMiddlewareModule ? [\n          {\n            module: clientMiddlewareModule,\n            varName: `${routeVarName}_clientMiddleware`\n          }\n        ] : [],\n        ...hydrateFallbackModule ? [\n          {\n            module: hydrateFallbackModule,\n            varName: `${routeVarName}_HydrateFallback`\n          }\n        ] : [],\n        { module, varName: `${routeVarName}_main` }\n      ];\n      if (chunks.length === 1) {\n        return `import * as ${routeVarName} from ${JSON.stringify(module)};`;\n      }\n      let chunkImportsSnippet = chunks.map((chunk) => `import * as ${chunk.varName} from \"${chunk.module}\";`).join(\"\\n\");\n      let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk) => `...${chunk.varName}`).join(\",\")}};`;\n      return [chunkImportsSnippet, mergedChunksSnippet].join(\"\\n\");\n    }).join(\"\\n\")}\n  ${enableFogOfWar ? (\n      // Inline a minimal manifest with the SSR matches\n      `window.__reactRouterManifest = ${JSON.stringify(\n        getPartialManifest(manifest, router),\n        null,\n        2\n      )};`\n    ) : \"\"}\n  window.__reactRouterRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"script\",\n      {\n        ...scriptProps,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: { __html: contextScript },\n        type: void 0\n      }\n    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"script\",\n      {\n        ...scriptProps,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: { __html: routeModulesScript },\n        type: \"module\",\n        async: true\n      }\n    ));\n  }, []);\n  let preloads = isHydrated || isRSCRouterContext ? [] : dedupe(\n    manifest.entry.imports.concat(\n      getModuleLinkHrefs(matches, manifest, {\n        includeHydrateFallback: true\n      })\n    )\n  );\n  let sri = typeof manifest.sri === \"object\" ? manifest.sri : {};\n  warnOnce(\n    !isRSCRouterContext,\n    \"The <Scripts /> element is a no-op when using RSC and can be safely removed.\"\n  );\n  return isHydrated || isRSCRouterContext ? null : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, typeof manifest.sri === \"object\" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"script\",\n    {\n      \"rr-importmap\": \"\",\n      type: \"importmap\",\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: {\n        __html: JSON.stringify({\n          integrity: sri\n        })\n      }\n    }\n  ) : null, !enableFogOfWar ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"link\",\n    {\n      rel: \"modulepreload\",\n      href: manifest.url,\n      crossOrigin: scriptProps.crossOrigin,\n      integrity: sri[manifest.url],\n      suppressHydrationWarning: true\n    }\n  ) : null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"link\",\n    {\n      rel: \"modulepreload\",\n      href: manifest.entry.module,\n      crossOrigin: scriptProps.crossOrigin,\n      integrity: sri[manifest.entry.module],\n      suppressHydrationWarning: true\n    }\n  ), preloads.map((path) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"link\",\n    {\n      key: path,\n      rel: \"modulepreload\",\n      href: path,\n      crossOrigin: scriptProps.crossOrigin,\n      integrity: sri[path],\n      suppressHydrationWarning: true\n    }\n  )), initialScripts);\n}\nfunction dedupe(array) {\n  return [...new Set(array)];\n}\nfunction mergeRefs(...refs) {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n// lib/dom/ssr/errorBoundaries.tsx\nvar RemixErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.state = { error: props.error || null, location: props.location };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (state.location !== props.location) {\n      return { error: props.error || null, location: props.location };\n    }\n    return { error: props.error || state.error, location: state.location };\n  }\n  render() {\n    if (this.state.error) {\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        RemixRootDefaultErrorBoundary,\n        {\n          error: this.state.error,\n          isOutsideRemixApp: true\n        }\n      );\n    } else {\n      return this.props.children;\n    }\n  }\n};\nfunction RemixRootDefaultErrorBoundary({\n  error,\n  isOutsideRemixApp\n}) {\n  console.error(error);\n  let heyDeveloper = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"script\",\n    {\n      dangerouslySetInnerHTML: {\n        __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n      }\n    }\n  );\n  if (isRouteErrorResponse(error)) {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, { title: \"Unhandled Thrown Response!\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", { style: { fontSize: \"24px\" } }, error.status, \" \", error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    BoundaryShell,\n    {\n      title: \"Application Error!\",\n      isOutsideRemixApp\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", { style: { fontSize: \"24px\" } }, \"Application Error\"),\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"pre\",\n      {\n        style: {\n          padding: \"2rem\",\n          background: \"hsla(10, 50%, 50%, 0.1)\",\n          color: \"red\",\n          overflow: \"auto\"\n        }\n      },\n      errorInstance.stack\n    ),\n    heyDeveloper\n  );\n}\nfunction BoundaryShell({\n  title,\n  renderScripts,\n  isOutsideRemixApp,\n  children\n}) {\n  let { routeModules } = useFrameworkContext();\n  if (routeModules.root?.Layout && !isOutsideRemixApp) {\n    return children;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"html\", { lang: \"en\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"head\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"meta\", { charSet: \"utf-8\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"meta\",\n    {\n      name: \"viewport\",\n      content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }\n  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", null, title)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"body\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"main\", { style: { fontFamily: \"system-ui, sans-serif\", padding: \"2rem\" } }, children, renderScripts ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Scripts, null) : null)));\n}\n\n// lib/dom/lib.tsx\n\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\ntry {\n  if (isBrowser) {\n    window.__reactRouterVersion = // @ts-expect-error\n    \"7.9.3\";\n  }\n} catch (e) {\n}\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    getContext: opts?.getContext,\n    future: opts?.future,\n    history: createBrowserHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    hydrationRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n    window: opts?.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts?.basename,\n    getContext: opts?.getContext,\n    future: opts?.future,\n    history: createHashHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n    hydrationRouteProperties,\n    dataStrategy: opts?.dataStrategy,\n    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n    window: opts?.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  let state = window?.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = {\n      ...state,\n      errors: deserializeErrors(state.errors)\n    };\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponseImpl(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            let error = new ErrorConstructor(val.message);\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction BrowserRouter({\n  basename,\n  children,\n  window: window2\n}) {\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (newState) => {\n      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction HashRouter({ basename, children, window: window2 }) {\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window: window2, v5Compat: true });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (newState) => {\n      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nfunction HistoryRouter({\n  basename,\n  children,\n  history\n}) {\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    action: history.action,\n    location: history.location\n  });\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (newState) => {\n      react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));\n    },\n    [setStateImpl]\n  );\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location: state.location,\n      navigationType: state.action,\n      navigator: history\n    }\n  );\n}\nHistoryRouter.displayName = \"unstable_HistoryRouter\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function LinkWithRef({\n    onClick,\n    discover = \"render\",\n    prefetch = \"none\",\n    relative,\n    reloadDocument,\n    replace: replace2,\n    state,\n    target,\n    to,\n    preventScrollReset,\n    viewTransition,\n    ...rest\n  }, forwardedRef) {\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to);\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && isAbsolute) {\n      absoluteHref = to;\n      if (isBrowser) {\n        try {\n          let currentUrl = new URL(window.location.href);\n          let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n          let path = stripBasename(targetUrl.pathname, basename);\n          if (targetUrl.origin === currentUrl.origin && path != null) {\n            to = path + targetUrl.search + targetUrl.hash;\n          } else {\n            isExternal = true;\n          }\n        } catch (e) {\n          warning(\n            false,\n            `<Link to=\"${to}\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`\n          );\n        }\n      }\n    }\n    let href = useHref(to, { relative });\n    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(\n      prefetch,\n      rest\n    );\n    let internalOnClick = useLinkClickHandler(to, {\n      replace: replace2,\n      state,\n      target,\n      preventScrollReset,\n      relative,\n      viewTransition\n    });\n    function handleClick(event) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented) {\n        internalOnClick(event);\n      }\n    }\n    let link = (\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n        \"a\",\n        {\n          ...rest,\n          ...prefetchHandlers,\n          href: absoluteHref || href,\n          onClick: isExternal || reloadDocument ? onClick : handleClick,\n          ref: mergeRefs(forwardedRef, prefetchRef),\n          target,\n          \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n        }\n      )\n    );\n    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, link, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, { page: href })) : link;\n  }\n);\nLink.displayName = \"Link\";\nvar NavLink = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  function NavLinkWithRef({\n    \"aria-current\": ariaCurrentProp = \"page\",\n    caseSensitive = false,\n    className: classNameProp = \"\",\n    end = false,\n    style: styleProp,\n    to,\n    viewTransition,\n    children,\n    ...rest\n  }, ref) {\n    let path = useResolvedPath(to, { relative: rest.relative });\n    let location = useLocation();\n    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n    let { navigator, basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n      toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n    }\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n      isActive,\n      isPending,\n      isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n    let className;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp(renderProps);\n    } else {\n      className = [\n        classNameProp,\n        isActive ? \"active\" : null,\n        isPending ? \"pending\" : null,\n        isTransitioning ? \"transitioning\" : null\n      ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      Link,\n      {\n        ...rest,\n        \"aria-current\": ariaCurrent,\n        className,\n        ref,\n        style,\n        to,\n        viewTransition\n      },\n      typeof children === \"function\" ? children(renderProps) : children\n    );\n  }\n);\nNavLink.displayName = \"NavLink\";\nvar Form = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  ({\n    discover = \"render\",\n    fetcherKey,\n    navigate,\n    reloadDocument,\n    replace: replace2,\n    state,\n    method = defaultMethod,\n    action,\n    onSubmit,\n    relative,\n    preventScrollReset,\n    viewTransition,\n    ...props\n  }, forwardedRef) => {\n    let submit = useSubmit();\n    let formAction = useFormAction(action, { relative });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let isAbsolute = typeof action === \"string\" && ABSOLUTE_URL_REGEX2.test(action);\n    let submitHandler = (event) => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n      let submitter = event.nativeEvent.submitter;\n      let submitMethod = submitter?.getAttribute(\"formmethod\") || method;\n      submit(submitter || event.currentTarget, {\n        fetcherKey,\n        method: submitMethod,\n        navigate,\n        replace: replace2,\n        state,\n        relative,\n        preventScrollReset,\n        viewTransition\n      });\n    };\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      \"form\",\n      {\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler,\n        ...props,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n      }\n    );\n  }\n);\nForm.displayName = \"Form\";\nfunction ScrollRestoration({\n  getKey,\n  storageKey,\n  ...props\n}) {\n  let remixContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);\n  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  useScrollRestoration({ getKey, storageKey });\n  let ssrKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => {\n      if (!remixContext || !getKey) return null;\n      let userKey = getScrollRestorationKey(\n        location,\n        matches,\n        basename,\n        getKey\n      );\n      return userKey !== location.key ? userKey : null;\n    },\n    // Nah, we only need this the first time for the SSR render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n  if (!remixContext || remixContext.isSpaMode) {\n    return null;\n  }\n  let restoreScroll = ((storageKey2, restoreKey) => {\n    if (!window.history.state || !window.history.state.key) {\n      let key = Math.random().toString(32).slice(2);\n      window.history.replaceState({ key }, \"\");\n    }\n    try {\n      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n      let storedY = positions[restoreKey || window.history.state.key];\n      if (typeof storedY === \"number\") {\n        window.scrollTo(0, storedY);\n      }\n    } catch (error) {\n      console.error(error);\n      sessionStorage.removeItem(storageKey2);\n    }\n  }).toString();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"script\",\n    {\n      ...props,\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: {\n        __html: `(${restoreScroll})(${JSON.stringify(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY\n        )}, ${JSON.stringify(ssrKey)})`\n      }\n    }\n  );\n}\nScrollRestoration.displayName = \"ScrollRestoration\";\nfunction getDataRouterConsoleError2(hookName) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext3(hookName) {\n  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError2(hookName));\n  return ctx;\n}\nfunction useDataRouterState2(hookName) {\n  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError2(hookName));\n  return state;\n}\nfunction useLinkClickHandler(to, {\n  target,\n  replace: replaceProp,\n  state,\n  preventScrollReset,\n  relative,\n  viewTransition\n} = {}) {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, { relative });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (event) => {\n      if (shouldProcessLinkClick(event, target)) {\n        event.preventDefault();\n        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n        navigate(to, {\n          replace: replace2,\n          state,\n          preventScrollReset,\n          relative,\n          viewTransition\n        });\n      }\n    },\n    [\n      location,\n      navigate,\n      path,\n      replaceProp,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      relative,\n      viewTransition\n    ]\n  );\n}\nfunction useSearchParams(defaultInit) {\n  warning(\n    typeof URLSearchParams !== \"undefined\",\n    `You cannot use the \\`useSearchParams\\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`\n  );\n  let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  let location = useLocation();\n  let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => (\n      // Only merge in the defaults if we haven't yet called setSearchParams.\n      // Once we call that we want those to take precedence, otherwise you can't\n      // remove a param with setSearchParams({}) if it has an initial value\n      getSearchParamsForLocation(\n        location.search,\n        hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n      )\n    ),\n    [location.search]\n  );\n  let navigate = useNavigate();\n  let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    (nextInit, navigateOptions) => {\n      const newSearchParams = createSearchParams(\n        typeof nextInit === \"function\" ? nextInit(new URLSearchParams(searchParams)) : nextInit\n      );\n      hasSetSearchParamsRef.current = true;\n      navigate(\"?\" + newSearchParams, navigateOptions);\n    },\n    [navigate, searchParams]\n  );\n  return [searchParams, setSearchParams];\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = () => `__${String(++fetcherId)}__`;\nfunction useSubmit() {\n  let { router } = useDataRouterContext3(\"useSubmit\" /* UseSubmit */);\n  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let currentRouteId = useRouteId();\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (target, options = {}) => {\n      let { action, method, encType, formData, body } = getFormSubmissionInfo(\n        target,\n        basename\n      );\n      if (options.navigate === false) {\n        let key = options.fetcherKey || getUniqueFetcherId();\n        await router.fetch(key, currentRouteId, options.action || action, {\n          preventScrollReset: options.preventScrollReset,\n          formData,\n          body,\n          formMethod: options.method || method,\n          formEncType: options.encType || encType,\n          flushSync: options.flushSync\n        });\n      } else {\n        await router.navigate(options.action || action, {\n          preventScrollReset: options.preventScrollReset,\n          formData,\n          body,\n          formMethod: options.method || method,\n          formEncType: options.encType || encType,\n          replace: options.replace,\n          state: options.state,\n          fromRouteId: currentRouteId,\n          flushSync: options.flushSync,\n          viewTransition: options.viewTransition\n        });\n      }\n    },\n    [router, basename, currentRouteId]\n  );\n}\nfunction useFormAction(action, { relative } = {}) {\n  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n  let [match] = routeContext.matches.slice(-1);\n  let path = { ...useResolvedPath(action ? action : \".\", { relative }) };\n  let location = useLocation();\n  if (action == null) {\n    path.search = location.search;\n    let params = new URLSearchParams(path.search);\n    let indexValues = params.getAll(\"index\");\n    let hasNakedIndexParam = indexValues.some((v) => v === \"\");\n    if (hasNakedIndexParam) {\n      params.delete(\"index\");\n      indexValues.filter((v) => v).forEach((v) => params.append(\"index\", v));\n      let qs = params.toString();\n      path.search = qs ? `?${qs}` : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction useFetcher({\n  key\n} = {}) {\n  let { router } = useDataRouterContext3(\"useFetcher\" /* UseFetcher */);\n  let state = useDataRouterState2(\"useFetcher\" /* UseFetcher */);\n  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);\n  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n  let routeId = route.matches[route.matches.length - 1]?.route.id;\n  invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);\n  invariant(route, `useFetcher must be used inside a RouteContext`);\n  invariant(\n    routeId != null,\n    `useFetcher can only be used on routes that contain a unique \"id\"`\n  );\n  let defaultKey = react__WEBPACK_IMPORTED_MODULE_0__.useId();\n  let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || defaultKey);\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => router.deleteFetcher(fetcherKey);\n  }, [router, fetcherKey]);\n  let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (href, opts) => {\n      invariant(routeId, \"No routeId available for fetcher.load()\");\n      await router.fetch(fetcherKey, routeId, href, opts);\n    },\n    [fetcherKey, routeId, router]\n  );\n  let submitImpl = useSubmit();\n  let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n    async (target, opts) => {\n      await submitImpl(target, {\n        ...opts,\n        navigate: false,\n        fetcherKey\n      });\n    },\n    [fetcherKey, submitImpl]\n  );\n  let unstable_reset = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((opts) => router.resetFetcher(fetcherKey, opts), [router, fetcherKey]);\n  let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    let FetcherForm2 = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n      (props, ref) => {\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, { ...props, navigate: false, fetcherKey, ref });\n      }\n    );\n    FetcherForm2.displayName = \"fetcher.Form\";\n    return FetcherForm2;\n  }, [fetcherKey]);\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data2 = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => ({\n      Form: FetcherForm,\n      submit,\n      load,\n      unstable_reset,\n      ...fetcher,\n      data: data2\n    }),\n    [FetcherForm, submit, load, unstable_reset, fetcher, data2]\n  );\n  return fetcherWithComponents;\n}\nfunction useFetchers() {\n  let state = useDataRouterState2(\"useFetchers\" /* UseFetchers */);\n  return Array.from(state.fetchers.entries()).map(([key, fetcher]) => ({\n    ...fetcher,\n    key\n  }));\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction getScrollRestorationKey(location, matches, basename, getKey) {\n  let key = null;\n  if (getKey) {\n    if (basename !== \"/\") {\n      key = getKey(\n        {\n          ...location,\n          pathname: stripBasename(location.pathname, basename) || location.pathname\n        },\n        matches\n      );\n    } else {\n      key = getKey(location, matches);\n    }\n  }\n  if (key == null) {\n    key = location.key;\n  }\n  return key;\n}\nfunction useScrollRestoration({\n  getKey,\n  storageKey\n} = {}) {\n  let { router } = useDataRouterContext3(\"useScrollRestoration\" /* UseScrollRestoration */);\n  let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(\n    \"useScrollRestoration\" /* UseScrollRestoration */\n  );\n  let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  usePageHide(\n    react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n      if (navigation.state === \"idle\") {\n        let key = getScrollRestorationKey(location, matches, basename, getKey);\n        savedScrollPositions[key] = window.scrollY;\n      }\n      try {\n        sessionStorage.setItem(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY,\n          JSON.stringify(savedScrollPositions)\n        );\n      } catch (error) {\n        warning(\n          false,\n          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`\n        );\n      }\n      window.history.scrollRestoration = \"auto\";\n    }, [navigation.state, getKey, basename, location, matches, storageKey])\n  );\n  if (typeof document !== \"undefined\") {\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY\n        );\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n      }\n    }, [storageKey]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n      let disableScrollRestoration = router?.enableScrollRestoration(\n        savedScrollPositions,\n        () => window.scrollY,\n        getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0\n      );\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      try {\n        if (location.hash) {\n          let el = document.getElementById(\n            decodeURIComponent(location.hash.slice(1))\n          );\n          if (el) {\n            el.scrollIntoView();\n            return;\n          }\n        }\n      } catch {\n        warning(\n          false,\n          `\"${location.hash.slice(\n            1\n          )}\" is not a decodable element ID. The view will not scroll to it.`\n        );\n      }\n      if (preventScrollReset === true) {\n        return;\n      }\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\nfunction useBeforeUnload(callback, options) {\n  let { capture } = options || {};\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let opts = capture != null ? { capture } : void 0;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePageHide(callback, options) {\n  let { capture } = options || {};\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    let opts = capture != null ? { capture } : void 0;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\nfunction usePrompt({\n  when,\n  message\n}) {\n  let blocker = useBlocker(when);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\nfunction useViewTransitionState(to, { relative } = {}) {\n  let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);\n  invariant(\n    vtContext != null,\n    \"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\"\n  );\n  let { basename } = useDataRouterContext3(\n    \"useViewTransitionState\" /* useViewTransitionState */\n  );\n  let path = useResolvedPath(to, { relative });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n\n// lib/dom/server.tsx\n\nfunction StaticRouter({\n  basename,\n  children,\n  location: locationProp = \"/\"\n}) {\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let action = \"POP\" /* Pop */;\n  let location = {\n    pathname: locationProp.pathname || \"/\",\n    search: locationProp.search || \"\",\n    hash: locationProp.hash || \"\",\n    state: locationProp.state != null ? locationProp.state : null,\n    key: locationProp.key || \"default\"\n  };\n  let staticNavigator = getStatelessNavigator();\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    Router,\n    {\n      basename,\n      children,\n      location,\n      navigationType: action,\n      navigator: staticNavigator,\n      static: true\n    }\n  );\n}\nfunction StaticRouterProvider({\n  context,\n  router,\n  hydrate: hydrate2 = true,\n  nonce\n}) {\n  invariant(\n    router && context,\n    \"You must provide `router` and `context` to <StaticRouterProvider>\"\n  );\n  let dataRouterContext = {\n    router,\n    navigator: getStatelessNavigator(),\n    static: true,\n    staticContext: context,\n    basename: context.basename || \"/\"\n  };\n  let fetchersContext = /* @__PURE__ */ new Map();\n  let hydrateScript = \"\";\n  if (hydrate2 !== false) {\n    let data2 = {\n      loaderData: context.loaderData,\n      actionData: context.actionData,\n      errors: serializeErrors(context.errors)\n    };\n    let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));\n    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n  }\n  let { state } = dataRouterContext.router;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, { value: fetchersContext }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, { value: { isTransitioning: false } }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    Router,\n    {\n      basename: dataRouterContext.basename,\n      location: state.location,\n      navigationType: state.historyAction,\n      navigator: dataRouterContext.navigator,\n      static: dataRouterContext.static\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      DataRoutes2,\n      {\n        routes: router.routes,\n        future: router.future,\n        state\n      }\n    )\n  ))))), hydrateScript ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"script\",\n    {\n      suppressHydrationWarning: true,\n      nonce,\n      dangerouslySetInnerHTML: { __html: hydrateScript }\n    }\n  ) : null);\n}\nfunction DataRoutes2({\n  routes,\n  future,\n  state\n}) {\n  return useRoutesImpl(routes, void 0, state, void 0, future);\n}\nfunction serializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    if (isRouteErrorResponse(val)) {\n      serialized[key] = { ...val, __type: \"RouteErrorResponse\" };\n    } else if (val instanceof Error) {\n      serialized[key] = {\n        message: val.message,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.\n        ...val.name !== \"Error\" ? {\n          __subType: val.name\n        } : {}\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nfunction getStatelessNavigator() {\n  return {\n    createHref,\n    encodeLocation,\n    push(to) {\n      throw new Error(\n        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`\n      );\n    },\n    replace(to) {\n      throw new Error(\n        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere in your app.`\n      );\n    },\n    go(delta) {\n      throw new Error(\n        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${delta})\\` somewhere in your app.`\n      );\n    },\n    back() {\n      throw new Error(\n        `You cannot use navigator.back() on the server because it is a stateless environment.`\n      );\n    },\n    forward() {\n      throw new Error(\n        `You cannot use navigator.forward() on the server because it is a stateless environment.`\n      );\n    }\n  };\n}\nfunction createStaticHandler2(routes, opts) {\n  return createStaticHandler(routes, {\n    ...opts,\n    mapRouteProperties\n  });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n  let manifest = {};\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties,\n    void 0,\n    manifest\n  );\n  let matches = context.matches.map((match) => {\n    let route = manifest[match.route.id] || match.route;\n    return {\n      ...match,\n      route\n    };\n  });\n  let msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;\n  return {\n    get basename() {\n      return context.basename;\n    },\n    get future() {\n      return {\n        v8_middleware: false,\n        ...opts?.future\n      };\n    },\n    get state() {\n      return {\n        historyAction: \"POP\" /* Pop */,\n        location: context.location,\n        matches,\n        loaderData: context.loaderData,\n        actionData: context.actionData,\n        errors: context.errors,\n        initialized: true,\n        navigation: IDLE_NAVIGATION,\n        restoreScrollPosition: null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        fetchers: /* @__PURE__ */ new Map(),\n        blockers: /* @__PURE__ */ new Map()\n      };\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return void 0;\n    },\n    initialize() {\n      throw msg(\"initialize\");\n    },\n    subscribe() {\n      throw msg(\"subscribe\");\n    },\n    enableScrollRestoration() {\n      throw msg(\"enableScrollRestoration\");\n    },\n    navigate() {\n      throw msg(\"navigate\");\n    },\n    fetch() {\n      throw msg(\"fetch\");\n    },\n    revalidate() {\n      throw msg(\"revalidate\");\n    },\n    createHref,\n    encodeLocation,\n    getFetcher() {\n      return IDLE_FETCHER;\n    },\n    deleteFetcher() {\n      throw msg(\"deleteFetcher\");\n    },\n    resetFetcher() {\n      throw msg(\"resetFetcher\");\n    },\n    dispose() {\n      throw msg(\"dispose\");\n    },\n    getBlocker() {\n      return IDLE_BLOCKER;\n    },\n    deleteBlocker() {\n      throw msg(\"deleteBlocker\");\n    },\n    patchRoutes() {\n      throw msg(\"patchRoutes\");\n    },\n    _internalFetchControllers: /* @__PURE__ */ new Map(),\n    _internalSetRoutes() {\n      throw msg(\"_internalSetRoutes\");\n    },\n    _internalSetStateDoNotUseOrYouWillBreakYourApp() {\n      throw msg(\"_internalSetStateDoNotUseOrYouWillBreakYourApp\");\n    }\n  };\n}\nfunction createHref(to) {\n  return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n  let href = typeof to === \"string\" ? to : createPath(to);\n  href = href.replace(/ $/, \"%20\");\n  let encoded = ABSOLUTE_URL_REGEX3.test(href) ? new URL(href) : new URL(href, \"http://localhost\");\n  return {\n    pathname: encoded.pathname,\n    search: encoded.search,\n    hash: encoded.hash\n  };\n}\nvar ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar ESCAPE_LOOKUP2 = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX2 = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n  return str.replace(ESCAPE_REGEX2, (match) => ESCAPE_LOOKUP2[match]);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvY2h1bmstTklTSFlSSUsubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWM7QUFDZjtBQUNBLHlDQUF5QztBQUN6QyxRQUFRLHlEQUF5RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1C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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3Q0FBd0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVksSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUE0RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTBJRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2RldmVsb3BtZW50L2NodW5rLU5JU0hZUklLLm1qcz81NDMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3Qtcm91dGVyIHY3LjkuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcblxuLy8gbGliL3JvdXRlci9oaXN0b3J5LnRzXG52YXIgQWN0aW9uID0gLyogQF9fUFVSRV9fICovICgoQWN0aW9uMikgPT4ge1xuICBBY3Rpb24yW1wiUG9wXCJdID0gXCJQT1BcIjtcbiAgQWN0aW9uMltcIlB1c2hcIl0gPSBcIlBVU0hcIjtcbiAgQWN0aW9uMltcIlJlcGxhY2VcIl0gPSBcIlJFUExBQ0VcIjtcbiAgcmV0dXJuIEFjdGlvbjI7XG59KShBY3Rpb24gfHwge30pO1xudmFyIFBvcFN0YXRlRXZlbnRUeXBlID0gXCJwb3BzdGF0ZVwiO1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zID0ge30pIHtcbiAgbGV0IHsgaW5pdGlhbEVudHJpZXMgPSBbXCIvXCJdLCBpbml0aWFsSW5kZXgsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzO1xuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKFxuICAgIChlbnRyeSwgaW5kZXgyKSA9PiBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICAgIGVudHJ5LFxuICAgICAgdHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiID8gbnVsbCA6IGVudHJ5LnN0YXRlLFxuICAgICAgaW5kZXgyID09PSAwID8gXCJkZWZhdWx0XCIgOiB2b2lkIDBcbiAgICApXG4gICk7XG4gIGxldCBpbmRleCA9IGNsYW1wSW5kZXgoXG4gICAgaW5pdGlhbEluZGV4ID09IG51bGwgPyBlbnRyaWVzLmxlbmd0aCAtIDEgOiBpbml0aWFsSW5kZXhcbiAgKTtcbiAgbGV0IGFjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBmdW5jdGlvbiBjbGFtcEluZGV4KG4pIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUgPSBudWxsLCBrZXkpIHtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcbiAgICAgIGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLFxuICAgICAgdG8sXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX1gXG4gICAgKTtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZjIodG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IHtcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50TG9jYXRpb24oKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYyLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZjIodG8pLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gICAgfSxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogcGF0aC5wYXRobmFtZSB8fCBcIlwiLFxuICAgICAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXG4gICAgICAgIGhhc2g6IHBhdGguaGFzaCB8fCBcIlwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMgPSB7fSkge1xuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24od2luZG93MiwgZ2xvYmFsSGlzdG9yeSkge1xuICAgIGxldCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IHdpbmRvdzIubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyIHx8IG51bGwsXG4gICAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3cyLCB0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlQnJvd3NlckxvY2F0aW9uLFxuICAgIGNyZWF0ZUJyb3dzZXJIcmVmLFxuICAgIG51bGwsXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucyA9IHt9KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbih3aW5kb3cyLCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCJcbiAgICB9ID0gcGFyc2VQYXRoKHdpbmRvdzIubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgIGlmICghcGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLFxuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93MiwgdG8pIHtcbiAgICBsZXQgYmFzZSA9IHdpbmRvdzIuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIik7XG4gICAgbGV0IGhyZWYgPSBcIlwiO1xuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkge1xuICAgICAgbGV0IHVybCA9IHdpbmRvdzIubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uLCB0bykge1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaCgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX0pYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVIYXNoTG9jYXRpb24sXG4gICAgY3JlYXRlSGFzaEhyZWYsXG4gICAgdmFsaWRhdGVIYXNoTG9jYXRpb24sXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xufVxuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oY3VycmVudCwgdG8sIHN0YXRlID0gbnVsbCwga2V5KSB7XG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogdHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIgPyBjdXJyZW50IDogY3VycmVudC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IFwiXCIsXG4gICAgaGFzaDogXCJcIixcbiAgICAuLi50eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG8sXG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogdG8gJiYgdG8ua2V5IHx8IGtleSB8fCBjcmVhdGVLZXkoKVxuICB9O1xuICByZXR1cm4gbG9jYXRpb247XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoKHtcbiAgcGF0aG5hbWUgPSBcIi9cIixcbiAgc2VhcmNoID0gXCJcIixcbiAgaGFzaCA9IFwiXCJcbn0pIHtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09IFwiP1wiKVxuICAgIHBhdGhuYW1lICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09IFwiP1wiID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09IFwiI1wiKVxuICAgIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0ge307XG4gIGlmIChwYXRoKSB7XG4gICAgbGV0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShnZXRMb2NhdGlvbiwgY3JlYXRlSHJlZjIsIHZhbGlkYXRlTG9jYXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgeyB3aW5kb3c6IHdpbmRvdzIgPSBkb2N1bWVudC5kZWZhdWx0VmlldywgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cyLmhpc3Rvcnk7XG4gIGxldCBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgbGV0IGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyAuLi5nbG9iYWxIaXN0b3J5LnN0YXRlLCBpZHg6IGluZGV4IH0sIFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgIGxldCBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwgeyBpZHg6IG51bGwgfTtcbiAgICByZXR1cm4gc3RhdGUuaWR4O1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICBsZXQgbmV4dEluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgZGVsdGEgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXggLSBpbmRleDtcbiAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHB1c2godG8sIHN0YXRlKSB7XG4gICAgYWN0aW9uID0gXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiRGF0YUNsb25lRXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdzIubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgfVxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZTIodG8sIHN0YXRlKSB7XG4gICAgYWN0aW9uID0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLztcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGxldCBoaXN0b3J5U3RhdGUgPSBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG8pIHtcbiAgICByZXR1cm4gY3JlYXRlQnJvd3NlclVSTEltcGwodG8pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0ge1xuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHdpbmRvdzIsIGdsb2JhbEhpc3RvcnkpO1xuICAgIH0sXG4gICAgbGlzdGVuKGZuKSB7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBoaXN0b3J5IG9ubHkgYWNjZXB0cyBvbmUgYWN0aXZlIGxpc3RlbmVyXCIpO1xuICAgICAgfVxuICAgICAgd2luZG93Mi5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdzIucmVtb3ZlRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYodG8pIHtcbiAgICAgIHJldHVybiBjcmVhdGVIcmVmMih3aW5kb3cyLCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgZ28obikge1xuICAgICAgcmV0dXJuIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJVUkxJbXBsKHRvLCBpc0Fic29sdXRlID0gZmFsc2UpIHtcbiAgbGV0IGJhc2UgPSBcImh0dHA6Ly9sb2NhbGhvc3RcIjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBiYXNlID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCIgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIDogd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIH1cbiAgaW52YXJpYW50KGJhc2UsIFwiTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkxcIik7XG4gIGxldCBocmVmID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgaHJlZiA9IGhyZWYucmVwbGFjZSgvICQvLCBcIiUyMFwiKTtcbiAgaWYgKCFpc0Fic29sdXRlICYmIGhyZWYuc3RhcnRzV2l0aChcIi8vXCIpKSB7XG4gICAgaHJlZiA9IGJhc2UgKyBocmVmO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKGhyZWYsIGJhc2UpO1xufVxuXG4vLyBsaWIvcm91dGVyL3V0aWxzLnRzXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4geyBkZWZhdWx0VmFsdWUgfTtcbn1cbnZhciBfbWFwO1xudmFyIFJvdXRlckNvbnRleHRQcm92aWRlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgUm91dGVyQ29udGV4dFByb3ZpZGVyYCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gaW5pdCBBbiBvcHRpb25hbCBpbml0aWFsIGNvbnRleHQgbWFwIHRvIHBvcHVsYXRlIHRoZSBwcm92aWRlciB3aXRoXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tYXAsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGlmIChpbml0KSB7XG4gICAgICBmb3IgKGxldCBbY29udGV4dCwgdmFsdWVdIG9mIGluaXQpIHtcbiAgICAgICAgdGhpcy5zZXQoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWNjZXNzIGEgdmFsdWUgZnJvbSB0aGUgY29udGV4dC4gSWYgbm8gdmFsdWUgaGFzIGJlZW4gc2V0IGZvciB0aGUgY29udGV4dCxcbiAgICogaXQgd2lsbCByZXR1cm4gdGhlIGNvbnRleHQncyBgZGVmYXVsdFZhbHVlYCBpZiBwcm92aWRlZCwgb3IgdGhyb3cgYW4gZXJyb3JcbiAgICogaWYgbm8gYGRlZmF1bHRWYWx1ZWAgd2FzIHNldC5cbiAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQgdG8gZ2V0IHRoZSB2YWx1ZSBmb3JcbiAgICogQHJldHVybnMgVGhlIHZhbHVlIGZvciB0aGUgY29udGV4dCwgb3IgdGhlIGNvbnRleHQncyBgZGVmYXVsdFZhbHVlYCBpZiBub1xuICAgKiB2YWx1ZSB3YXMgc2V0XG4gICAqL1xuICBnZXQoY29udGV4dCkge1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX21hcCkuaGFzKGNvbnRleHQpKSB7XG4gICAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9tYXApLmdldChjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBjb250ZXh0LmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgZm91bmQgZm9yIGNvbnRleHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGZvciB0aGUgY29udGV4dC4gSWYgdGhlIGNvbnRleHQgYWxyZWFkeSBoYXMgYSB2YWx1ZSBzZXQsIHRoaXNcbiAgICogd2lsbCBvdmVyd3JpdGUgaXQuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGZvciB0aGUgY29udGV4dFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHNldChjb250ZXh0LCB2YWx1ZSkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKS5zZXQoY29udGV4dCwgdmFsdWUpO1xuICB9XG59O1xuX21hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgdW5zdXBwb3J0ZWRMYXp5Um91dGVPYmplY3RLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImxhenlcIixcbiAgXCJjYXNlU2Vuc2l0aXZlXCIsXG4gIFwicGF0aFwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJjaGlsZHJlblwiXG5dKTtcbmZ1bmN0aW9uIGlzVW5zdXBwb3J0ZWRMYXp5Um91dGVPYmplY3RLZXkoa2V5KSB7XG4gIHJldHVybiB1bnN1cHBvcnRlZExhenlSb3V0ZU9iamVjdEtleXMuaGFzKFxuICAgIGtleVxuICApO1xufVxudmFyIHVuc3VwcG9ydGVkTGF6eVJvdXRlRnVuY3Rpb25LZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImxhenlcIixcbiAgXCJjYXNlU2Vuc2l0aXZlXCIsXG4gIFwicGF0aFwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJtaWRkbGV3YXJlXCIsXG4gIFwiY2hpbGRyZW5cIlxuXSk7XG5mdW5jdGlvbiBpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlRnVuY3Rpb25LZXkoa2V5KSB7XG4gIHJldHVybiB1bnN1cHBvcnRlZExhenlSb3V0ZUZ1bmN0aW9uS2V5cy5oYXMoXG4gICAga2V5XG4gICk7XG59XG5mdW5jdGlvbiBpc0luZGV4Um91dGUocm91dGUpIHtcbiAgcmV0dXJuIHJvdXRlLmluZGV4ID09PSB0cnVlO1xufVxuZnVuY3Rpb24gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhyb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllczIsIHBhcmVudFBhdGggPSBbXSwgbWFuaWZlc3QgPSB7fSwgYWxsb3dJblBsYWNlTXV0YXRpb25zID0gZmFsc2UpIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBTdHJpbmcoaW5kZXgpXTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlIHx8ICFyb3V0ZS5jaGlsZHJlbixcbiAgICAgIGBDYW5ub3Qgc3BlY2lmeSBjaGlsZHJlbiBvbiBhbiBpbmRleCByb3V0ZWBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgIGFsbG93SW5QbGFjZU11dGF0aW9ucyB8fCAhbWFuaWZlc3RbaWRdLFxuICAgICAgYEZvdW5kIGEgcm91dGUgaWQgY29sbGlzaW9uIG9uIGlkIFwiJHtpZH1cIi4gIFJvdXRlIGlkJ3MgbXVzdCBiZSBnbG9iYWxseSB1bmlxdWUgd2l0aGluIERhdGEgUm91dGVyIHVzYWdlc2BcbiAgICApO1xuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZSA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIC4uLm1hcFJvdXRlUHJvcGVydGllczIocm91dGUpLFxuICAgICAgICBpZFxuICAgICAgfTtcbiAgICAgIG1hbmlmZXN0W2lkXSA9IGluZGV4Um91dGU7XG4gICAgICByZXR1cm4gaW5kZXhSb3V0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhdGhPckxheW91dFJvdXRlID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZSksXG4gICAgICAgIGlkLFxuICAgICAgICBjaGlsZHJlbjogdm9pZCAwXG4gICAgICB9O1xuICAgICAgbWFuaWZlc3RbaWRdID0gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcGF0aE9yTGF5b3V0Um91dGUuY2hpbGRyZW4gPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgdHJlZVBhdGgsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgYWxsb3dJblBsYWNlTXV0YXRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aE9yTGF5b3V0Um91dGU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lID0gXCIvXCIpIHtcbiAgcmV0dXJuIG1hdGNoUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lLCBhbGxvd1BhcnRpYWwpIHtcbiAgbGV0IGxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgZGVjb2RlZCA9IGRlY29kZVBhdGgocGF0aG5hbWUpO1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoKFxuICAgICAgYnJhbmNoZXNbaV0sXG4gICAgICBkZWNvZGVkLFxuICAgICAgYWxsb3dQYXJ0aWFsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG1hdGNoLCBsb2FkZXJEYXRhKSB7XG4gIGxldCB7IHJvdXRlLCBwYXRobmFtZSwgcGFyYW1zIH0gPSBtYXRjaDtcbiAgcmV0dXJuIHtcbiAgICBpZDogcm91dGUuaWQsXG4gICAgcGF0aG5hbWUsXG4gICAgcGFyYW1zLFxuICAgIGRhdGE6IGxvYWRlckRhdGFbcm91dGUuaWRdLFxuICAgIGxvYWRlckRhdGE6IGxvYWRlckRhdGFbcm91dGUuaWRdLFxuICAgIGhhbmRsZTogcm91dGUuaGFuZGxlXG4gIH07XG59XG5mdW5jdGlvbiBmbGF0dGVuUm91dGVzKHJvdXRlcywgYnJhbmNoZXMgPSBbXSwgcGFyZW50c01ldGEgPSBbXSwgcGFyZW50UGF0aCA9IFwiXCIsIF9oYXNQYXJlbnRPcHRpb25hbFNlZ21lbnRzID0gZmFsc2UpIHtcbiAgbGV0IGZsYXR0ZW5Sb3V0ZSA9IChyb3V0ZSwgaW5kZXgsIGhhc1BhcmVudE9wdGlvbmFsU2VnbWVudHMgPSBfaGFzUGFyZW50T3B0aW9uYWxTZWdtZW50cywgcmVsYXRpdmVQYXRoKSA9PiB7XG4gICAgbGV0IG1ldGEgPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6IHJlbGF0aXZlUGF0aCA9PT0gdm9pZCAwID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGVcbiAgICB9O1xuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaWYgKCFtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpICYmIGhhc1BhcmVudE9wdGlvbmFsU2VnbWVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggXCIke3BhcmVudFBhdGh9XCIgaXMgbm90IHZhbGlkLiBBbiBhYnNvbHV0ZSBjaGlsZCByb3V0ZSBwYXRoIG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcbiAgICAgIG1ldGEucmVsYXRpdmVQYXRoID0gbWV0YS5yZWxhdGl2ZVBhdGguc2xpY2UocGFyZW50UGF0aC5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXCIke3BhdGh9XCIuYFxuICAgICAgKTtcbiAgICAgIGZsYXR0ZW5Sb3V0ZXMoXG4gICAgICAgIHJvdXRlLmNoaWxkcmVuLFxuICAgICAgICBicmFuY2hlcyxcbiAgICAgICAgcm91dGVzTWV0YSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgaGFzUGFyZW50T3B0aW9uYWxTZWdtZW50c1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYnJhbmNoZXMucHVzaCh7XG4gICAgICBwYXRoLFxuICAgICAgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksXG4gICAgICByb3V0ZXNNZXRhXG4gICAgfSk7XG4gIH07XG4gIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBpZiAocm91dGUucGF0aCA9PT0gXCJcIiB8fCAhcm91dGUucGF0aD8uaW5jbHVkZXMoXCI/XCIpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgdHJ1ZSwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBicmFuY2hlcztcbn1cbmZ1bmN0aW9uIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHBhdGgpIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBzZWdtZW50cztcbiAgbGV0IGlzT3B0aW9uYWwgPSBmaXJzdC5lbmRzV2l0aChcIj9cIik7XG4gIGxldCByZXF1aXJlZCA9IGZpcnN0LnJlcGxhY2UoL1xcPyQvLCBcIlwiKTtcbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBbcmVxdWlyZWQsIFwiXCJdIDogW3JlcXVpcmVkXTtcbiAgfVxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgcmVzdWx0LnB1c2goXG4gICAgLi4ucmVzdEV4cGxvZGVkLm1hcChcbiAgICAgIChzdWJwYXRoKSA9PiBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpXG4gICAgKVxuICApO1xuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5tYXAoXG4gICAgKGV4cGxvZGVkKSA9PiBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZFxuICApO1xufVxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpIHtcbiAgYnJhbmNoZXMuc29ydChcbiAgICAoYSwgYikgPT4gYS5zY29yZSAhPT0gYi5zY29yZSA/IGIuc2NvcmUgLSBhLnNjb3JlIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICBhLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLFxuICAgICAgYi5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KVxuICAgIClcbiAgKTtcbn1cbnZhciBwYXJhbVJlID0gL146W1xcdy1dKyQvO1xudmFyIGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xudmFyIGluZGV4Um91dGVWYWx1ZSA9IDI7XG52YXIgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xudmFyIHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xudmFyIHNwbGF0UGVuYWx0eSA9IC0yO1xudmFyIGlzU3BsYXQgPSAocykgPT4gcyA9PT0gXCIqXCI7XG5mdW5jdGlvbiBjb21wdXRlU2NvcmUocGF0aCwgaW5kZXgpIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuICBpZiAoaW5kZXgpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gaW5kZXhSb3V0ZVZhbHVlO1xuICB9XG4gIHJldHVybiBzZWdtZW50cy5maWx0ZXIoKHMpID0+ICFpc1NwbGF0KHMpKS5yZWR1Y2UoXG4gICAgKHNjb3JlLCBzZWdtZW50KSA9PiBzY29yZSArIChwYXJhbVJlLnRlc3Qoc2VnbWVudCkgPyBkeW5hbWljU2VnbWVudFZhbHVlIDogc2VnbWVudCA9PT0gXCJcIiA/IGVtcHR5U2VnbWVudFZhbHVlIDogc3RhdGljU2VnbWVudFZhbHVlKSxcbiAgICBpbml0aWFsU2NvcmVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGEsIGIpIHtcbiAgbGV0IHNpYmxpbmdzID0gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuc2xpY2UoMCwgLTEpLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBiW2ldKTtcbiAgcmV0dXJuIHNpYmxpbmdzID8gKFxuICAgIC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcbiAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAvLyB3YW50IHRoZW0gdHJpZWQuXG4gICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICkgOiAoXG4gICAgLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAgIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2goYnJhbmNoLCBwYXRobmFtZSwgYWxsb3dQYXJ0aWFsID0gZmFsc2UpIHtcbiAgbGV0IHsgcm91dGVzTWV0YSB9ID0gYnJhbmNoO1xuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcbiAgICBpZiAoIW1hdGNoICYmIGVuZCAmJiBhbGxvd1BhcnRpYWwgJiYgIXJvdXRlc01ldGFbcm91dGVzTWV0YS5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICAgIHtcbiAgICAgICAgICBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoXG4gICAgICAgIGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgob3JpZ2luYWxQYXRoLCBwYXJhbXMgPSB7fSkge1xuICBsZXQgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpICYmIHBhdGggIT09IFwiKlwiICYmICFwYXRoLmVuZHNXaXRoKFwiLypcIikpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICAgKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCIvXCIgOiBcIlwiO1xuICBjb25zdCBzdHJpbmdpZnkyID0gKHApID0+IHAgPT0gbnVsbCA/IFwiXCIgOiB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHAgOiBTdHJpbmcocCk7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pLm1hcCgoc2VnbWVudCwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxO1xuICAgIGlmIChpc0xhc3RTZWdtZW50ICYmIHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgICBjb25zdCBzdGFyID0gXCIqXCI7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5MihwYXJhbXNbc3Rhcl0pO1xuICAgIH1cbiAgICBjb25zdCBrZXlNYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFtcXHctXSspKFxcPz8pJC8pO1xuICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgY29uc3QgWywga2V5LCBvcHRpb25hbF0gPSBrZXlNYXRjaDtcbiAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXldO1xuICAgICAgaW52YXJpYW50KG9wdGlvbmFsID09PSBcIj9cIiB8fCBwYXJhbSAhPSBudWxsLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnkyKHBhcmFtKSk7XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gIH0pLmZpbHRlcigoc2VnbWVudCkgPT4gISFzZWdtZW50KTtcbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gbWF0Y2hbMF07XG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICBsZXQgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnNsaWNlKDEpO1xuICBsZXQgcGFyYW1zID0gY29tcGlsZWRQYXJhbXMucmVkdWNlKFxuICAgIChtZW1vMiwgeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWwgfSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aCkucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICAgIGlmIChpc09wdGlvbmFsICYmICF2YWx1ZSkge1xuICAgICAgICBtZW1vMltwYXJhbU5hbWVdID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbzJbcGFyYW1OYW1lXSA9ICh2YWx1ZSB8fCBcIlwiKS5yZXBsYWNlKC8lMkYvZywgXCIvXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW8yO1xuICAgIH0sXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoZWRQYXRobmFtZSxcbiAgICBwYXRobmFtZUJhc2UsXG4gICAgcGF0dGVyblxuICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0aCwgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLCBlbmQgPSB0cnVlKSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG4gIGxldCBwYXJhbXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKS5yZXBsYWNlKC9bXFxcXC4qK14ke318KClbXFxdXS9nLCBcIlxcXFwkJlwiKS5yZXBsYWNlKFxuICAgIC9cXC86KFtcXHctXSspKFxcPyk/L2csXG4gICAgKF8sIHBhcmFtTmFtZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgcGFyYW1zLnB1c2goeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwgIT0gbnVsbCB9KTtcbiAgICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgICB9XG4gICkucmVwbGFjZSgvXFwvKFtcXHctXSspXFw/KFxcL3wkKS9nLCBcIigvJDEpPyQyXCIpO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbXMucHVzaCh7IHBhcmFtTmFtZTogXCIqXCIgfSk7XG4gICAgcmVnZXhwU291cmNlICs9IHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIiA/IFwiKC4qKSRcIiA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7XG4gIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIHtcbiAgfVxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdm9pZCAwIDogXCJpXCIpO1xuICByZXR1cm4gW21hdGNoZXIsIHBhcmFtc107XG59XG5mdW5jdGlvbiBkZWNvZGVQYXRoKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KFwiL1wiKS5tYXAoKHYpID0+IGRlY29kZVVSSUNvbXBvbmVudCh2KS5yZXBsYWNlKC9cXC8vZywgXCIlMkZcIikpLmpvaW4oXCIvXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgVVJMIHBhdGggXCIke3ZhbHVlfVwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgYSBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKSB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcbiAgaWYgKCFwYXRobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYmFzZW5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IGJhc2VuYW1lLmxlbmd0aCAtIDEgOiBiYXNlbmFtZS5sZW5ndGg7XG4gIGxldCBuZXh0Q2hhciA9IHBhdGhuYW1lLmNoYXJBdChzdGFydEluZGV4KTtcbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cbmZ1bmN0aW9uIHByZXBlbmRCYXNlbmFtZSh7XG4gIGJhc2VuYW1lLFxuICBwYXRobmFtZVxufSkge1xuICByZXR1cm4gcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKSA6IGZyb21QYXRobmFtZTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihjaGFyLCBmaWVsZCwgZGVzdCwgcGF0aCkge1xuICByZXR1cm4gYENhbm5vdCBpbmNsdWRlIGEgJyR7Y2hhcn0nIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBcXGB0by4ke2ZpZWxkfVxcYCBmaWVsZCBbJHtKU09OLnN0cmluZ2lmeShcbiAgICBwYXRoXG4gICl9XS4gIFBsZWFzZSBzZXBhcmF0ZSBpdCBvdXQgdG8gdGhlIFxcYHRvLiR7ZGVzdH1cXGAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgYSBzdHJpbmcgaW4gPExpbmsgdG89XCIuLi5cIj4gYW5kIHRoZSByb3V0ZXIgd2lsbCBwYXJzZSBpdCBmb3IgeW91LmA7XG59XG5mdW5jdGlvbiBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcihcbiAgICAobWF0Y2gsIGluZGV4KSA9PiBpbmRleCA9PT0gMCB8fCBtYXRjaC5yb3V0ZS5wYXRoICYmIG1hdGNoLnJvdXRlLnBhdGgubGVuZ3RoID4gMFxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKFxuICAgIChtYXRjaCwgaWR4KSA9PiBpZHggPT09IHBhdGhNYXRjaGVzLmxlbmd0aCAtIDEgPyBtYXRjaC5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZVxuICApO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRvKHRvQXJnLCByb3V0ZVBhdGhuYW1lcywgbG9jYXRpb25QYXRobmFtZSwgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZSkge1xuICBsZXQgdG87XG4gIGlmICh0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0byA9IHBhcnNlUGF0aCh0b0FyZyk7XG4gIH0gZWxzZSB7XG4gICAgdG8gPSB7IC4uLnRvQXJnIH07XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIj9cIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgfVxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG4gIGxldCBmcm9tO1xuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG4gICAgaWYgKCFpc1BhdGhSZWxhdGl2ZSAmJiB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID0gdG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgbGV0IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoID0gKGlzRW1wdHlQYXRoIHx8IHRvUGF0aG5hbWUgPT09IFwiLlwiKSAmJiBsb2NhdGlvblBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgaWYgKCFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKSkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG52YXIgam9pblBhdGhzID0gKHBhdGhzKSA9PiBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcbnZhciBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZSkgPT4gcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbnZhciBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoKSA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG52YXIgbm9ybWFsaXplSGFzaCA9IChoYXNoKSA9PiAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbnZhciBEYXRhV2l0aFJlc3BvbnNlSW5pdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGF0YTIsIGluaXQpIHtcbiAgICB0aGlzLnR5cGUgPSBcIkRhdGFXaXRoUmVzcG9uc2VJbml0XCI7XG4gICAgdGhpcy5kYXRhID0gZGF0YTI7XG4gICAgdGhpcy5pbml0ID0gaW5pdCB8fCBudWxsO1xuICB9XG59O1xuZnVuY3Rpb24gZGF0YShkYXRhMiwgaW5pdCkge1xuICByZXR1cm4gbmV3IERhdGFXaXRoUmVzcG9uc2VJbml0KFxuICAgIGRhdGEyLFxuICAgIHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8geyBzdGF0dXM6IGluaXQgfSA6IGluaXRcbiAgKTtcbn1cbnZhciByZWRpcmVjdCA9ICh1cmwsIGluaXQgPSAzMDIpID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0geyBzdGF0dXM6IHJlc3BvbnNlSW5pdCB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgLi4ucmVzcG9uc2VJbml0LCBoZWFkZXJzIH0pO1xufTtcbnZhciByZWRpcmVjdERvY3VtZW50ID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbnZhciByZXBsYWNlID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVwbGFjZVwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG52YXIgRXJyb3JSZXNwb25zZUltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YTIsIGludGVybmFsID0gZmFsc2UpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgIGlmIChkYXRhMiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMi50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGEyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMjtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikge1xuICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiYgXCJkYXRhXCIgaW4gZXJyb3I7XG59XG5cbi8vIGxpYi9yb3V0ZXIvcm91dGVyLnRzXG52YXIgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIgPSBbXG4gIFwiUE9TVFwiLFxuICBcIlBVVFwiLFxuICBcIlBBVENIXCIsXG4gIFwiREVMRVRFXCJcbl07XG52YXIgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0KFxuICB2YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuKTtcbnZhciB2YWxpZFJlcXVlc3RNZXRob2RzQXJyID0gW1xuICBcIkdFVFwiLFxuICAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuXTtcbnZhciB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldCh2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcbnZhciByZWRpcmVjdFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG52YXIgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwNywgMzA4XSk7XG52YXIgSURMRV9OQVZJR0FUSU9OID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB2b2lkIDAsXG4gIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICBmb3JtRGF0YTogdm9pZCAwLFxuICBqc29uOiB2b2lkIDAsXG4gIHRleHQ6IHZvaWQgMFxufTtcbnZhciBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdm9pZCAwLFxuICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgZm9ybURhdGE6IHZvaWQgMCxcbiAganNvbjogdm9pZCAwLFxuICB0ZXh0OiB2b2lkIDBcbn07XG52YXIgSURMRV9CTE9DS0VSID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdm9pZCAwLFxuICByZXNldDogdm9pZCAwLFxuICBsb2NhdGlvbjogdm9pZCAwXG59O1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbnZhciBpc0Fic29sdXRlVXJsID0gKHVybCkgPT4gQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodXJsKTtcbnZhciBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzID0gKHJvdXRlKSA9PiAoe1xuICBoYXNFcnJvckJvdW5kYXJ5OiBCb29sZWFuKHJvdXRlLmhhc0Vycm9yQm91bmRhcnkpXG59KTtcbnZhciBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSA9IFwicmVtaXgtcm91dGVyLXRyYW5zaXRpb25zXCI7XG52YXIgUmVzZXRMb2FkZXJEYXRhU3ltYm9sID0gU3ltYm9sKFwiUmVzZXRMb2FkZXJEYXRhXCIpO1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKGluaXQpIHtcbiAgY29uc3Qgcm91dGVyV2luZG93ID0gaW5pdC53aW5kb3cgPyBpbml0LndpbmRvdyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gIGNvbnN0IGlzQnJvd3NlcjIgPSB0eXBlb2Ygcm91dGVyV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICBpbnZhcmlhbnQoXG4gICAgaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVJvdXRlclwiXG4gICk7XG4gIGxldCBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMyID0gaW5pdC5oeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMgfHwgW107XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXMyID0gaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXMgfHwgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICBpbml0LnJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBsZXQgaW5GbGlnaHREYXRhUm91dGVzO1xuICBsZXQgYmFzZW5hbWUgPSBpbml0LmJhc2VuYW1lIHx8IFwiL1wiO1xuICBpZiAoIWJhc2VuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgYmFzZW5hbWUgPSBgLyR7YmFzZW5hbWV9YDtcbiAgfVxuICBsZXQgZGF0YVN0cmF0ZWd5SW1wbCA9IGluaXQuZGF0YVN0cmF0ZWd5IHx8IGRlZmF1bHREYXRhU3RyYXRlZ3lXaXRoTWlkZGxld2FyZTtcbiAgbGV0IGZ1dHVyZSA9IHtcbiAgICAuLi5pbml0LmZ1dHVyZVxuICB9O1xuICBsZXQgdW5saXN0ZW5IaXN0b3J5ID0gbnVsbDtcbiAgbGV0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zMiA9IG51bGw7XG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIgPSBudWxsO1xuICBsZXQgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICBsZXQgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbiwgYmFzZW5hbWUpO1xuICBsZXQgaW5pdGlhbE1hdGNoZXNJc0ZPVyA9IGZhbHNlO1xuICBsZXQgaW5pdGlhbEVycm9ycyA9IG51bGw7XG4gIGxldCBpbml0aWFsaXplZDtcbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwgJiYgIWluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24pIHtcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgcGF0aG5hbWU6IGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZVxuICAgIH0pO1xuICAgIGxldCB7IG1hdGNoZXMsIHJvdXRlIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHsgW3JvdXRlLmlkXTogZXJyb3IgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5pdGlhbE1hdGNoZXMgJiYgIWluaXQuaHlkcmF0aW9uRGF0YSkge1xuICAgICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihcbiAgICAgICAgaW5pdGlhbE1hdGNoZXMsXG4gICAgICAgIGRhdGFSb3V0ZXMsXG4gICAgICAgIGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChmb2dPZldhci5hY3RpdmUpIHtcbiAgICAgICAgaW5pdGlhbE1hdGNoZXMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluaXRpYWxNYXRjaGVzKSB7XG4gICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgaW5pdGlhbE1hdGNoZXMgPSBbXTtcbiAgICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGRhdGFSb3V0ZXMsXG4gICAgICAgIGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgICBpbml0aWFsTWF0Y2hlc0lzRk9XID0gdHJ1ZTtcbiAgICAgICAgaW5pdGlhbE1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sYXp5KSkge1xuICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiByb3V0ZUhhc0xvYWRlck9yTWlkZGxld2FyZShtLnJvdXRlKSkpIHtcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxvYWRlckRhdGEgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSA6IG51bGw7XG4gICAgICBsZXQgZXJyb3JzID0gaW5pdC5oeWRyYXRpb25EYXRhID8gaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyA6IG51bGw7XG4gICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgIGxldCBpZHggPSBpbml0aWFsTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAgICAgKG0pID0+IGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdm9pZCAwXG4gICAgICAgICk7XG4gICAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuc2xpY2UoMCwgaWR4ICsgMSkuZXZlcnkoXG4gICAgICAgICAgKG0pID0+ICFzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihtLnJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsaXplZCA9IGluaXRpYWxNYXRjaGVzLmV2ZXJ5KFxuICAgICAgICAgIChtKSA9PiAhc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24obS5yb3V0ZSwgbG9hZGVyRGF0YSwgZXJyb3JzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgcm91dGVyO1xuICBsZXQgc3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSB8fCBudWxsLFxuICAgIGVycm9yczogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBibG9ja2VyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBsZXQgcGVuZGluZ0FjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyO1xuICBsZXQgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICBsZXQgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIGxldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBhY3RpdmVGZXRjaGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgdW5ibG9ja0Jsb2NrZXJIaXN0b3J5VXBkYXRlID0gdm9pZCAwO1xuICBsZXQgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihcbiAgICAgICh7IGFjdGlvbjogaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIGRlbHRhIH0pID0+IHtcbiAgICAgICAgaWYgKHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSkge1xuICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSgpO1xuICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDAgfHwgZGVsdGEgIT0gbnVsbCxcbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIHVzZSBhIGJsb2NrZXIgb24gYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIHRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciB2aWEgYHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZWAvYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCBpbnN0ZWFkIG9mIHVzaW5nIHJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIGNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIlxuICAgICAgICApO1xuICAgICAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChibG9ja2VyS2V5ICYmIGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgbmV4dEhpc3RvcnlVcGRhdGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHJlc29sdmU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhICogLTEpO1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvY2VlZDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbG9jYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5leHRIaXN0b3J5VXBkYXRlUHJvbWlzZS50aGVuKCgpID0+IGluaXQuaGlzdG9yeS5nbyhkZWx0YSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24pO1xuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGlzQnJvd3NlcjIpIHtcbiAgICAgIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIGxldCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyA9ICgpID0+IHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIHJvdXRlcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gKCkgPT4gcm91dGVyV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihcIlBPUFwiIC8qIFBvcCAqLywgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgaW5pdGlhbEh5ZHJhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodW5saXN0ZW5IaXN0b3J5KSB7XG4gICAgICB1bmxpc3Rlbkhpc3RvcnkoKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZuKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKG5ld1N0YXRlLm1hdGNoZXMpIHtcbiAgICAgIG5ld1N0YXRlLm1hdGNoZXMgPSBuZXdTdGF0ZS5tYXRjaGVzLm1hcCgobSkgPT4ge1xuICAgICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFttLnJvdXRlLmlkXTtcbiAgICAgICAgbGV0IG1hdGNoUm91dGUgPSBtLnJvdXRlO1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZS5lbGVtZW50ICE9PSByb3V0ZS5lbGVtZW50IHx8IG1hdGNoUm91dGUuZXJyb3JFbGVtZW50ICE9PSByb3V0ZS5lcnJvckVsZW1lbnQgfHwgbWF0Y2hSb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50ICE9PSByb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm0sXG4gICAgICAgICAgICByb3V0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm5ld1N0YXRlXG4gICAgfTtcbiAgICBsZXQgdW5tb3VudGVkRmV0Y2hlcnMgPSBbXTtcbiAgICBsZXQgbW91bnRlZEZldGNoZXJzID0gW107XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgICAgICB1bm1vdW50ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW91bnRlZEZldGNoZXJzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLmZldGNoZXJzLmhhcyhrZXkpICYmICFmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIHVubW91bnRlZEZldGNoZXJzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBbLi4uc3Vic2NyaWJlcnNdLmZvckVhY2goXG4gICAgICAoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcihzdGF0ZSwge1xuICAgICAgICBkZWxldGVkRmV0Y2hlcnM6IHVubW91bnRlZEZldGNoZXJzLFxuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHM6IG9wdHMudmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgICBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlXG4gICAgICB9KVxuICAgICk7XG4gICAgdW5tb3VudGVkRmV0Y2hlcnMuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIG1vdW50ZWRGZXRjaGVycy5mb3JFYWNoKChrZXkpID0+IHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIG5ld1N0YXRlLCB7IGZsdXNoU3luYyB9ID0ge30pIHtcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPSBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiYgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZTtcbiAgICBsZXQgYWN0aW9uRGF0YTtcbiAgICBpZiAobmV3U3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1N0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG5ld1N0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQWN0aW9uUmVsb2FkKSB7XG4gICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBsb2FkZXJEYXRhID0gbmV3U3RhdGUubG9hZGVyRGF0YSA/IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICBuZXdTdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSxcbiAgICAgIG5ld1N0YXRlLmVycm9yc1xuICAgICkgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuICAgIGxldCBibG9ja2VycyA9IHN0YXRlLmJsb2NrZXJzO1xuICAgIGlmIChibG9ja2Vycy5zaXplID4gMCkge1xuICAgICAgYmxvY2tlcnMgPSBuZXcgTWFwKGJsb2NrZXJzKTtcbiAgICAgIGJsb2NrZXJzLmZvckVhY2goKF8sIGspID0+IGJsb2NrZXJzLnNldChrLCBJRExFX0JMT0NLRVIpKTtcbiAgICB9XG4gICAgbGV0IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9IGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA/IGZhbHNlIDogZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbmV3U3RhdGUubWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSB8fCBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiYgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlO1xuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIHtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUE9QXCIgLyogUG9wICovKSB7XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlBVU0hcIiAvKiBQdXNoICovKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLykge1xuICAgICAgaW5pdC5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9XG4gICAgbGV0IHZpZXdUcmFuc2l0aW9uT3B0cztcbiAgICBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJQT1BcIiAvKiBQb3AgKi8pIHtcbiAgICAgIGxldCBwcmlvclBhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHByaW9yUGF0aHMgJiYgcHJpb3JQYXRocy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcbiAgICAgIGxldCB0b1BhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHRvUGF0aHMpIHtcbiAgICAgICAgdG9QYXRocy5hZGQobG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9QYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xuICAgICAgICBhcHBsaWVkVmlld1RyYW5zaXRpb25zLnNldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgdG9QYXRocyk7XG4gICAgICB9XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAge1xuICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgLy8gbWF0Y2hlcywgZXJyb3JzLCBmZXRjaGVycyBnbyB0aHJvdWdoIGFzLWlzXG4gICAgICAgIGFjdGlvbkRhdGEsXG4gICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgIGhpc3RvcnlBY3Rpb246IHBlbmRpbmdBY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb24sXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgYmxvY2tlcnNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyxcbiAgICAgICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMgPT09IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBwZW5kaW5nUmV2YWxpZGF0aW9uRGZkPy5yZXNvbHZlKCk7XG4gICAgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IG51bGw7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdGUodG8sIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpbml0Lmhpc3RvcnkuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhcbiAgICAgIHN0YXRlLmxvY2F0aW9uLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgdG8sXG4gICAgICBvcHRzPy5mcm9tUm91dGVJZCxcbiAgICAgIG9wdHM/LnJlbGF0aXZlXG4gICAgKTtcbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uLCBlcnJvciB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKFxuICAgICAgZmFsc2UsXG4gICAgICBub3JtYWxpemVkUGF0aCxcbiAgICAgIG9wdHNcbiAgICApO1xuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG4gICAgbmV4dExvY2F0aW9uID0ge1xuICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgLi4uaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbilcbiAgICB9O1xuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB2b2lkIDA7XG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgIGlmICh1c2VyUmVwbGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgfSBlbHNlIGlmICh1c2VyUmVwbGFjZSA9PT0gZmFsc2UpIHtcbiAgICB9IGVsc2UgaWYgKHN1Ym1pc3Npb24gIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkgJiYgc3VibWlzc2lvbi5mb3JtQWN0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgfVxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBvcHRzICYmIFwicHJldmVudFNjcm9sbFJlc2V0XCIgaW4gb3B0cyA/IG9wdHMucHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIDogdm9pZCAwO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0pO1xuICAgIGlmIChibG9ja2VyS2V5KSB7XG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdm9pZCAwLFxuICAgICAgICAgICAgcmVzZXQ6IHZvaWQgMCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuYXZpZ2F0ZSh0bywgb3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5LCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudmlld1RyYW5zaXRpb24sXG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXZhbGlkYXRlKCkge1xuICAgIGlmICghcGVuZGluZ1JldmFsaWRhdGlvbkRmZCkge1xuICAgICAgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgfVxuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgdXBkYXRlU3RhdGUoeyByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiIH0pO1xuICAgIGxldCBwcm9taXNlID0gcGVuZGluZ1JldmFsaWRhdGlvbkRmZC5wcm9taXNlO1xuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcInN1Ym1pdHRpbmdcIikge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgc3RhcnROYXZpZ2F0aW9uKFxuICAgICAgcGVuZGluZ0FjdGlvbiB8fCBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbixcbiAgICAgIHtcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uOiBzdGF0ZS5uYXZpZ2F0aW9uLFxuICAgICAgICAvLyBQcm94eSB0aHJvdWdoIGFueSByZW5kaW5nIHZpZXcgdHJhbnNpdGlvblxuICAgICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9PT0gdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCBvcHRzKSB7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgcGVuZGluZ0FjdGlvbiA9IGhpc3RvcnlBY3Rpb247XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gKG9wdHMgJiYgb3B0cy5zdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pID09PSB0cnVlO1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gKG9wdHMgJiYgb3B0cy5lbmFibGVWaWV3VHJhbnNpdGlvbikgPT09IHRydWU7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3B0cyAmJiBvcHRzLm92ZXJyaWRlTmF2aWdhdGlvbjtcbiAgICBsZXQgbWF0Y2hlcyA9IG9wdHM/LmluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUubWF0Y2hlcyAmJiBzdGF0ZS5tYXRjaGVzLmxlbmd0aCA+IDAgJiYgIWluaXRpYWxNYXRjaGVzSXNGT1cgPyAoXG4gICAgICAvLyBgbWF0Y2hSb3V0ZXMoKWAgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgaWYgd2UncmUgaW4gaGVyZSB2aWEgYHJvdXRlci5pbml0aWFsaXplKClgXG4gICAgICBzdGF0ZS5tYXRjaGVzXG4gICAgKSA6IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgaWYgKG1hdGNoZXMgJiYgc3RhdGUuaW5pdGlhbGl6ZWQgJiYgIWlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgJiYgaXNIYXNoQ2hhbmdlT25seShzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24pICYmICEob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpKSB7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHsgbWF0Y2hlcyB9LCB7IGZsdXNoU3luYyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcyA9IGZvZ09mV2FyLm1hdGNoZXM7XG4gICAgfVxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IHsgZXJyb3IsIG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChcbiAgICAgICAgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb25cbiAgICApO1xuICAgIGxldCBzY29wZWRDb250ZXh0ID0gaW5pdC5nZXRDb250ZXh0ID8gYXdhaXQgaW5pdC5nZXRDb250ZXh0KCkgOiBuZXcgUm91dGVyQ29udGV4dFByb3ZpZGVyKCk7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25SZXN1bHQ7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBbXG4gICAgICAgIGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWQsXG4gICAgICAgIHsgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLCBlcnJvcjogb3B0cy5wZW5kaW5nRXJyb3IgfVxuICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYXdhaXQgaGFuZGxlQWN0aW9uKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgb3B0cy5zdWJtaXNzaW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICBmb2dPZldhci5hY3RpdmUsXG4gICAgICAgIG9wdHMgJiYgb3B0cy5pbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgICB7IHJlcGxhY2U6IG9wdHMucmVwbGFjZSwgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICBpZiAoYWN0aW9uUmVzdWx0LnNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgICAgICBsZXQgW3JvdXRlSWQsIHJlc3VsdF0gPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSAmJiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpICYmIHJlc3VsdC5lcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgICAgICBtYXRjaGVzOiBhY3Rpb25SZXN1bHQubWF0Y2hlcyxcbiAgICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICAgIFtyb3V0ZUlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXRjaGVzID0gYWN0aW9uUmVzdWx0Lm1hdGNoZXMgfHwgbWF0Y2hlcztcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIG9wdHMuc3VibWlzc2lvbik7XG4gICAgICBmbHVzaFN5bmMgPSBmYWxzZTtcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgICBpbml0Lmhpc3RvcnksXG4gICAgICAgIHJlcXVlc3QudXJsLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHNob3J0Q2lyY3VpdGVkLFxuICAgICAgbWF0Y2hlczogdXBkYXRlZE1hdGNoZXMsXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIG9wdHMgJiYgb3B0cy5pbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdFxuICAgICk7XG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICBtYXRjaGVzOiB1cGRhdGVkTWF0Y2hlcyB8fCBtYXRjaGVzLFxuICAgICAgLi4uZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24ocmVxdWVzdCwgbG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMsIHNjb3BlZENvbnRleHQsIGlzRm9nT2ZXYXIsIGluaXRpYWxIeWRyYXRpb24sIG9wdHMgPSB7fSkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgbGV0IG5hdmlnYXRpb24gPSBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgdXBkYXRlU3RhdGUoeyBuYXZpZ2F0aW9uIH0sIHsgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZSB9KTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxldCB7IG1hdGNoZXM6IG1hdGNoZXMyLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hlczIsXG4gICAgICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbXG4gICAgICAgICAgICAgIHJvdXRlLmlkLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgICAgICAgIGVycm9yOiBkaXNjb3ZlclJlc3VsdC5lcnJvclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMpLnJvdXRlLmlkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzLFxuICAgICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtcbiAgICAgICAgICAgIGJvdW5kYXJ5SWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICAgICAgZXJyb3I6IGRpc2NvdmVyUmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBsZXQgeyBub3RGb3VuZE1hdGNoZXMsIGVycm9yLCByb3V0ZSB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KFxuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtcbiAgICAgICAgICAgIHJvdXRlLmlkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgaW5pdGlhbEh5ZHJhdGlvbiA/IFtdIDogaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgc2NvcGVkQ29udGV4dFxuICAgICAgKTtcbiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgZHNNYXRjaGVzLFxuICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1thY3Rpb25NYXRjaC5yb3V0ZS5pZF07XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdHNbbWF0Y2gucm91dGUuaWRdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2UyO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwpIHtcbiAgICAgICAgcmVwbGFjZTIgPSBvcHRzLnJlcGxhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbG9jYXRpb24yID0gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihcbiAgICAgICAgICByZXN1bHQucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKSxcbiAgICAgICAgICBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgICAgICBiYXNlbmFtZVxuICAgICAgICApO1xuICAgICAgICByZXBsYWNlMiA9IGxvY2F0aW9uMiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZXN1bHQsIHRydWUsIHtcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGlmICgob3B0cyAmJiBvcHRzLnJlcGxhY2UpICE9PSB0cnVlKSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb24gPSBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW1xuICAgICAgICAgIGJvdW5kYXJ5TWF0Y2gucm91dGUuaWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW2FjdGlvbk1hdGNoLnJvdXRlLmlkLCByZXN1bHRdXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJzKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCBzY29wZWRDb250ZXh0LCBpc0ZvZ09mV2FyLCBvdmVycmlkZU5hdmlnYXRpb24sIHN1Ym1pc3Npb24sIGZldGNoZXJTdWJtaXNzaW9uLCByZXBsYWNlMiwgaW5pdGlhbEh5ZHJhdGlvbiwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uIHx8IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb24gfHwgZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKGxvYWRpbmdOYXZpZ2F0aW9uKTtcbiAgICBsZXQgc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlID0gIWlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiAmJiAhaW5pdGlhbEh5ZHJhdGlvbjtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZU5hdmlnYXRpb25TdGF0ZSkge1xuICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IGdldFVwZGF0ZWRBY3Rpb25EYXRhKHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xuICAgICAgICB1cGRhdGVTdGF0ZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uOiBsb2FkaW5nTmF2aWdhdGlvbixcbiAgICAgICAgICAgIC4uLmFjdGlvbkRhdGEgIT09IHZvaWQgMCA/IHsgYWN0aW9uRGF0YSB9IDoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZsdXNoU3luY1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGxldCBkaXNjb3ZlclJlc3VsdCA9IGF3YWl0IGRpc2NvdmVyUm91dGVzKFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgcmVxdWVzdC5zaWduYWxcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICAgIH0gZWxzZSBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsZXQgeyBtYXRjaGVzOiBtYXRjaGVzMiwgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoZXM6IG1hdGNoZXMyLFxuICAgICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgICAgW3JvdXRlLmlkXTogZGlzY292ZXJSZXN1bHQuZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcykucm91dGUuaWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBbYm91bmRhcnlJZF06IGRpc2NvdmVyUmVzdWx0LmVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBsZXQgeyBlcnJvciwgbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KFxuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVzID0gZGlzY292ZXJSZXN1bHQubWF0Y2hlcztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IHsgZHNNYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVycyB9ID0gZ2V0TWF0Y2hlc1RvTG9hZChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlU3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgaW5pdGlhbEh5ZHJhdGlvbiA/IFtdIDogaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIGluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLFxuICAgICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbixcbiAgICAgIGZldGNoTG9hZE1hdGNoZXMsXG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24gIT0gbnVsbCxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHRcbiAgICApO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgaWYgKCFpbml0LmRhdGFTdHJhdGVneSAmJiAhZHNNYXRjaGVzLnNvbWUoKG0pID0+IG0uc2hvdWxkTG9hZCkgJiYgIWRzTWF0Y2hlcy5zb21lKFxuICAgICAgKG0pID0+IG0ucm91dGUubWlkZGxld2FyZSAmJiBtLnJvdXRlLm1pZGRsZXdhcmUubGVuZ3RoID4gMFxuICAgICkgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdXBkYXRlZEZldGNoZXJzMiA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIC8vIENvbW1pdCBwZW5kaW5nIGVycm9yIGlmIHdlJ3JlIHNob3J0IGNpcmN1aXRpbmdcbiAgICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHsgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIH0gOiBudWxsLFxuICAgICAgICAgIC4uLmdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCksXG4gICAgICAgICAgLi4udXBkYXRlZEZldGNoZXJzMiA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0gOiB7fVxuICAgICAgICB9LFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFVwZGF0ZU5hdmlnYXRpb25TdGF0ZSkge1xuICAgICAgbGV0IHVwZGF0ZXMgPSB7fTtcbiAgICAgIGlmICghaXNGb2dPZldhcikge1xuICAgICAgICB1cGRhdGVzLm5hdmlnYXRpb24gPSBsb2FkaW5nTmF2aWdhdGlvbjtcbiAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSBnZXRVcGRhdGVkQWN0aW9uRGF0YShwZW5kaW5nQWN0aW9uUmVzdWx0KTtcbiAgICAgICAgaWYgKGFjdGlvbkRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHVwZGF0ZXMuYWN0aW9uRGF0YSA9IGFjdGlvbkRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVwZGF0ZXMuZmV0Y2hlcnMgPSBnZXRVcGRhdGVkUmV2YWxpZGF0aW5nRmV0Y2hlcnMocmV2YWxpZGF0aW5nRmV0Y2hlcnMpO1xuICAgICAgfVxuICAgICAgdXBkYXRlU3RhdGUodXBkYXRlcywgeyBmbHVzaFN5bmMgfSk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICBhYm9ydEZldGNoZXIocmYua2V5KTtcbiAgICAgIGlmIChyZi5jb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKGYpID0+IGFib3J0RmV0Y2hlcihmLmtleSkpO1xuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB7IGxvYWRlclJlc3VsdHMsIGZldGNoZXJSZXN1bHRzIH0gPSBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICBkc01hdGNoZXMsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBzY29wZWRDb250ZXh0XG4gICAgKTtcbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcImFib3J0XCIsXG4gICAgICAgIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHJmLmtleSkpO1xuICAgIGxldCByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QobG9hZGVyUmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0Mikge1xuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVkaXJlY3QyLnJlc3VsdCwgdHJ1ZSwge1xuICAgICAgICByZXBsYWNlOiByZXBsYWNlMlxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QoZmV0Y2hlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKHJlZGlyZWN0Mi5rZXkpO1xuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVkaXJlY3QyLnJlc3VsdCwgdHJ1ZSwge1xuICAgICAgICByZXBsYWNlOiByZXBsYWNlMlxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgKTtcbiAgICBpZiAoaW5pdGlhbEh5ZHJhdGlvbiAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICAgIGVycm9ycyA9IHsgLi4uc3RhdGUuZXJyb3JzLCAuLi5lcnJvcnMgfTtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpO1xuICAgIGxldCBzaG91bGRVcGRhdGVGZXRjaGVycyA9IHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnMsXG4gICAgICAuLi5zaG91bGRVcGRhdGVGZXRjaGVycyA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0gOiB7fVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIGlmIChwZW5kaW5nQWN0aW9uUmVzdWx0ICYmICFpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlZFJldmFsaWRhdGluZ0ZldGNoZXJzKHJldmFsaWRhdGluZ0ZldGNoZXJzKSB7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IHtcbiAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XG4gICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGZldGNoZXIgPyBmZXRjaGVyLmRhdGEgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQocmYua2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1hcChzdGF0ZS5mZXRjaGVycyk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2gyKGtleSwgcm91dGVJZCwgaHJlZiwgb3B0cykge1xuICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGhyZWYsXG4gICAgICByb3V0ZUlkLFxuICAgICAgb3B0cz8ucmVsYXRpdmVcbiAgICApO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIG5vcm1hbGl6ZWRQYXRoLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgbm9ybWFsaXplZFBhdGgpO1xuICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcyA9IGZvZ09mV2FyLm1hdGNoZXM7XG4gICAgfVxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBub3JtYWxpemVkUGF0aCB9KSxcbiAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgICAgIHRydWUsXG4gICAgICBub3JtYWxpemVkUGF0aCxcbiAgICAgIG9wdHNcbiAgICApO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIHsgZmx1c2hTeW5jIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2NvcGVkQ29udGV4dCA9IGluaXQuZ2V0Q29udGV4dCA/IGF3YWl0IGluaXQuZ2V0Q29udGV4dCgpIDogbmV3IFJvdXRlckNvbnRleHRQcm92aWRlcigpO1xuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBhd2FpdCBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgICAgZmx1c2hTeW5jLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwgeyByb3V0ZUlkLCBwYXRoIH0pO1xuICAgIGF3YWl0IGhhbmRsZUZldGNoZXJMb2FkZXIoXG4gICAgICBrZXksXG4gICAgICByb3V0ZUlkLFxuICAgICAgcGF0aCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgZm9nT2ZXYXIuYWN0aXZlLFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckFjdGlvbihrZXksIHJvdXRlSWQsIHBhdGgsIHJlcXVlc3RNYXRjaGVzLCBzY29wZWRDb250ZXh0LCBpc0ZvZ09mV2FyLCBmbHVzaFN5bmMsIHByZXZlbnRTY3JvbGxSZXNldCwgc3VibWlzc2lvbikge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0U3VibWl0dGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyKSwge1xuICAgICAgZmx1c2hTeW5jXG4gICAgfSk7XG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBwYXRoLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICApO1xuICAgIGlmIChpc0ZvZ09mV2FyKSB7XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgcmVxdWVzdE1hdGNoZXMsXG4gICAgICAgIG5ldyBVUkwoZmV0Y2hSZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIGZldGNoUmVxdWVzdC5zaWduYWwsXG4gICAgICAgIGtleVxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBkaXNjb3ZlclJlc3VsdC5lcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBwYXRoIH0pLFxuICAgICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdE1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChyZXF1ZXN0TWF0Y2hlcywgcGF0aCk7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIW1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgcm91dGVJZFxuICAgICAgfSk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGZldGNoTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAgbWF0Y2gsXG4gICAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgc2NvcGVkQ29udGV4dFxuICAgICk7XG4gICAgbGV0IGFjdGlvblJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgZmV0Y2hNYXRjaGVzLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIGtleVxuICAgICk7XG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGFjdGlvblJlc3VsdHNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkgfHwgaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih2b2lkIDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKGZldGNoUmVxdWVzdCwgYWN0aW9uUmVzdWx0LCBmYWxzZSwge1xuICAgICAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb246IHN1Ym1pc3Npb24sXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBhY3Rpb25SZXN1bHQuZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9IHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgIT09IFwiaWRsZVwiID8gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIGJhc2VuYW1lKSA6IHN0YXRlLm1hdGNoZXM7XG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG4gICAgbGV0IGxvYWRGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgYWN0aW9uUmVzdWx0LmRhdGEpO1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRGZXRjaGVyKTtcbiAgICBsZXQgeyBkc01hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzIH0gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgcmV2YWxpZGF0aW9uUmVxdWVzdCxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIGZhbHNlLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24sXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgZmV0Y2hSZWRpcmVjdElkcyxcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uICE9IG51bGwsXG4gICAgICBbbWF0Y2gucm91dGUuaWQsIGFjdGlvblJlc3VsdF1cbiAgICApO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZpbHRlcigocmYpID0+IHJmLmtleSAhPT0ga2V5KS5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgbGV0IHN0YWxlS2V5ID0gcmYua2V5O1xuICAgICAgbGV0IGV4aXN0aW5nRmV0Y2hlcjIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBleGlzdGluZ0ZldGNoZXIyID8gZXhpc3RpbmdGZXRjaGVyMi5kYXRhIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHN0YWxlS2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgIGFib3J0RmV0Y2hlcihzdGFsZUtleSk7XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChzdGFsZUtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBhYm9ydEZldGNoZXIocmYua2V5KSk7XG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgKTtcbiAgICBsZXQgeyBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgZHNNYXRjaGVzLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgc2NvcGVkQ29udGV4dFxuICAgICk7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcImFib3J0XCIsXG4gICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICApO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcbiAgICBpZiAoc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gICAgbGV0IHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChsb2FkZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3QsXG4gICAgICAgIHJlZGlyZWN0Mi5yZXN1bHQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB7IHByZXZlbnRTY3JvbGxSZXNldCB9XG4gICAgICApO1xuICAgIH1cbiAgICByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QoZmV0Y2hlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKHJlZGlyZWN0Mi5rZXkpO1xuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgICByZWRpcmVjdDIucmVzdWx0LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgeyBwcmV2ZW50U2Nyb2xsUmVzZXQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICB2b2lkIDAsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgKTtcbiAgICBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBsb2FkSWQgPiBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCkge1xuICAgICAgaW52YXJpYW50KHBlbmRpbmdBY3Rpb24sIFwiRXhwZWN0ZWQgcGVuZGluZyBhY3Rpb25cIik7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBsb2FkZXJEYXRhOiBtZXJnZUxvYWRlckRhdGEoXG4gICAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgZXJyb3JzXG4gICAgICAgICksXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaGVzLCBzY29wZWRDb250ZXh0LCBpc0ZvZ09mV2FyLCBmbHVzaFN5bmMsIHByZXZlbnRTY3JvbGxSZXNldCwgc3VibWlzc2lvbikge1xuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoXG4gICAgICBrZXksXG4gICAgICBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAgZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB2b2lkIDBcbiAgICAgICksXG4gICAgICB7IGZsdXNoU3luYyB9XG4gICAgKTtcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG5ldyBVUkwoZmV0Y2hSZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIGZldGNoUmVxdWVzdC5zaWduYWwsXG4gICAgICAgIGtleVxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBkaXNjb3ZlclJlc3VsdC5lcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBwYXRoIH0pLFxuICAgICAgICAgIHsgZmx1c2hTeW5jIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYXRjaCxcbiAgICAgIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIsXG4gICAgICBzY29wZWRDb250ZXh0XG4gICAgKTtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBkc01hdGNoZXMsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAga2V5XG4gICAgKTtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodm9pZCAwKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihmZXRjaFJlcXVlc3QsIHJlc3VsdCwgZmFsc2UsIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgcmVzdWx0LmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdDIsIGlzTmF2aWdhdGlvbiwge1xuICAgIHN1Ym1pc3Npb24sXG4gICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gIH0gPSB7fSkge1xuICAgIGlmIChyZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgbG9jYXRpb24gPSByZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICBpbnZhcmlhbnQobG9jYXRpb24sIFwiRXhwZWN0ZWQgYSBMb2NhdGlvbiBoZWFkZXIgb24gdGhlIHJlZGlyZWN0IFJlc3BvbnNlXCIpO1xuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICBiYXNlbmFtZVxuICAgICk7XG4gICAgbGV0IHJlZGlyZWN0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24sIHtcbiAgICAgIF9pc1JlZGlyZWN0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKGlzQnJvd3NlcjIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG4gICAgICBpZiAocmVkaXJlY3QyLnJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikpIHtcbiAgICAgICAgaXNEb2N1bWVudFJlbG9hZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGlzQWJzb2x1dGVVcmwobG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZUJyb3dzZXJVUkxJbXBsKGxvY2F0aW9uLCB0cnVlKTtcbiAgICAgICAgaXNEb2N1bWVudFJlbG9hZCA9IC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRvIGEgbmV3IG9yaWdpblxuICAgICAgICB1cmwub3JpZ2luICE9PSByb3V0ZXJXaW5kb3cubG9jYXRpb24ub3JpZ2luIHx8IC8vIEhhcmQgcmVsb2FkIGlmIGl0J3MgYW4gYWJzb2x1dGUgVVJMIHRoYXQgZG9lcyBub3QgbWF0Y2ggb3VyIGJhc2VuYW1lXG4gICAgICAgIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgPT0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RvY3VtZW50UmVsb2FkKSB7XG4gICAgICAgIGlmIChyZXBsYWNlMikge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24uYXNzaWduKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgbGV0IHJlZGlyZWN0TmF2aWdhdGlvblR5cGUgPSByZXBsYWNlMiA9PT0gdHJ1ZSB8fCByZWRpcmVjdDIucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlcGxhY2VcIikgPyBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovIDogXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtQWN0aW9uLCBmb3JtRW5jVHlwZSB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgIWZldGNoZXJTdWJtaXNzaW9uICYmIGZvcm1NZXRob2QgJiYgZm9ybUFjdGlvbiAmJiBmb3JtRW5jVHlwZSkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uO1xuICAgIGlmIChyZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMuaGFzKHJlZGlyZWN0Mi5yZXNwb25zZS5zdGF0dXMpICYmIGFjdGl2ZVN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChhY3RpdmVTdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgLi4uYWN0aXZlU3VibWlzc2lvbixcbiAgICAgICAgICBmb3JtQWN0aW9uOiBsb2NhdGlvblxuICAgICAgICB9LFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGVzZSBmbGFncyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcHJldmVudFNjcm9sbFJlc2V0IHx8IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBpc05hdmlnYXRpb24gPyBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG92ZXJyaWRlTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKFxuICAgICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgICBzdWJtaXNzaW9uXG4gICAgICApO1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0TmF2aWdhdGlvblR5cGUsIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uLFxuICAgICAgICAvLyBTZW5kIGZldGNoZXIgc3VibWlzc2lvbnMgdGhyb3VnaCBmb3Igc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICAgICAgLy8gUHJlc2VydmUgdGhlc2UgZmxhZ3MgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHByZXZlbnRTY3JvbGxSZXNldCB8fCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogaXNOYXZpZ2F0aW9uID8gcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3kocmVxdWVzdCwgbWF0Y2hlcywgc2NvcGVkQ29udGV4dCwgZmV0Y2hlcktleSkge1xuICAgIGxldCByZXN1bHRzO1xuICAgIGxldCBkYXRhUmVzdWx0cyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneUltcGwoXG4gICAgICAgIGRhdGFTdHJhdGVneUltcGwsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG1hdGNoZXMuZmlsdGVyKChtKSA9PiBtLnNob3VsZExvYWQpLmZvckVhY2goKG0pID0+IHtcbiAgICAgICAgZGF0YVJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhUmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiBkYXRhUmVzdWx0cztcbiAgICB9XG4gICAgZm9yIChsZXQgW3JvdXRlSWQsIHJlc3VsdF0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0cykpIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0RGF0YVN0cmF0ZWd5UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgZGF0YVJlc3VsdHNbcm91dGVJZF0gPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWRpcmVjdFwiIC8qIHJlZGlyZWN0ICovLFxuICAgICAgICAgIHJlc3BvbnNlOiBub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlKFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcm91dGVJZCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBiYXNlbmFtZVxuICAgICAgICAgIClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFSZXN1bHRzW3JvdXRlSWRdID0gYXdhaXQgY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKG1hdGNoZXMsIGZldGNoZXJzVG9Mb2FkLCByZXF1ZXN0LCBzY29wZWRDb250ZXh0KSB7XG4gICAgbGV0IGxvYWRlclJlc3VsdHNQcm9taXNlID0gY2FsbERhdGFTdHJhdGVneShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0c1Byb21pc2UgPSBQcm9taXNlLmFsbChcbiAgICAgIGZldGNoZXJzVG9Mb2FkLm1hcChhc3luYyAoZikgPT4ge1xuICAgICAgICBpZiAoZi5tYXRjaGVzICYmIGYubWF0Y2ggJiYgZi5yZXF1ZXN0ICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgICAgIGYucmVxdWVzdCxcbiAgICAgICAgICAgIGYubWF0Y2hlcyxcbiAgICAgICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgICAgICBmLmtleVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbZi5tYXRjaC5yb3V0ZS5pZF07XG4gICAgICAgICAgcmV0dXJuIHsgW2Yua2V5XTogcmVzdWx0IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBbZi5rZXldOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IGYucGF0aFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgbGV0IGxvYWRlclJlc3VsdHMgPSBhd2FpdCBsb2FkZXJSZXN1bHRzUHJvbWlzZTtcbiAgICBsZXQgZmV0Y2hlclJlc3VsdHMgPSAoYXdhaXQgZmV0Y2hlclJlc3VsdHNQcm9taXNlKS5yZWR1Y2UoXG4gICAgICAoYWNjLCByKSA9PiBPYmplY3QuYXNzaWduKGFjYywgciksXG4gICAgICB7fVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGZldGNoZXIsIG9wdHMgPSB7fSkge1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAgeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSxcbiAgICAgIHsgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWUgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIG9wdHMgPSB7fSkge1xuICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCByb3V0ZUlkKTtcbiAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7XG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9LFxuICAgICAgeyBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRGZXRjaGVyKGtleSkge1xuICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSArIDEpO1xuICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0RmV0Y2hlcihrZXksIG9wdHMpIHtcbiAgICBhYm9ydEZldGNoZXIoa2V5LCBvcHRzPy5yZWFzb24pO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKG51bGwpKTtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyKGtleSkge1xuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkgJiYgIShmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGZldGNoUmVsb2FkSWRzLmhhcyhrZXkpKSkge1xuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmRlbGV0ZShrZXkpO1xuICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5kZWxldGUoa2V5KTtcbiAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiBxdWV1ZUZldGNoZXJGb3JEZWxldGlvbihrZXkpIHtcbiAgICBsZXQgY291bnQgPSAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgLSAxO1xuICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIGNvdW50KTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleSwgcmVhc29uKSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KHJlYXNvbik7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXMpIHtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgbGV0IGZldGNoZXIgPSBnZXRGZXRjaGVyKGtleSk7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihmZXRjaGVyLmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCkge1xuICAgIGxldCBkb25lS2V5cyA9IFtdO1xuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgICB1cGRhdGVkRmV0Y2hlcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgICByZXR1cm4gdXBkYXRlZEZldGNoZXJzO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkKSB7XG4gICAgbGV0IHllZXRlZEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBba2V5LCBpZF0gb2YgZmV0Y2hSZWxvYWRJZHMpIHtcbiAgICAgIGlmIChpZCA8IGxhbmRlZElkKSB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleSwgZm4pIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleSkge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlcihrZXksIG5ld0Jsb2NrZXIpIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIixcbiAgICAgIGBJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogJHtibG9ja2VyLnN0YXRlfSAtPiAke25ld0Jsb2NrZXIuc3RhdGV9YFxuICAgICk7XG4gICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgYmxvY2tlcnMuc2V0KGtleSwgbmV3QmxvY2tlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICBuZXh0TG9jYXRpb24sXG4gICAgaGlzdG9yeUFjdGlvblxuICB9KSB7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID4gMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJBIHJvdXRlciBvbmx5IHN1cHBvcnRzIG9uZSBibG9ja2VyIGF0IGEgdGltZVwiKTtcbiAgICB9XG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGJsb2NrZXJGdW5jdGlvbnMuZW50cmllcygpKTtcbiAgICBsZXQgW2Jsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XG4gICAgaWYgKGJsb2NrZXIgJiYgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbih7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0pKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcktleTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KHBhdGhuYW1lKSB7XG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWUgfSk7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzVG9Vc2UpO1xuICAgIHJldHVybiB7IG5vdEZvdW5kTWF0Y2hlczogbWF0Y2hlcywgcm91dGUsIGVycm9yIH07XG4gIH1cbiAgZnVuY3Rpb24gZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24ocG9zaXRpb25zLCBnZXRQb3NpdGlvbiwgZ2V0S2V5KSB7XG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMyID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyID0gZ2V0S2V5IHx8IG51bGw7XG4gICAgaWYgKCFpbml0aWFsU2Nyb2xsUmVzdG9yZWQgJiYgc3RhdGUubmF2aWdhdGlvbiA9PT0gSURMRV9OQVZJR0FUSU9OKSB7XG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgbGV0IHkgPSBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczIgPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLm1hcCgobSkgPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgc3RhdGUubG9hZGVyRGF0YSkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvbi5rZXk7XG4gIH1cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zMiAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczJba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMyKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnMyW2tleV07XG4gICAgICBpZiAodHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIHBhdGhuYW1lKSB7XG4gICAgaWYgKGluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24pIHtcbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICBsZXQgZm9nTWF0Y2hlcyA9IG1hdGNoUm91dGVzSW1wbChcbiAgICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7IGFjdGl2ZTogdHJ1ZSwgbWF0Y2hlczogZm9nTWF0Y2hlcyB8fCBbXSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1hdGNoZXNbMF0ucGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IHBhcnRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHsgYWN0aXZlOiB0cnVlLCBtYXRjaGVzOiBwYXJ0aWFsTWF0Y2hlcyB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGFjdGl2ZTogZmFsc2UsIG1hdGNoZXM6IG51bGwgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkaXNjb3ZlclJvdXRlcyhtYXRjaGVzLCBwYXRobmFtZSwgc2lnbmFsLCBmZXRjaGVyS2V5KSB7XG4gICAgaWYgKCFpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlcyB9O1xuICAgIH1cbiAgICBsZXQgcGFydGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaXNOb25ITVIgPSBpbkZsaWdodERhdGFSb3V0ZXMgPT0gbnVsbDtcbiAgICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgICAgbGV0IGxvY2FsTWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24oe1xuICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICBwYXRoOiBwYXRobmFtZSxcbiAgICAgICAgICBtYXRjaGVzOiBwYXJ0aWFsTWF0Y2hlcyxcbiAgICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICAgIHBhdGNoOiAocm91dGVJZCwgY2hpbGRyZW4pID0+IHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcGF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgICAgIGxvY2FsTWFuaWZlc3QsXG4gICAgICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3I6IGUsIHBhcnRpYWxNYXRjaGVzIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaXNOb25ITVIgJiYgIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgZGF0YVJvdXRlcyA9IFsuLi5kYXRhUm91dGVzXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYWJvcnRlZFwiIH07XG4gICAgICB9XG4gICAgICBsZXQgbmV3TWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBwYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgaWYgKG5ld01hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hdGNoZXM6IG5ld01hdGNoZXMgfTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdQYXJ0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzSW1wbChcbiAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICAgIGlmICghbmV3UGFydGlhbE1hdGNoZXMgfHwgcGFydGlhbE1hdGNoZXMubGVuZ3RoID09PSBuZXdQYXJ0aWFsTWF0Y2hlcy5sZW5ndGggJiYgcGFydGlhbE1hdGNoZXMuZXZlcnkoXG4gICAgICAgIChtLCBpKSA9PiBtLnJvdXRlLmlkID09PSBuZXdQYXJ0aWFsTWF0Y2hlc1tpXS5yb3V0ZS5pZFxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlczogbnVsbCB9O1xuICAgICAgfVxuICAgICAgcGFydGlhbE1hdGNoZXMgPSBuZXdQYXJ0aWFsTWF0Y2hlcztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2ludGVybmFsU2V0Um91dGVzKG5ld1JvdXRlcykge1xuICAgIG1hbmlmZXN0ID0ge307XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICAgIG5ld1JvdXRlcyxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICB2b2lkIDAsXG4gICAgICBtYW5pZmVzdFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gcGF0Y2hSb3V0ZXMocm91dGVJZCwgY2hpbGRyZW4sIHVuc3RhYmxlX2FsbG93RWxlbWVudE11dGF0aW9ucyA9IGZhbHNlKSB7XG4gICAgbGV0IGlzTm9uSE1SID0gaW5GbGlnaHREYXRhUm91dGVzID09IG51bGw7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgcGF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgcm91dGVJZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICB1bnN0YWJsZV9hbGxvd0VsZW1lbnRNdXRhdGlvbnNcbiAgICApO1xuICAgIGlmIChpc05vbkhNUikge1xuICAgICAgZGF0YVJvdXRlcyA9IFsuLi5kYXRhUm91dGVzXTtcbiAgICAgIHVwZGF0ZVN0YXRlKHt9KTtcbiAgICB9XG4gIH1cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4gZnV0dXJlO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgIHJldHVybiByb3V0ZXJXaW5kb3c7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHJldmFsaWRhdGUsXG4gICAgLy8gUGFzc3Rocm91Z2ggdG8gaGlzdG9yeS1hd2FyZSBjcmVhdGVIcmVmIHVzZWQgYnkgdXNlSHJlZiBzbyB3ZSBnZXQgcHJvcGVyXG4gICAgLy8gaGFzaC1hd2FyZSBVUkxzIGluIERPTSBwYXRoc1xuICAgIGNyZWF0ZUhyZWY6ICh0bykgPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiAodG8pID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICByZXNldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcjogcXVldWVGZXRjaGVyRm9yRGVsZXRpb24sXG4gICAgZGlzcG9zZSxcbiAgICBnZXRCbG9ja2VyLFxuICAgIGRlbGV0ZUJsb2NrZXIsXG4gICAgcGF0Y2hSb3V0ZXMsXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogZmV0Y2hDb250cm9sbGVycyxcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2V0Um91dGVzLCBpdCdzIHRlbXBvcmFyeSB0byBhdm9pZCBkZWFsaW5nIHdpdGhcbiAgICAvLyB1cGRhdGluZyB0aGUgdHJlZSB3aGlsZSB2YWxpZGF0aW5nIHRoZSB1cGRhdGUgYWxnb3JpdGhtLlxuICAgIF9pbnRlcm5hbFNldFJvdXRlcyxcbiAgICBfaW50ZXJuYWxTZXRTdGF0ZURvTm90VXNlT3JZb3VXaWxsQnJlYWtZb3VyQXBwKG5ld1N0YXRlKSB7XG4gICAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcm91dGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIG9wdHMpIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiXG4gICk7XG4gIGxldCBtYW5pZmVzdCA9IHt9O1xuICBsZXQgYmFzZW5hbWUgPSAob3B0cyA/IG9wdHMuYmFzZW5hbWUgOiBudWxsKSB8fCBcIi9cIjtcbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllczIgPSBvcHRzPy5tYXBSb3V0ZVByb3BlcnRpZXMgfHwgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeShyZXF1ZXN0LCB7XG4gICAgcmVxdWVzdENvbnRleHQsXG4gICAgZmlsdGVyTWF0Y2hlc1RvTG9hZCxcbiAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICBza2lwUmV2YWxpZGF0aW9uLFxuICAgIGRhdGFTdHJhdGVneSxcbiAgICBnZW5lcmF0ZU1pZGRsZXdhcmVSZXNwb25zZVxuICB9ID0ge30pIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICByZXF1ZXN0Q29udGV4dCA9IHJlcXVlc3RDb250ZXh0ICE9IG51bGwgPyByZXF1ZXN0Q29udGV4dCA6IG5ldyBSb3V0ZXJDb250ZXh0UHJvdmlkZXIoKTtcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICBsZXQgc3RhdGljQ29udGV4dCA9IHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGdlbmVyYXRlTWlkZGxld2FyZVJlc3BvbnNlID8gZ2VuZXJhdGVNaWRkbGV3YXJlUmVzcG9uc2UoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0YXRpY0NvbnRleHQpKSA6IHN0YXRpY0NvbnRleHQ7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIGxldCBzdGF0aWNDb250ZXh0ID0ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGdlbmVyYXRlTWlkZGxld2FyZVJlc3BvbnNlID8gZ2VuZXJhdGVNaWRkbGV3YXJlUmVzcG9uc2UoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0YXRpY0NvbnRleHQpKSA6IHN0YXRpY0NvbnRleHQ7XG4gICAgfVxuICAgIGlmIChnZW5lcmF0ZU1pZGRsZXdhcmVSZXNwb25zZSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByZXF1ZXN0Q29udGV4dCBpbnN0YW5jZW9mIFJvdXRlckNvbnRleHRQcm92aWRlcixcbiAgICAgICAgXCJXaGVuIHVzaW5nIG1pZGRsZXdhcmUgaW4gYHN0YXRpY0hhbmRsZXIucXVlcnkoKWAsIGFueSBwcm92aWRlZCBgcmVxdWVzdENvbnRleHRgIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYFJvdXRlckNvbnRleHRQcm92aWRlcmBcIlxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxvYWRMYXp5TWlkZGxld2FyZUZvck1hdGNoZXMoXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZW5kZXJlZFN0YXRpY0NvbnRleHQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHJ1blNlcnZlck1pZGRsZXdhcmVQaXBlbGluZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIHBhcmFtczogbWF0Y2hlc1swXS5wYXJhbXMsXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBjYWxsaW5nIG1pZGRsZXdhcmUgdGhlbiBpdCBtdXN0IGJlIGVuYWJsZWQgc28gd2UgY2FuIGNhc3RcbiAgICAgICAgICAgIC8vIHRoaXMgdG8gdGhlIHByb3BlciB0eXBlIGtub3dpbmcgaXQncyBub3QgYW4gYEFwcExvYWRDb250ZXh0YFxuICAgICAgICAgICAgY29udGV4dDogcmVxdWVzdENvbnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBnZW5lcmF0ZU1pZGRsZXdhcmVSZXNwb25zZShcbiAgICAgICAgICAgICAgYXN5bmMgKHJldmFsaWRhdGlvblJlcXVlc3QsIG9wdHMyID0ge30pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPT09IHRydWUsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgXCJmaWx0ZXJNYXRjaGVzVG9Mb2FkXCIgaW4gb3B0czIgPyBvcHRzMi5maWx0ZXJNYXRjaGVzVG9Mb2FkID8/IG51bGwgOiBmaWx0ZXJNYXRjaGVzVG9Mb2FkID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICBza2lwUmV2YWxpZGF0aW9uID09PSB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQyKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbmRlcmVkU3RhdGljQ29udGV4dCA9IHsgbG9jYXRpb24sIGJhc2VuYW1lLCAuLi5yZXN1bHQyIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVkU3RhdGljQ29udGV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyAoZXJyb3IsIHJvdXRlSWQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHBhcnNlUmVzcG9uc2VCb2R5KGVycm9yKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KGVycm9yKSkge1xuICAgICAgICAgICAgICBlcnJvciA9IGRhdGFXaXRoUmVzcG9uc2VJbml0VG9FcnJvclJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZFN0YXRpY0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgaWYgKHJvdXRlSWQgaW4gcmVuZGVyZWRTdGF0aWNDb250ZXh0LmxvYWRlckRhdGEpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN0YXRpY0NvbnRleHQubG9hZGVyRGF0YVtyb3V0ZUlkXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgc3RhdGljQ29udGV4dCA9IGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IoXG4gICAgICAgICAgICAgICAgZGF0YVJvdXRlcyxcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN0YXRpY0NvbnRleHQsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPyByb3V0ZUlkIDogZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCByb3V0ZUlkKS5yb3V0ZS5pZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVNaWRkbGV3YXJlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0YXRpY0NvbnRleHQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgYm91bmRhcnlSb3V0ZUlkID0gc2tpcExvYWRlckVycm9yQnViYmxpbmcgPyByb3V0ZUlkIDogZmluZE5lYXJlc3RCb3VuZGFyeShcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZXMuZmluZChcbiAgICAgICAgICAgICAgICAgIChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkIHx8IG0ucm91dGUubG9hZGVyXG4gICAgICAgICAgICAgICAgKT8ucm91dGUuaWQgfHwgcm91dGVJZFxuICAgICAgICAgICAgICApLnJvdXRlLmlkO1xuICAgICAgICAgICAgICBsZXQgc3RhdGljQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICAgICAgICBbYm91bmRhcnlSb3V0ZUlkXTogZXJyb3JcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICAgICAgICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVNaWRkbGV3YXJlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0YXRpY0NvbnRleHQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpbnZhcmlhbnQoaXNSZXNwb25zZShyZXNwb25zZSksIFwiRXhwZWN0ZWQgYSByZXNwb25zZSBpbiBxdWVyeSgpXCIpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc1Jlc3BvbnNlKGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPT09IHRydWUsXG4gICAgICBudWxsLFxuICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZCB8fCBudWxsLFxuICAgICAgc2tpcFJldmFsaWRhdGlvbiA9PT0gdHJ1ZVxuICAgICk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbG9jYXRpb24sIGJhc2VuYW1lLCAuLi5yZXN1bHQgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBxdWVyeVJvdXRlKHJlcXVlc3QsIHtcbiAgICByb3V0ZUlkLFxuICAgIHJlcXVlc3RDb250ZXh0LFxuICAgIGRhdGFTdHJhdGVneSxcbiAgICBnZW5lcmF0ZU1pZGRsZXdhcmVSZXNwb25zZVxuICB9ID0ge30pIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICByZXF1ZXN0Q29udGV4dCA9IHJlcXVlc3RDb250ZXh0ICE9IG51bGwgPyByZXF1ZXN0Q29udGV4dCA6IG5ldyBSb3V0ZXJDb250ZXh0UHJvdmlkZXIoKTtcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiICYmIG1ldGhvZCAhPT0gXCJPUFRJT05TXCIpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IHJvdXRlSWQgPyBtYXRjaGVzLmZpbmQoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmIChyb3V0ZUlkICYmICFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDMsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgIH1cbiAgICBpZiAoZ2VuZXJhdGVNaWRkbGV3YXJlUmVzcG9uc2UpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgcmVxdWVzdENvbnRleHQgaW5zdGFuY2VvZiBSb3V0ZXJDb250ZXh0UHJvdmlkZXIsXG4gICAgICAgIFwiV2hlbiB1c2luZyBtaWRkbGV3YXJlIGluIGBzdGF0aWNIYW5kbGVyLnF1ZXJ5Um91dGUoKWAsIGFueSBwcm92aWRlZCBgcmVxdWVzdENvbnRleHRgIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYFJvdXRlckNvbnRleHRQcm92aWRlcmBcIlxuICAgICAgKTtcbiAgICAgIGF3YWl0IGxvYWRMYXp5TWlkZGxld2FyZUZvck1hdGNoZXMobWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllczIpO1xuICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgcnVuU2VydmVyTWlkZGxld2FyZVBpcGVsaW5lKFxuICAgICAgICB7XG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIHBhcmFtczogbWF0Y2hlc1swXS5wYXJhbXMsXG4gICAgICAgICAgLy8gSWYgd2UncmUgY2FsbGluZyBtaWRkbGV3YXJlIHRoZW4gaXQgbXVzdCBiZSBlbmFibGVkIHNvIHdlIGNhbiBjYXN0XG4gICAgICAgICAgLy8gdGhpcyB0byB0aGUgcHJvcGVyIHR5cGUga25vd2luZyBpdCdzIG5vdCBhbiBgQXBwTG9hZENvbnRleHRgXG4gICAgICAgICAgY29udGV4dDogcmVxdWVzdENvbnRleHRcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBnZW5lcmF0ZU1pZGRsZXdhcmVSZXNwb25zZShcbiAgICAgICAgICAgIGFzeW5jIChpbm5lclJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdDIgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICAgICAgICAgICAgaW5uZXJSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgICAgICAgZGF0YVN0cmF0ZWd5IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsZXQgcHJvY2Vzc2VkID0gaGFuZGxlUXVlcnlSZXN1bHQocmVzdWx0Mik7XG4gICAgICAgICAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHByb2Nlc3NlZCkgPyBwcm9jZXNzZWQgOiB0eXBlb2YgcHJvY2Vzc2VkID09PSBcInN0cmluZ1wiID8gbmV3IFJlc3BvbnNlKHByb2Nlc3NlZCkgOiBSZXNwb25zZS5qc29uKHByb2Nlc3NlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChlcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YVdpdGhSZXNwb25zZUluaXRUb1Jlc3BvbnNlKGVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgZGF0YVN0cmF0ZWd5IHx8IG51bGwsXG4gICAgICBmYWxzZSxcbiAgICAgIG1hdGNoLFxuICAgICAgbnVsbCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICByZXR1cm4gaGFuZGxlUXVlcnlSZXN1bHQocmVzdWx0KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVRdWVyeVJlc3VsdChyZXN1bHQyKSB7XG4gICAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQyKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGxldCBlcnJvciA9IHJlc3VsdDIuZXJyb3JzID8gT2JqZWN0LnZhbHVlcyhyZXN1bHQyLmVycm9ycylbMF0gOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQyLmFjdGlvbkRhdGEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0Mi5hY3Rpb25EYXRhKVswXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQyLmxvYWRlckRhdGEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0Mi5sb2FkZXJEYXRhKVswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gsIGZpbHRlck1hdGNoZXNUb0xvYWQsIHNraXBSZXZhbGlkYXRpb24pIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIlxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IHN1Ym1pdChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksXG4gICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgICAgIHJvdXRlTWF0Y2ggIT0gbnVsbCxcbiAgICAgICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkLFxuICAgICAgICAgIHNraXBSZXZhbGlkYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIGRhdGFTdHJhdGVneSxcbiAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgIHJvdXRlTWF0Y2gsXG4gICAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWRcbiAgICAgICk7XG4gICAgICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQpID8gcmVzdWx0IDoge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChpc0RhdGFTdHJhdGVneVJlc3VsdChlKSAmJiBpc1Jlc3BvbnNlKGUucmVzdWx0KSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pIHtcbiAgICAgICAgICB0aHJvdyBlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3VibWl0KHJlcXVlc3QsIG1hdGNoZXMsIGFjdGlvbk1hdGNoLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgaXNSb3V0ZVJlcXVlc3QsIGZpbHRlck1hdGNoZXNUb0xvYWQsIHNraXBSZXZhbGlkYXRpb24pIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGFjdGlvbk1hdGNoLFxuICAgICAgICBbXSxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgICk7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGRzTWF0Y2hlcyxcbiAgICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICBkYXRhU3RyYXRlZ3lcbiAgICAgICk7XG4gICAgICByZXN1bHQgPSByZXN1bHRzW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IFthY3Rpb25NYXRjaF0sXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNraXBSZXZhbGlkYXRpb24pIHtcbiAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA/IGFjdGlvbk1hdGNoIDogZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiByZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsID8gcmVzdWx0LnN0YXR1c0NvZGUgOiA1MDAsXG4gICAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5yZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxvYWRlckhlYWRlcnM6IHt9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhY3Rpb25IZWFkZXJzOiByZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXNDb2RlIHx8IDIwMCxcbiAgICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID8gYWN0aW9uTWF0Y2ggOiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGxldCBoYW5kbGVyQ29udGV4dDIgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICBsb2FkZXJSZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWQsIHJlc3VsdF1cbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5oYW5kbGVyQ29udGV4dDIsXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcikgPyByZXN1bHQuZXJyb3Iuc3RhdHVzIDogcmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCA/IHJlc3VsdC5zdGF0dXNDb2RlIDogNTAwLFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgICAgLi4ucmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgaGFuZGxlckNvbnRleHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgbG9hZGVyUmVxdWVzdCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneSxcbiAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgbnVsbCxcbiAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWRcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5oYW5kbGVyQ29udGV4dCxcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGFcbiAgICAgIH0sXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIC4uLnJlc3VsdC5zdGF0dXNDb2RlID8geyBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB9IDoge30sXG4gICAgICBhY3Rpb25IZWFkZXJzOiByZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9XG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCByb3V0ZU1hdGNoLCBmaWx0ZXJNYXRjaGVzVG9Mb2FkLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IGlzUm91dGVSZXF1ZXN0ID0gcm91dGVNYXRjaCAhPSBudWxsO1xuICAgIGlmIChpc1JvdXRlUmVxdWVzdCAmJiAhcm91dGVNYXRjaD8ucm91dGUubG9hZGVyICYmICFyb3V0ZU1hdGNoPy5yb3V0ZS5sYXp5KSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2g/LnJvdXRlLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGRzTWF0Y2hlcztcbiAgICBpZiAocm91dGVNYXRjaCkge1xuICAgICAgZHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcm91dGVNYXRjaCxcbiAgICAgICAgW10sXG4gICAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF4SWR4ID0gcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gKFxuICAgICAgICAvLyBVcCB0byBidXQgbm90IGluY2x1ZGluZyB0aGUgYm91bmRhcnlcbiAgICAgICAgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHBlbmRpbmdBY3Rpb25SZXN1bHRbMF0pIC0gMVxuICAgICAgKSA6IHZvaWQgMDtcbiAgICAgIGRzTWF0Y2hlcyA9IG1hdGNoZXMubWFwKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKG1heElkeCAhPSBudWxsICYmIGluZGV4ID4gbWF4SWR4KSB7XG4gICAgICAgICAgcmV0dXJuIGdldERhdGFTdHJhdGVneU1hdGNoKFxuICAgICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgW10sXG4gICAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2goXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIFtdLFxuICAgICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICAgIChtYXRjaC5yb3V0ZS5sb2FkZXIgfHwgbWF0Y2gucm91dGUubGF6eSkgIT0gbnVsbCAmJiAoIWZpbHRlck1hdGNoZXNUb0xvYWQgfHwgZmlsdGVyTWF0Y2hlc1RvTG9hZChtYXRjaCkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFkYXRhU3RyYXRlZ3kgJiYgIWRzTWF0Y2hlcy5zb21lKChtKSA9PiBtLnNob3VsZExvYWQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7XG4gICAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICByZXF1ZXN0LFxuICAgICAgZHNNYXRjaGVzLFxuICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneVxuICAgICk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVyQ29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQsXG4gICAgICB0cnVlLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmdcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5oYW5kbGVyQ29udGV4dCxcbiAgICAgIG1hdGNoZXNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3kocmVxdWVzdCwgbWF0Y2hlcywgaXNSb3V0ZVJlcXVlc3QsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3kpIHtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3lJbXBsKFxuICAgICAgZGF0YVN0cmF0ZWd5IHx8IGRlZmF1bHREYXRhU3RyYXRlZ3ksXG4gICAgICByZXF1ZXN0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG51bGwsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGxldCBkYXRhUmVzdWx0cyA9IHt9O1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbWF0Y2hlcy5tYXAoYXN5bmMgKG1hdGNoKSA9PiB7XG4gICAgICAgIGlmICghKG1hdGNoLnJvdXRlLmlkIGluIHJlc3VsdHMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgaWYgKGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgdGhyb3cgbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIG1hdGNoLnJvdXRlLmlkLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQucmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQucmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgZGF0YVdpdGhSZXNwb25zZUluaXRUb1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhUmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF0gPSBhd2FpdCBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKHJvdXRlcywgaGFuZGxlckNvbnRleHQsIGVycm9yLCBib3VuZGFyeUlkKSB7XG4gIGxldCBlcnJvckJvdW5kYXJ5SWQgPSBib3VuZGFyeUlkIHx8IGhhbmRsZXJDb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZDtcbiAgcmV0dXJuIHtcbiAgICAuLi5oYW5kbGVyQ29udGV4dCxcbiAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbZXJyb3JCb3VuZGFyeUlkXTogZXJyb3JcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3Quc2lnbmFsLnJlYXNvbiAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uO1xuICB9XG4gIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZCB3aXRob3V0IGFuIFxcYEFib3J0U2lnbmFsLnJlYXNvblxcYDogJHtyZXF1ZXN0Lm1ldGhvZH0gJHtyZXF1ZXN0LnVybH1gXG4gICk7XG59XG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiAoXCJmb3JtRGF0YVwiIGluIG9wdHMgJiYgb3B0cy5mb3JtRGF0YSAhPSBudWxsIHx8IFwiYm9keVwiIGluIG9wdHMgJiYgb3B0cy5ib2R5ICE9PSB2b2lkIDApO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG8obG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCB0bywgZnJvbVJvdXRlSWQsIHJlbGF0aXZlKSB7XG4gIGxldCBjb250ZXh0dWFsTWF0Y2hlcztcbiAgbGV0IGFjdGl2ZVJvdXRlTWF0Y2g7XG4gIGlmIChmcm9tUm91dGVJZCkge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgIHRvID8gdG8gOiBcIi5cIixcbiAgICBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzKSxcbiAgICBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICk7XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuICBpZiAoKHRvID09IG51bGwgfHwgdG8gPT09IFwiXCIgfHwgdG8gPT09IFwiLlwiKSAmJiBhY3RpdmVSb3V0ZU1hdGNoKSB7XG4gICAgbGV0IG5ha2VkSW5kZXggPSBoYXNOYWtlZEluZGV4UXVlcnkocGF0aC5zZWFyY2gpO1xuICAgIGlmIChhY3RpdmVSb3V0ZU1hdGNoLnJvdXRlLmluZGV4ICYmICFuYWtlZEluZGV4KSB7XG4gICAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gICAgfSBlbHNlIGlmICghYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiBuYWtlZEluZGV4KSB7XG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgICBsZXQgaW5kZXhWYWx1ZXMgPSBwYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBpbmRleFZhbHVlcy5maWx0ZXIoKHYpID0+IHYpLmZvckVhY2goKHYpID0+IHBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB2KSk7XG4gICAgICBsZXQgcXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcXMgPyBgPyR7cXN9YCA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcHJlcGVuZEJhc2VuYW1lKHsgYmFzZW5hbWUsIHBhdGhuYW1lOiBwYXRoLnBhdGhuYW1lIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGlzRmV0Y2hlciwgcGF0aCwgb3B0cykge1xuICBpZiAoIW9wdHMgfHwgIWlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykpIHtcbiAgICByZXR1cm4geyBwYXRoIH07XG4gIH1cbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAmJiAhaXNWYWxpZE1ldGhvZChvcHRzLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kOiBvcHRzLmZvcm1NZXRob2QgfSlcbiAgICB9O1xuICB9XG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImludmFsaWQtYm9keVwiIH0pXG4gIH0pO1xuICBsZXQgcmF3Rm9ybU1ldGhvZCA9IG9wdHMuZm9ybU1ldGhvZCB8fCBcImdldFwiO1xuICBsZXQgZm9ybU1ldGhvZCA9IHJhd0Zvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKTtcbiAgaWYgKG9wdHMuYm9keSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0ID0gdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IG9wdHMuYm9keSA6IG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhIHx8IG9wdHMuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IChcbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjcGxhaW4tdGV4dC1mb3JtLWRhdGFcbiAgICAgICAgQXJyYXkuZnJvbShvcHRzLmJvZHkuZW50cmllcygpKS5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgW25hbWUsIHZhbHVlXSkgPT4gYCR7YWNjfSR7bmFtZX09JHt2YWx1ZX1cbmAsXG4gICAgICAgICAgXCJcIlxuICAgICAgICApXG4gICAgICApIDogU3RyaW5nKG9wdHMuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICAgICAganNvbjogdm9pZCAwLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID0gdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2Uob3B0cy5ib2R5KSA6IG9wdHMuYm9keTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRleHQ6IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KFxuICAgIHR5cGVvZiBGb3JtRGF0YSA9PT0gXCJmdW5jdGlvblwiLFxuICAgIFwiRm9ybURhdGEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCJcbiAgKTtcbiAgbGV0IHNlYXJjaFBhcmFtcztcbiAgbGV0IGZvcm1EYXRhO1xuICBpZiAob3B0cy5mb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuZm9ybURhdGEpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5mb3JtRGF0YTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmJvZHk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gb3B0cy5ib2R5O1xuICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgPT0gbnVsbCkge1xuICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1Ym1pc3Npb24gPSB7XG4gICAgZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICBmb3JtRGF0YSxcbiAgICBqc29uOiB2b2lkIDAsXG4gICAgdGV4dDogdm9pZCAwXG4gIH07XG4gIGlmIChpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4geyBwYXRoLCBzdWJtaXNzaW9uIH07XG4gIH1cbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IGA/JHtzZWFyY2hQYXJhbXN9YDtcbiAgcmV0dXJuIHsgcGF0aDogY3JlYXRlUGF0aChwYXJzZWRQYXRoKSwgc3VibWlzc2lvbiB9O1xufVxuZnVuY3Rpb24gZ2V0TWF0Y2hlc1RvTG9hZChyZXF1ZXN0LCBzY29wZWRDb250ZXh0LCBtYXBSb3V0ZVByb3BlcnRpZXMyLCBtYW5pZmVzdCwgaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxvY2F0aW9uLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLCBpbml0aWFsSHlkcmF0aW9uLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24sIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgaGFzUGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24sIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgbGV0IGFjdGlvblJlc3VsdCA9IHBlbmRpbmdBY3Rpb25SZXN1bHQgPyBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciA6IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YSA6IHZvaWQgMDtcbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICBsZXQgbWF4SWR4O1xuICBpZiAoaW5pdGlhbEh5ZHJhdGlvbiAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IE9iamVjdC5rZXlzKHN0YXRlLmVycm9ycylbMF07XG4gICAgbWF4SWR4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSkge1xuICAgIGxldCBib3VuZGFyeUlkID0gcGVuZGluZ0FjdGlvblJlc3VsdFswXTtcbiAgICBtYXhJZHggPSBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gYm91bmRhcnlJZCkgLSAxO1xuICB9XG4gIGxldCBhY3Rpb25TdGF0dXMgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ID8gcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5zdGF0dXNDb2RlIDogdm9pZCAwO1xuICBsZXQgc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA9IGFjdGlvblN0YXR1cyAmJiBhY3Rpb25TdGF0dXMgPj0gNDAwO1xuICBsZXQgYmFzZVNob3VsZFJldmFsaWRhdGVBcmdzID0ge1xuICAgIGN1cnJlbnRVcmwsXG4gICAgY3VycmVudFBhcmFtczogc3RhdGUubWF0Y2hlc1swXT8ucGFyYW1zIHx8IHt9LFxuICAgIG5leHRVcmwsXG4gICAgbmV4dFBhcmFtczogbWF0Y2hlc1swXS5wYXJhbXMsXG4gICAgLi4uc3VibWlzc2lvbixcbiAgICBhY3Rpb25SZXN1bHQsXG4gICAgYWN0aW9uU3RhdHVzXG4gIH07XG4gIGxldCBkc01hdGNoZXMgPSBtYXRjaGVzLm1hcCgobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IHsgcm91dGUgfSA9IG1hdGNoO1xuICAgIGxldCBmb3JjZVNob3VsZExvYWQgPSBudWxsO1xuICAgIGlmIChtYXhJZHggIT0gbnVsbCAmJiBpbmRleCA+IG1heElkeCkge1xuICAgICAgZm9yY2VTaG91bGRMb2FkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChyb3V0ZS5sYXp5KSB7XG4gICAgICBmb3JjZVNob3VsZExvYWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJvdXRlSGFzTG9hZGVyT3JNaWRkbGV3YXJlKHJvdXRlKSkge1xuICAgICAgZm9yY2VTaG91bGRMb2FkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsSHlkcmF0aW9uKSB7XG4gICAgICBmb3JjZVNob3VsZExvYWQgPSBzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgIHN0YXRlLmVycm9yc1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzTmV3TG9hZGVyKHN0YXRlLmxvYWRlckRhdGEsIHN0YXRlLm1hdGNoZXNbaW5kZXhdLCBtYXRjaCkpIHtcbiAgICAgIGZvcmNlU2hvdWxkTG9hZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChmb3JjZVNob3VsZExvYWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBnZXREYXRhU3RyYXRlZ3lNYXRjaChcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLFxuICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICBmb3JjZVNob3VsZExvYWRcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPyBmYWxzZSA6IChcbiAgICAgIC8vIEZvcmNlZCByZXZhbGlkYXRpb24gZHVlIHRvIHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdG9yLCBvciBYLVJlbWl4LVJldmFsaWRhdGVcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHwgY3VycmVudFVybC5wYXRobmFtZSArIGN1cnJlbnRVcmwuc2VhcmNoID09PSBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHwgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fCBpc05ld1JvdXRlSW5zdGFuY2Uoc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKVxuICAgICk7XG4gICAgbGV0IHNob3VsZFJldmFsaWRhdGVBcmdzID0ge1xuICAgICAgLi4uYmFzZVNob3VsZFJldmFsaWRhdGVBcmdzLFxuICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGVcbiAgICB9O1xuICAgIGxldCBzaG91bGRMb2FkID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwgc2hvdWxkUmV2YWxpZGF0ZUFyZ3MpO1xuICAgIHJldHVybiBnZXREYXRhU3RyYXRlZ3lNYXRjaChcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaCxcbiAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsXG4gICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgc2hvdWxkTG9hZCxcbiAgICAgIHNob3VsZFJldmFsaWRhdGVBcmdzXG4gICAgKTtcbiAgfSk7XG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVycyA9IFtdO1xuICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKGYsIGtleSkgPT4ge1xuICAgIGlmIChpbml0aWFsSHlkcmF0aW9uIHx8ICFtYXRjaGVzLnNvbWUoKG0pID0+IG0ucm91dGUuaWQgPT09IGYucm91dGVJZCkgfHwgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBpc01pZEluaXRpYWxMb2FkID0gZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlICE9PSBcImlkbGVcIiAmJiBmZXRjaGVyLmRhdGEgPT09IHZvaWQgMDtcbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XG4gICAgaWYgKCFmZXRjaGVyTWF0Y2hlcykge1xuICAgICAgaWYgKGhhc1BhdGNoUm91dGVzT25OYXZpZ2F0aW9uICYmIGlzTWlkSW5pdGlhbExvYWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IG51bGwsXG4gICAgICAgIG1hdGNoOiBudWxsLFxuICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICBjb250cm9sbGVyOiBudWxsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZldGNoUmVkaXJlY3RJZHMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZldGNoZXJNYXRjaCA9IGdldFRhcmdldE1hdGNoKGZldGNoZXJNYXRjaGVzLCBmLnBhdGgpO1xuICAgIGxldCBmZXRjaENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaGlzdG9yeSxcbiAgICAgIGYucGF0aCxcbiAgICAgIGZldGNoQ29udHJvbGxlci5zaWduYWxcbiAgICApO1xuICAgIGxldCBmZXRjaGVyRHNNYXRjaGVzID0gbnVsbDtcbiAgICBpZiAoY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmhhcyhrZXkpKSB7XG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMuZGVsZXRlKGtleSk7XG4gICAgICBmZXRjaGVyRHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgICBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgZmV0Y2hlck1hdGNoLFxuICAgICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLFxuICAgICAgICBzY29wZWRDb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNNaWRJbml0aWFsTG9hZCkge1xuICAgICAgaWYgKGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQpIHtcbiAgICAgICAgZmV0Y2hlckRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgICAgICBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgICBmZXRjaGVyTWF0Y2gsXG4gICAgICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCxcbiAgICAgICAgICBzY29wZWRDb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzaG91bGRSZXZhbGlkYXRlQXJncyA9IHtcbiAgICAgICAgLi4uYmFzZVNob3VsZFJldmFsaWRhdGVBcmdzLFxuICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA/IGZhbHNlIDogaXNSZXZhbGlkYXRpb25SZXF1aXJlZFxuICAgICAgfTtcbiAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGZldGNoZXJNYXRjaCwgc2hvdWxkUmV2YWxpZGF0ZUFyZ3MpKSB7XG4gICAgICAgIGZldGNoZXJEc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICAgICAgZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgICAgZmV0Y2hlck1hdGNoLFxuICAgICAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsXG4gICAgICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgICAgICBzaG91bGRSZXZhbGlkYXRlQXJnc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmV0Y2hlckRzTWF0Y2hlcykge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxuICAgICAgICBwYXRoOiBmLnBhdGgsXG4gICAgICAgIG1hdGNoZXM6IGZldGNoZXJEc01hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIHJlcXVlc3Q6IGZldGNoUmVxdWVzdCxcbiAgICAgICAgY29udHJvbGxlcjogZmV0Y2hDb250cm9sbGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBkc01hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzIH07XG59XG5mdW5jdGlvbiByb3V0ZUhhc0xvYWRlck9yTWlkZGxld2FyZShyb3V0ZSkge1xuICByZXR1cm4gcm91dGUubG9hZGVyICE9IG51bGwgfHwgcm91dGUubWlkZGxld2FyZSAhPSBudWxsICYmIHJvdXRlLm1pZGRsZXdhcmUubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uKHJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpIHtcbiAgaWYgKHJvdXRlLmxhenkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXJvdXRlSGFzTG9hZGVyT3JNaWRkbGV3YXJlKHJvdXRlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgaGFzRGF0YSA9IGxvYWRlckRhdGEgIT0gbnVsbCAmJiByb3V0ZS5pZCBpbiBsb2FkZXJEYXRhO1xuICBsZXQgaGFzRXJyb3IgPSBlcnJvcnMgIT0gbnVsbCAmJiBlcnJvcnNbcm91dGUuaWRdICE9PSB2b2lkIDA7XG4gIGlmICghaGFzRGF0YSAmJiBoYXNFcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHJvdXRlLmxvYWRlciA9PT0gXCJmdW5jdGlvblwiICYmIHJvdXRlLmxvYWRlci5oeWRyYXRlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICFoYXNEYXRhICYmICFoYXNFcnJvcjtcbn1cbmZ1bmN0aW9uIGlzTmV3TG9hZGVyKGN1cnJlbnRMb2FkZXJEYXRhLCBjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XG4gIGxldCBpc05ldyA9IChcbiAgICAvLyBbYV0gLT4gW2EsIGJdXG4gICAgIWN1cnJlbnRNYXRjaCB8fCAvLyBbYSwgYl0gLT4gW2EsIGNdXG4gICAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZFxuICApO1xuICBsZXQgaXNNaXNzaW5nRGF0YSA9ICFjdXJyZW50TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShtYXRjaC5yb3V0ZS5pZCk7XG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8IC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICBjdXJyZW50UGF0aCAhPSBudWxsICYmIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICApO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihsb2FkZXJNYXRjaCwgYXJnKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG5mdW5jdGlvbiBwYXRjaFJvdXRlc0ltcGwocm91dGVJZCwgY2hpbGRyZW4sIHJvdXRlc1RvVXNlLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzMiwgYWxsb3dFbGVtZW50TXV0YXRpb25zKSB7XG4gIGxldCBjaGlsZHJlblRvUGF0Y2g7XG4gIGlmIChyb3V0ZUlkKSB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Rbcm91dGVJZF07XG4gICAgaW52YXJpYW50KFxuICAgICAgcm91dGUsXG4gICAgICBgTm8gcm91dGUgZm91bmQgdG8gcGF0Y2ggY2hpbGRyZW4gaW50bzogcm91dGVJZCA9ICR7cm91dGVJZH1gXG4gICAgKTtcbiAgICBpZiAoIXJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgICBjaGlsZHJlblRvUGF0Y2ggPSByb3V0ZS5jaGlsZHJlbjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlblRvUGF0Y2ggPSByb3V0ZXNUb1VzZTtcbiAgfVxuICBsZXQgdW5pcXVlQ2hpbGRyZW4gPSBbXTtcbiAgbGV0IGV4aXN0aW5nQ2hpbGRyZW4gPSBbXTtcbiAgY2hpbGRyZW4uZm9yRWFjaCgobmV3Um91dGUpID0+IHtcbiAgICBsZXQgZXhpc3RpbmdSb3V0ZSA9IGNoaWxkcmVuVG9QYXRjaC5maW5kKFxuICAgICAgKGV4aXN0aW5nUm91dGUyKSA9PiBpc1NhbWVSb3V0ZShuZXdSb3V0ZSwgZXhpc3RpbmdSb3V0ZTIpXG4gICAgKTtcbiAgICBpZiAoZXhpc3RpbmdSb3V0ZSkge1xuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5wdXNoKHsgZXhpc3RpbmdSb3V0ZSwgbmV3Um91dGUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXF1ZUNoaWxkcmVuLnB1c2gobmV3Um91dGUpO1xuICAgIH1cbiAgfSk7XG4gIGlmICh1bmlxdWVDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgbGV0IG5ld1JvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICB1bmlxdWVDaGlsZHJlbixcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBbcm91dGVJZCB8fCBcIl9cIiwgXCJwYXRjaFwiLCBTdHJpbmcoY2hpbGRyZW5Ub1BhdGNoPy5sZW5ndGggfHwgXCIwXCIpXSxcbiAgICAgIG1hbmlmZXN0XG4gICAgKTtcbiAgICBjaGlsZHJlblRvUGF0Y2gucHVzaCguLi5uZXdSb3V0ZXMpO1xuICB9XG4gIGlmIChhbGxvd0VsZW1lbnRNdXRhdGlvbnMgJiYgZXhpc3RpbmdDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGlzdGluZ0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgeyBleGlzdGluZ1JvdXRlLCBuZXdSb3V0ZSB9ID0gZXhpc3RpbmdDaGlsZHJlbltpXTtcbiAgICAgIGxldCBleGlzdGluZ1JvdXRlVHlwZWQgPSBleGlzdGluZ1JvdXRlO1xuICAgICAgbGV0IFtuZXdSb3V0ZVR5cGVkXSA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICAgIFtuZXdSb3V0ZV0sXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgIFtdLFxuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlciBmb3IgbXV0YXRlZCByb3V0ZXMgc2luY2UgdGhleSBhbHJlYWR5IGhhdmUgYW4gaWRcbiAgICAgICAge30sXG4gICAgICAgIC8vIERvbid0IHRvdWNoIHRoZSBtYW5pZmVzdCBoZXJlIHNpbmNlIHdlJ3JlIHVwZGF0aW5nIGluIHBsYWNlXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBPYmplY3QuYXNzaWduKGV4aXN0aW5nUm91dGVUeXBlZCwge1xuICAgICAgICBlbGVtZW50OiBuZXdSb3V0ZVR5cGVkLmVsZW1lbnQgPyBuZXdSb3V0ZVR5cGVkLmVsZW1lbnQgOiBleGlzdGluZ1JvdXRlVHlwZWQuZWxlbWVudCxcbiAgICAgICAgZXJyb3JFbGVtZW50OiBuZXdSb3V0ZVR5cGVkLmVycm9yRWxlbWVudCA/IG5ld1JvdXRlVHlwZWQuZXJyb3JFbGVtZW50IDogZXhpc3RpbmdSb3V0ZVR5cGVkLmVycm9yRWxlbWVudCxcbiAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDogbmV3Um91dGVUeXBlZC5oeWRyYXRlRmFsbGJhY2tFbGVtZW50ID8gbmV3Um91dGVUeXBlZC5oeWRyYXRlRmFsbGJhY2tFbGVtZW50IDogZXhpc3RpbmdSb3V0ZVR5cGVkLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lUm91dGUobmV3Um91dGUsIGV4aXN0aW5nUm91dGUpIHtcbiAgaWYgKFwiaWRcIiBpbiBuZXdSb3V0ZSAmJiBcImlkXCIgaW4gZXhpc3RpbmdSb3V0ZSAmJiBuZXdSb3V0ZS5pZCA9PT0gZXhpc3RpbmdSb3V0ZS5pZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghKG5ld1JvdXRlLmluZGV4ID09PSBleGlzdGluZ1JvdXRlLmluZGV4ICYmIG5ld1JvdXRlLnBhdGggPT09IGV4aXN0aW5nUm91dGUucGF0aCAmJiBuZXdSb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSBleGlzdGluZ1JvdXRlLmNhc2VTZW5zaXRpdmUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoIW5ld1JvdXRlLmNoaWxkcmVuIHx8IG5ld1JvdXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgKCFleGlzdGluZ1JvdXRlLmNoaWxkcmVuIHx8IGV4aXN0aW5nUm91dGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBuZXdSb3V0ZS5jaGlsZHJlbi5ldmVyeShcbiAgICAoYUNoaWxkLCBpKSA9PiBleGlzdGluZ1JvdXRlLmNoaWxkcmVuPy5zb21lKChiQ2hpbGQpID0+IGlzU2FtZVJvdXRlKGFDaGlsZCwgYkNoaWxkKSlcbiAgKTtcbn1cbnZhciBsYXp5Um91dGVQcm9wZXJ0eUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgbG9hZExhenlSb3V0ZVByb3BlcnR5ID0gKHtcbiAga2V5LFxuICByb3V0ZSxcbiAgbWFuaWZlc3QsXG4gIG1hcFJvdXRlUHJvcGVydGllczogbWFwUm91dGVQcm9wZXJ0aWVzMlxufSkgPT4ge1xuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG4gIGlmICghcm91dGVUb1VwZGF0ZS5sYXp5IHx8IHR5cGVvZiByb3V0ZVRvVXBkYXRlLmxhenkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGxhenlGbiA9IHJvdXRlVG9VcGRhdGUubGF6eVtrZXldO1xuICBpZiAoIWxhenlGbikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgY2FjaGUgPSBsYXp5Um91dGVQcm9wZXJ0eUNhY2hlLmdldChyb3V0ZVRvVXBkYXRlKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0ge307XG4gICAgbGF6eVJvdXRlUHJvcGVydHlDYWNoZS5zZXQocm91dGVUb1VwZGF0ZSwgY2FjaGUpO1xuICB9XG4gIGxldCBjYWNoZWRQcm9taXNlID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgfVxuICBsZXQgcHJvcGVydHlQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICBsZXQgaXNVbnN1cHBvcnRlZCA9IGlzVW5zdXBwb3J0ZWRMYXp5Um91dGVPYmplY3RLZXkoa2V5KTtcbiAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9IHJvdXRlVG9VcGRhdGVba2V5XTtcbiAgICBsZXQgaXNTdGF0aWNhbGx5RGVmaW5lZCA9IHN0YXRpY1JvdXRlVmFsdWUgIT09IHZvaWQgMCAmJiBrZXkgIT09IFwiaGFzRXJyb3JCb3VuZGFyeVwiO1xuICAgIGlmIChpc1Vuc3VwcG9ydGVkKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhaXNVbnN1cHBvcnRlZCxcbiAgICAgICAgXCJSb3V0ZSBwcm9wZXJ0eSBcIiArIGtleSArIFwiIGlzIG5vdCBhIHN1cHBvcnRlZCBsYXp5IHJvdXRlIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgKTtcbiAgICAgIGNhY2hlW2tleV0gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RhdGljYWxseURlZmluZWQpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBgUm91dGUgXCIke3JvdXRlVG9VcGRhdGUuaWR9XCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFwiJHtrZXl9XCIgZGVmaW5lZC4gVGhlIGxhenkgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2YWx1ZSA9IGF3YWl0IGxhenlGbigpO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlVG9VcGRhdGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByb3V0ZVRvVXBkYXRlLmxhenkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJvdXRlVG9VcGRhdGUubGF6eVtrZXldID0gdm9pZCAwO1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMocm91dGVUb1VwZGF0ZS5sYXp5KS5ldmVyeSgodmFsdWUpID0+IHZhbHVlID09PSB2b2lkIDApKSB7XG4gICAgICAgIHJvdXRlVG9VcGRhdGUubGF6eSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0pKCk7XG4gIGNhY2hlW2tleV0gPSBwcm9wZXJ0eVByb21pc2U7XG4gIHJldHVybiBwcm9wZXJ0eVByb21pc2U7XG59O1xudmFyIGxhenlSb3V0ZUZ1bmN0aW9uQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGxvYWRMYXp5Um91dGUocm91dGUsIHR5cGUsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMyLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwKSB7XG4gIGxldCByb3V0ZVRvVXBkYXRlID0gbWFuaWZlc3Rbcm91dGUuaWRdO1xuICBpbnZhcmlhbnQocm91dGVUb1VwZGF0ZSwgXCJObyByb3V0ZSBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhenlSb3V0ZVByb21pc2U6IHZvaWQgMCxcbiAgICAgIGxhenlIYW5kbGVyUHJvbWlzZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHJvdXRlLmxhenkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGxldCBjYWNoZWRQcm9taXNlID0gbGF6eVJvdXRlRnVuY3Rpb25DYWNoZS5nZXQocm91dGVUb1VwZGF0ZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhenlSb3V0ZVByb21pc2U6IGNhY2hlZFByb21pc2UsXG4gICAgICAgIGxhenlIYW5kbGVyUHJvbWlzZTogY2FjaGVkUHJvbWlzZVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGxhenlSb3V0ZVByb21pc2UyID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIHJvdXRlLmxhenkgPT09IFwiZnVuY3Rpb25cIixcbiAgICAgICAgXCJObyBsYXp5IHJvdXRlIGZ1bmN0aW9uIGZvdW5kXCJcbiAgICAgICk7XG4gICAgICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuICAgICAgbGV0IHJvdXRlVXBkYXRlcyA9IHt9O1xuICAgICAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgICAgIGxldCBsYXp5VmFsdWUgPSBsYXp5Um91dGVbbGF6eVJvdXRlUHJvcGVydHldO1xuICAgICAgICBpZiAobGF6eVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNVbnN1cHBvcnRlZCA9IGlzVW5zdXBwb3J0ZWRMYXp5Um91dGVGdW5jdGlvbktleShsYXp5Um91dGVQcm9wZXJ0eSk7XG4gICAgICAgIGxldCBzdGF0aWNSb3V0ZVZhbHVlID0gcm91dGVUb1VwZGF0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XG4gICAgICAgIGxldCBpc1N0YXRpY2FsbHlEZWZpbmVkID0gc3RhdGljUm91dGVWYWx1ZSAhPT0gdm9pZCAwICYmIC8vIFRoaXMgcHJvcGVydHkgaXNuJ3Qgc3RhdGljIHNpbmNlIGl0IHNob3VsZCBhbHdheXMgYmUgdXBkYXRlZCBiYXNlZFxuICAgICAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgICAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG4gICAgICAgIGlmIChpc1Vuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICFpc1Vuc3VwcG9ydGVkLFxuICAgICAgICAgICAgXCJSb3V0ZSBwcm9wZXJ0eSBcIiArIGxhenlSb3V0ZVByb3BlcnR5ICsgXCIgaXMgbm90IGEgc3VwcG9ydGVkIHByb3BlcnR5IHRvIGJlIHJldHVybmVkIGZyb20gYSBsYXp5IHJvdXRlIGZ1bmN0aW9uLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdGF0aWNhbGx5RGVmaW5lZCkge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAhaXNTdGF0aWNhbGx5RGVmaW5lZCxcbiAgICAgICAgICAgIGBSb3V0ZSBcIiR7cm91dGVUb1VwZGF0ZS5pZH1cIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIGRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIFRoZSBsYXp5IHJvdXRlIHByb3BlcnR5IFwiJHtsYXp5Um91dGVQcm9wZXJ0eX1cIiB3aWxsIGJlIGlnbm9yZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9IGxhenlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCByb3V0ZVVwZGF0ZXMpO1xuICAgICAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCB7XG4gICAgICAgIC8vIFRvIGtlZXAgdGhpbmdzIGZyYW1ld29yayBhZ25vc3RpYywgd2UgdXNlIHRoZSBwcm92aWRlZCBgbWFwUm91dGVQcm9wZXJ0aWVzYFxuICAgICAgICAvLyBmdW5jdGlvbiB0byBzZXQgdGhlIGZyYW1ld29yay1hd2FyZSBwcm9wZXJ0aWVzIChgZWxlbWVudGAvYGhhc0Vycm9yQm91bmRhcnlgKVxuICAgICAgICAvLyBzaW5jZSB0aGUgbG9naWMgd2lsbCBkaWZmZXIgYmV0d2VlbiBmcmFtZXdvcmtzLlxuICAgICAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlVG9VcGRhdGUpLFxuICAgICAgICBsYXp5OiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gICAgbGF6eVJvdXRlRnVuY3Rpb25DYWNoZS5zZXQocm91dGVUb1VwZGF0ZSwgbGF6eVJvdXRlUHJvbWlzZTIpO1xuICAgIGxhenlSb3V0ZVByb21pc2UyLmNhdGNoKCgpID0+IHtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGF6eVJvdXRlUHJvbWlzZTogbGF6eVJvdXRlUHJvbWlzZTIsXG4gICAgICBsYXp5SGFuZGxlclByb21pc2U6IGxhenlSb3V0ZVByb21pc2UyXG4gICAgfTtcbiAgfVxuICBsZXQgbGF6eUtleXMgPSBPYmplY3Qua2V5cyhyb3V0ZS5sYXp5KTtcbiAgbGV0IGxhenlQcm9wZXJ0eVByb21pc2VzID0gW107XG4gIGxldCBsYXp5SGFuZGxlclByb21pc2UgPSB2b2lkIDA7XG4gIGZvciAobGV0IGtleSBvZiBsYXp5S2V5cykge1xuICAgIGlmIChsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwICYmIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBwcm9taXNlID0gbG9hZExhenlSb3V0ZVByb3BlcnR5KHtcbiAgICAgIGtleSxcbiAgICAgIHJvdXRlLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IG1hcFJvdXRlUHJvcGVydGllczJcbiAgICB9KTtcbiAgICBpZiAocHJvbWlzZSkge1xuICAgICAgbGF6eVByb3BlcnR5UHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgIGlmIChrZXkgPT09IHR5cGUpIHtcbiAgICAgICAgbGF6eUhhbmRsZXJQcm9taXNlID0gcHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGxhenlSb3V0ZVByb21pc2UgPSBsYXp5UHJvcGVydHlQcm9taXNlcy5sZW5ndGggPiAwID8gUHJvbWlzZS5hbGwobGF6eVByb3BlcnR5UHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICB9KSA6IHZvaWQgMDtcbiAgbGF6eVJvdXRlUHJvbWlzZT8uY2F0Y2goKCkgPT4ge1xuICB9KTtcbiAgbGF6eUhhbmRsZXJQcm9taXNlPy5jYXRjaCgoKSA9PiB7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGxhenlSb3V0ZVByb21pc2UsXG4gICAgbGF6eUhhbmRsZXJQcm9taXNlXG4gIH07XG59XG5mdW5jdGlvbiBpc05vbk51bGxhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gbG9hZExhenlNaWRkbGV3YXJlRm9yTWF0Y2hlcyhtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzMikge1xuICBsZXQgcHJvbWlzZXMgPSBtYXRjaGVzLm1hcCgoeyByb3V0ZSB9KSA9PiB7XG4gICAgaWYgKHR5cGVvZiByb3V0ZS5sYXp5ICE9PSBcIm9iamVjdFwiIHx8ICFyb3V0ZS5sYXp5Lm1pZGRsZXdhcmUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsb2FkTGF6eVJvdXRlUHJvcGVydHkoe1xuICAgICAga2V5OiBcIm1pZGRsZXdhcmVcIixcbiAgICAgIHJvdXRlLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IG1hcFJvdXRlUHJvcGVydGllczJcbiAgICB9KTtcbiAgfSkuZmlsdGVyKGlzTm9uTnVsbGFibGUpO1xuICByZXR1cm4gcHJvbWlzZXMubGVuZ3RoID4gMCA/IFByb21pc2UuYWxsKHByb21pc2VzKSA6IHZvaWQgMDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHREYXRhU3RyYXRlZ3koYXJncykge1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IGFyZ3MubWF0Y2hlcy5maWx0ZXIoKG0pID0+IG0uc2hvdWxkTG9hZCk7XG4gIGxldCBrZXllZFJlc3VsdHMgPSB7fTtcbiAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChtYXRjaGVzVG9Mb2FkLm1hcCgobSkgPT4gbS5yZXNvbHZlKCkpKTtcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGkpID0+IHtcbiAgICBrZXllZFJlc3VsdHNbbWF0Y2hlc1RvTG9hZFtpXS5yb3V0ZS5pZF0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4ga2V5ZWRSZXN1bHRzO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdERhdGFTdHJhdGVneVdpdGhNaWRkbGV3YXJlKGFyZ3MpIHtcbiAgaWYgKCFhcmdzLm1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5taWRkbGV3YXJlKSkge1xuICAgIHJldHVybiBkZWZhdWx0RGF0YVN0cmF0ZWd5KGFyZ3MpO1xuICB9XG4gIHJldHVybiBydW5DbGllbnRNaWRkbGV3YXJlUGlwZWxpbmUoYXJncywgKCkgPT4gZGVmYXVsdERhdGFTdHJhdGVneShhcmdzKSk7XG59XG5mdW5jdGlvbiBydW5TZXJ2ZXJNaWRkbGV3YXJlUGlwZWxpbmUoYXJncywgaGFuZGxlciwgZXJyb3JIYW5kbGVyKSB7XG4gIHJldHVybiBydW5NaWRkbGV3YXJlUGlwZWxpbmUoXG4gICAgYXJncyxcbiAgICBoYW5kbGVyLFxuICAgIHByb2Nlc3NSZXN1bHQsXG4gICAgaXNSZXNwb25zZSxcbiAgICBlcnJvckhhbmRsZXJcbiAgKTtcbiAgZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQpIHtcbiAgICByZXR1cm4gaXNEYXRhV2l0aFJlc3BvbnNlSW5pdChyZXN1bHQpID8gZGF0YVdpdGhSZXNwb25zZUluaXRUb1Jlc3BvbnNlKHJlc3VsdCkgOiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJ1bkNsaWVudE1pZGRsZXdhcmVQaXBlbGluZShhcmdzLCBoYW5kbGVyKSB7XG4gIHJldHVybiBydW5NaWRkbGV3YXJlUGlwZWxpbmUoXG4gICAgYXJncyxcbiAgICBoYW5kbGVyLFxuICAgIChyKSA9PiByLFxuICAgIC8vIE5vIHBvc3QtcHJvY2Vzc2luZyBuZWVkZWQgb24gdGhlIGNsaWVudFxuICAgIGlzRGF0YVN0cmF0ZWd5UmVzdWx0cyxcbiAgICBlcnJvckhhbmRsZXJcbiAgKTtcbiAgZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGVycm9yLCByb3V0ZUlkLCBuZXh0UmVzdWx0KSB7XG4gICAgaWYgKG5leHRSZXN1bHQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV4dFJlc3VsdC52YWx1ZSwge1xuICAgICAgICAgIFtyb3V0ZUlkXTogeyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZXJyb3IgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHsgbWF0Y2hlcyB9ID0gYXJncztcbiAgICAgIGxldCBtYXhCb3VuZGFyeUlkeCA9IE1hdGgubWluKFxuICAgICAgICAvLyBUaHJvd2luZyByb3V0ZVxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCksXG4gICAgICAgICAgMFxuICAgICAgICApLFxuICAgICAgICAvLyBvciB0aGUgc2hhbGxvd2VzdCByb3V0ZSB0aGF0IG5lZWRzIHRvIGxvYWQgZGF0YVxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS51bnN0YWJsZV9zaG91bGRDYWxsSGFuZGxlcigpKSxcbiAgICAgICAgICAwXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBsZXQgYm91bmRhcnlSb3V0ZUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1ttYXhCb3VuZGFyeUlkeF0ucm91dGUuaWRcbiAgICAgICkucm91dGUuaWQ7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgW2JvdW5kYXJ5Um91dGVJZF06IHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGVycm9yIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcnVuTWlkZGxld2FyZVBpcGVsaW5lKGFyZ3MsIGhhbmRsZXIsIHByb2Nlc3NSZXN1bHQsIGlzUmVzdWx0LCBlcnJvckhhbmRsZXIpIHtcbiAgbGV0IHsgbWF0Y2hlcywgcmVxdWVzdCwgcGFyYW1zLCBjb250ZXh0IH0gPSBhcmdzO1xuICBsZXQgdHVwbGVzID0gbWF0Y2hlcy5mbGF0TWFwKFxuICAgIChtKSA9PiBtLnJvdXRlLm1pZGRsZXdhcmUgPyBtLnJvdXRlLm1pZGRsZXdhcmUubWFwKChmbikgPT4gW20ucm91dGUuaWQsIGZuXSkgOiBbXVxuICApO1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbFJvdXRlTWlkZGxld2FyZShcbiAgICB7IHJlcXVlc3QsIHBhcmFtcywgY29udGV4dCB9LFxuICAgIHR1cGxlcyxcbiAgICBoYW5kbGVyLFxuICAgIHByb2Nlc3NSZXN1bHQsXG4gICAgaXNSZXN1bHQsXG4gICAgZXJyb3JIYW5kbGVyXG4gICk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsUm91dGVNaWRkbGV3YXJlKGFyZ3MsIG1pZGRsZXdhcmVzLCBoYW5kbGVyLCBwcm9jZXNzUmVzdWx0LCBpc1Jlc3VsdCwgZXJyb3JIYW5kbGVyLCBpZHggPSAwKSB7XG4gIGxldCB7IHJlcXVlc3QgfSA9IGFyZ3M7XG4gIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uID8/IG5ldyBFcnJvcihgUmVxdWVzdCBhYm9ydGVkOiAke3JlcXVlc3QubWV0aG9kfSAke3JlcXVlc3QudXJsfWApO1xuICB9XG4gIGxldCB0dXBsZSA9IG1pZGRsZXdhcmVzW2lkeF07XG4gIGlmICghdHVwbGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcigpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGV0IFtyb3V0ZUlkLCBtaWRkbGV3YXJlXSA9IHR1cGxlO1xuICBsZXQgbmV4dFJlc3VsdDtcbiAgbGV0IG5leHQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKG5leHRSZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtYXkgb25seSBjYWxsIGBuZXh0KClgIG9uY2UgcGVyIG1pZGRsZXdhcmVcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbFJvdXRlTWlkZGxld2FyZShcbiAgICAgICAgYXJncyxcbiAgICAgICAgbWlkZGxld2FyZXMsXG4gICAgICAgIGhhbmRsZXIsXG4gICAgICAgIHByb2Nlc3NSZXN1bHQsXG4gICAgICAgIGlzUmVzdWx0LFxuICAgICAgICBlcnJvckhhbmRsZXIsXG4gICAgICAgIGlkeCArIDFcbiAgICAgICk7XG4gICAgICBuZXh0UmVzdWx0ID0geyB2YWx1ZTogcmVzdWx0IH07XG4gICAgICByZXR1cm4gbmV4dFJlc3VsdC52YWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbmV4dFJlc3VsdCA9IHsgdmFsdWU6IGF3YWl0IGVycm9ySGFuZGxlcihlcnJvciwgcm91dGVJZCwgbmV4dFJlc3VsdCkgfTtcbiAgICAgIHJldHVybiBuZXh0UmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfTtcbiAgdHJ5IHtcbiAgICBsZXQgdmFsdWUgPSBhd2FpdCBtaWRkbGV3YXJlKGFyZ3MsIG5leHQpO1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZSAhPSBudWxsID8gcHJvY2Vzc1Jlc3VsdCh2YWx1ZSkgOiB2b2lkIDA7XG4gICAgaWYgKGlzUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChuZXh0UmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ID8/IG5leHRSZXN1bHQudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRSZXN1bHQgPSB7IHZhbHVlOiBhd2FpdCBuZXh0KCkgfTtcbiAgICAgIHJldHVybiBuZXh0UmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBlcnJvckhhbmRsZXIoZXJyb3IsIHJvdXRlSWQsIG5leHRSZXN1bHQpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2hMYXp5UHJvbWlzZXMobWFwUm91dGVQcm9wZXJ0aWVzMiwgbWFuaWZlc3QsIHJlcXVlc3QsIG1hdGNoLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwKSB7XG4gIGxldCBsYXp5TWlkZGxld2FyZVByb21pc2UgPSBsb2FkTGF6eVJvdXRlUHJvcGVydHkoe1xuICAgIGtleTogXCJtaWRkbGV3YXJlXCIsXG4gICAgcm91dGU6IG1hdGNoLnJvdXRlLFxuICAgIG1hbmlmZXN0LFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogbWFwUm91dGVQcm9wZXJ0aWVzMlxuICB9KTtcbiAgbGV0IGxhenlSb3V0ZVByb21pc2VzID0gbG9hZExhenlSb3V0ZShcbiAgICBtYXRjaC5yb3V0ZSxcbiAgICBpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKSA/IFwiYWN0aW9uXCIgOiBcImxvYWRlclwiLFxuICAgIG1hbmlmZXN0LFxuICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcFxuICApO1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmU6IGxhenlNaWRkbGV3YXJlUHJvbWlzZSxcbiAgICByb3V0ZTogbGF6eVJvdXRlUHJvbWlzZXMubGF6eVJvdXRlUHJvbWlzZSxcbiAgICBoYW5kbGVyOiBsYXp5Um91dGVQcm9taXNlcy5sYXp5SGFuZGxlclByb21pc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERhdGFTdHJhdGVneU1hdGNoKG1hcFJvdXRlUHJvcGVydGllczIsIG1hbmlmZXN0LCByZXF1ZXN0LCBtYXRjaCwgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCwgc2NvcGVkQ29udGV4dCwgc2hvdWxkTG9hZCwgdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgPSBudWxsKSB7XG4gIGxldCBpc1VzaW5nTmV3QXBpID0gZmFsc2U7XG4gIGxldCBfbGF6eVByb21pc2VzID0gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2hMYXp5UHJvbWlzZXMoXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICBtYW5pZmVzdCxcbiAgICByZXF1ZXN0LFxuICAgIG1hdGNoLFxuICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXBcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tYXRjaCxcbiAgICBfbGF6eVByb21pc2VzLFxuICAgIHNob3VsZExvYWQsXG4gICAgdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MsXG4gICAgdW5zdGFibGVfc2hvdWxkQ2FsbEhhbmRsZXIoZGVmYXVsdFNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIGlzVXNpbmdOZXdBcGkgPSB0cnVlO1xuICAgICAgaWYgKCF1bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncykge1xuICAgICAgICByZXR1cm4gc2hvdWxkTG9hZDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFNob3VsZFJldmFsaWRhdGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCB7XG4gICAgICAgICAgLi4udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MsXG4gICAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihtYXRjaCwgdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MpO1xuICAgIH0sXG4gICAgcmVzb2x2ZShoYW5kbGVyT3ZlcnJpZGUpIHtcbiAgICAgIGxldCB7IGxhenksIGxvYWRlciwgbWlkZGxld2FyZSB9ID0gbWF0Y2gucm91dGU7XG4gICAgICBsZXQgY2FsbEhhbmRsZXIgPSBpc1VzaW5nTmV3QXBpIHx8IHNob3VsZExvYWQgfHwgaGFuZGxlck92ZXJyaWRlICYmICFpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKSAmJiAobGF6eSB8fCBsb2FkZXIpO1xuICAgICAgbGV0IGlzTWlkZGxld2FyZU9ubHlSb3V0ZSA9IG1pZGRsZXdhcmUgJiYgbWlkZGxld2FyZS5sZW5ndGggPiAwICYmICFsb2FkZXIgJiYgIWxhenk7XG4gICAgICBpZiAoY2FsbEhhbmRsZXIgJiYgIWlzTWlkZGxld2FyZU9ubHlSb3V0ZSkge1xuICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGxhenlIYW5kbGVyUHJvbWlzZTogX2xhenlQcm9taXNlcz8uaGFuZGxlcixcbiAgICAgICAgICBsYXp5Um91dGVQcm9taXNlOiBfbGF6eVByb21pc2VzPy5yb3V0ZSxcbiAgICAgICAgICBoYW5kbGVyT3ZlcnJpZGUsXG4gICAgICAgICAgc2NvcGVkQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCByZXN1bHQ6IHZvaWQgMCB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMobWFwUm91dGVQcm9wZXJ0aWVzMiwgbWFuaWZlc3QsIHJlcXVlc3QsIG1hdGNoZXMsIHRhcmdldE1hdGNoLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLCBzY29wZWRDb250ZXh0LCBzaG91bGRSZXZhbGlkYXRlQXJncyA9IG51bGwpIHtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKChtYXRjaCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5pZCAhPT0gdGFyZ2V0TWF0Y2gucm91dGUuaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1hdGNoLFxuICAgICAgICBzaG91bGRMb2FkOiBmYWxzZSxcbiAgICAgICAgdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3M6IHNob3VsZFJldmFsaWRhdGVBcmdzLFxuICAgICAgICB1bnN0YWJsZV9zaG91bGRDYWxsSGFuZGxlcjogKCkgPT4gZmFsc2UsXG4gICAgICAgIF9sYXp5UHJvbWlzZXM6IGdldERhdGFTdHJhdGVneU1hdGNoTGF6eVByb21pc2VzKFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwXG4gICAgICAgICksXG4gICAgICAgIHJlc29sdmU6ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQ6IHZvaWQgMCB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGdldERhdGFTdHJhdGVneU1hdGNoKFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICB0cnVlLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZUFyZ3NcbiAgICApO1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3lJbXBsKGRhdGFTdHJhdGVneUltcGwsIHJlcXVlc3QsIG1hdGNoZXMsIGZldGNoZXJLZXksIHNjb3BlZENvbnRleHQsIGlzU3RhdGljSGFuZGxlcikge1xuICBpZiAobWF0Y2hlcy5zb21lKChtKSA9PiBtLl9sYXp5UHJvbWlzZXM/Lm1pZGRsZXdhcmUpKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hlcy5tYXAoKG0pID0+IG0uX2xhenlQcm9taXNlcz8ubWlkZGxld2FyZSkpO1xuICB9XG4gIGxldCBkYXRhU3RyYXRlZ3lBcmdzID0ge1xuICAgIHJlcXVlc3QsXG4gICAgcGFyYW1zOiBtYXRjaGVzWzBdLnBhcmFtcyxcbiAgICBjb250ZXh0OiBzY29wZWRDb250ZXh0LFxuICAgIG1hdGNoZXNcbiAgfTtcbiAgbGV0IHJ1bkNsaWVudE1pZGRsZXdhcmUgPSBpc1N0YXRpY0hhbmRsZXIgPyAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IGNhbGwgYHJ1bkNsaWVudE1pZGRsZXdhcmUoKWAgZnJvbSBhIHN0YXRpYyBoYW5kbGVyIGBkYXRhU3RyYXRlZ3lgLiBNaWRkbGV3YXJlIGlzIHJ1biBvdXRzaWRlIG9mIGBkYXRhU3RyYXRlZ3lgIGR1cmluZyBTU1IgaW4gb3JkZXIgdG8gYnViYmxlIHVwIHRoZSBSZXNwb25zZS4gIFlvdSBjYW4gZW5hYmxlIG1pZGRsZXdhcmUgdmlhIHRoZSBgcmVzcG9uZGAgQVBJIGluIGBxdWVyeWAvYHF1ZXJ5Um91dGVgXCJcbiAgICApO1xuICB9IDogKGNiKSA9PiB7XG4gICAgbGV0IHR5cGVkRGF0YVN0cmF0ZWd5QXJncyA9IGRhdGFTdHJhdGVneUFyZ3M7XG4gICAgcmV0dXJuIHJ1bkNsaWVudE1pZGRsZXdhcmVQaXBlbGluZSh0eXBlZERhdGFTdHJhdGVneUFyZ3MsICgpID0+IHtcbiAgICAgIHJldHVybiBjYih7XG4gICAgICAgIC4uLnR5cGVkRGF0YVN0cmF0ZWd5QXJncyxcbiAgICAgICAgZmV0Y2hlcktleSxcbiAgICAgICAgcnVuQ2xpZW50TWlkZGxld2FyZTogKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2Fubm90IGNhbGwgYHJ1bkNsaWVudE1pZGRsZXdhcmUoKWAgZnJvbSB3aXRoaW4gYW4gYHJ1bkNsaWVudE1pZGRsZXdhcmVgIGhhbmRsZXJcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBsZXQgcmVzdWx0cyA9IGF3YWl0IGRhdGFTdHJhdGVneUltcGwoe1xuICAgIC4uLmRhdGFTdHJhdGVneUFyZ3MsXG4gICAgZmV0Y2hlcktleSxcbiAgICBydW5DbGllbnRNaWRkbGV3YXJlXG4gIH0pO1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbWF0Y2hlcy5mbGF0TWFwKChtKSA9PiBbXG4gICAgICAgIG0uX2xhenlQcm9taXNlcz8uaGFuZGxlcixcbiAgICAgICAgbS5fbGF6eVByb21pc2VzPy5yb3V0ZVxuICAgICAgXSlcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyT3JBY3Rpb24oe1xuICByZXF1ZXN0LFxuICBtYXRjaCxcbiAgbGF6eUhhbmRsZXJQcm9taXNlLFxuICBsYXp5Um91dGVQcm9taXNlLFxuICBoYW5kbGVyT3ZlcnJpZGUsXG4gIHNjb3BlZENvbnRleHRcbn0pIHtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IG9uUmVqZWN0O1xuICBsZXQgaXNBY3Rpb24gPSBpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKTtcbiAgbGV0IHR5cGUgPSBpc0FjdGlvbiA/IFwiYWN0aW9uXCIgOiBcImxvYWRlclwiO1xuICBsZXQgcnVuSGFuZGxlciA9IChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IHJlamVjdDtcbiAgICBsZXQgYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHIpID0+IHJlamVjdCA9IHIpO1xuICAgIG9uUmVqZWN0ID0gKCkgPT4gcmVqZWN0KCk7XG4gICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICBsZXQgYWN0dWFsSGFuZGxlciA9IChjdHgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgWW91IGNhbm5vdCBjYWxsIHRoZSBoYW5kbGVyIGZvciBhIHJvdXRlIHdoaWNoIGRlZmluZXMgYSBib29sZWFuIFwiJHt0eXBlfVwiIFtyb3V0ZUlkOiAke21hdGNoLnJvdXRlLmlkfV1gXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZXIoXG4gICAgICAgIHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgICAgIGNvbnRleHQ6IHNjb3BlZENvbnRleHRcbiAgICAgICAgfSxcbiAgICAgICAgLi4uY3R4ICE9PSB2b2lkIDAgPyBbY3R4XSA6IFtdXG4gICAgICApO1xuICAgIH07XG4gICAgbGV0IGhhbmRsZXJQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB2YWwgPSBhd2FpdCAoaGFuZGxlck92ZXJyaWRlID8gaGFuZGxlck92ZXJyaWRlKChjdHgpID0+IGFjdHVhbEhhbmRsZXIoY3R4KSkgOiBhY3R1YWxIYW5kbGVyKCkpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0OiB2YWwgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGUgfTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2hhbmRsZXJQcm9taXNlLCBhYm9ydFByb21pc2VdKTtcbiAgfTtcbiAgdHJ5IHtcbiAgICBsZXQgaGFuZGxlciA9IGlzQWN0aW9uID8gbWF0Y2gucm91dGUuYWN0aW9uIDogbWF0Y2gucm91dGUubG9hZGVyO1xuICAgIGlmIChsYXp5SGFuZGxlclByb21pc2UgfHwgbGF6eVJvdXRlUHJvbWlzZSkge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgbGV0IFt2YWx1ZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgdGhyb3dzLCBkb24ndCBsZXQgaXQgaW1tZWRpYXRlbHkgYnViYmxlIG91dCxcbiAgICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgICAgLy8gcm91dGUgaGFzIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlcikuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXJFcnJvciA9IGU7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLy8gRW5zdXJlIGFsbCBsYXp5IHJvdXRlIHByb21pc2VzIGFyZSByZXNvbHZlZCBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgIGxhenlIYW5kbGVyUHJvbWlzZSxcbiAgICAgICAgICBsYXp5Um91dGVQcm9taXNlXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoaGFuZGxlckVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBoYW5kbGVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBsYXp5SGFuZGxlclByb21pc2U7XG4gICAgICAgIGxldCBoYW5kbGVyMiA9IGlzQWN0aW9uID8gbWF0Y2gucm91dGUuYWN0aW9uIDogbWF0Y2gucm91dGUubG9hZGVyO1xuICAgICAgICBpZiAoaGFuZGxlcjIpIHtcbiAgICAgICAgICBbcmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtydW5IYW5kbGVyKGhhbmRsZXIyKSwgbGF6eVJvdXRlUHJvbWlzZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCByZXN1bHQ6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIHJlc3VsdDogZSB9O1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VCb2R5KHJlc3BvbnNlKSB7XG4gIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keSA9PSBudWxsID8gbnVsbCA6IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdChkYXRhU3RyYXRlZ3lSZXN1bHQpIHtcbiAgbGV0IHsgcmVzdWx0LCB0eXBlIH0gPSBkYXRhU3RyYXRlZ3lSZXN1bHQ7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICBsZXQgZGF0YTI7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEyID0gYXdhaXQgcGFyc2VSZXNwb25zZUJvZHkocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIGVycm9yOiBlIH07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgZGF0YTIpLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sXG4gICAgICBkYXRhOiBkYXRhMixcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLykge1xuICAgIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChyZXN1bHQuZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXN1bHQuaW5pdD8uc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnM6IHJlc3VsdC5pbml0Py5oZWFkZXJzID8gbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycykgOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICAgICAgICByZXN1bHQuaW5pdD8uc3RhdHVzIHx8IDUwMCxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgcmVzdWx0LmRhdGFcbiAgICAgICAgKSxcbiAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdC5zdGF0dXMgOiB2b2lkIDAsXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5pbml0Py5oZWFkZXJzID8gbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycykgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICBlcnJvcjogcmVzdWx0LFxuICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdC5zdGF0dXMgOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhXCIgLyogZGF0YSAqLyxcbiAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LmluaXQ/LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5pbml0Py5oZWFkZXJzID8gbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycykgOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sIGRhdGE6IHJlc3VsdCB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSwgcmVxdWVzdCwgcm91dGVJZCwgbWF0Y2hlcywgYmFzZW5hbWUpIHtcbiAgbGV0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgaW52YXJpYW50KFxuICAgIGxvY2F0aW9uLFxuICAgIFwiUmVkaXJlY3RzIHJldHVybmVkL3Rocm93biBmcm9tIGxvYWRlcnMvYWN0aW9ucyBtdXN0IGhhdmUgYSBMb2NhdGlvbiBoZWFkZXJcIlxuICApO1xuICBpZiAoIWlzQWJzb2x1dGVVcmwobG9jYXRpb24pKSB7XG4gICAgbGV0IHRyaW1tZWRNYXRjaGVzID0gbWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxXG4gICAgKTtcbiAgICBsb2NhdGlvbiA9IG5vcm1hbGl6ZVRvKFxuICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICB0cmltbWVkTWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgbG9jYXRpb24pO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24sIGN1cnJlbnRVcmwsIGJhc2VuYW1lKSB7XG4gIGlmIChpc0Fic29sdXRlVXJsKGxvY2F0aW9uKSkge1xuICAgIGxldCBub3JtYWxpemVkTG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICBsZXQgdXJsID0gbm9ybWFsaXplZExvY2F0aW9uLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIG5vcm1hbGl6ZWRMb2NhdGlvbikgOiBuZXcgVVJMKG5vcm1hbGl6ZWRMb2NhdGlvbik7XG4gICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgIGlmICh1cmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBpc1NhbWVCYXNlbmFtZSkge1xuICAgICAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaGlzdG9yeSwgbG9jYXRpb24sIHNpZ25hbCwgc3VibWlzc2lvbikge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdCA9IHsgc2lnbmFsIH07XG4gIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1FbmNUeXBlIH0gPSBzdWJtaXNzaW9uO1xuICAgIGluaXQubWV0aG9kID0gZm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogZm9ybUVuY1R5cGUgfSk7XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLnRleHQ7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiAmJiBzdWJtaXNzaW9uLmZvcm1EYXRhKSB7XG4gICAgICBpbml0LmJvZHkgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhzdWJtaXNzaW9uLmZvcm1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSkge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcykge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCBpc1N0YXRpY0hhbmRsZXIgPSBmYWxzZSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPSBmYWxzZSkge1xuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuICBsZXQgZXJyb3JzID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzID0ge307XG4gIGxldCBwZW5kaW5nRXJyb3IgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogdm9pZCAwO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCEobWF0Y2gucm91dGUuaWQgaW4gcmVzdWx0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaWRdO1xuICAgIGludmFyaWFudChcbiAgICAgICFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksXG4gICAgICBcIkNhbm5vdCBoYW5kbGUgcmVkaXJlY3QgcmVzdWx0cyBpbiBwcm9jZXNzTG9hZGVyRGF0YVwiXG4gICAgKTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICBpZiAocGVuZGluZ0Vycm9yICE9PSB2b2lkIDApIHtcbiAgICAgICAgZXJyb3IgPSBwZW5kaW5nRXJyb3I7XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcbiAgICAgIGlmIChza2lwTG9hZGVyRXJyb3JCdWJibGluZykge1xuICAgICAgICBlcnJvcnNbaWRdID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgaWQpO1xuICAgICAgICBpZiAoZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdID09IG51bGwpIHtcbiAgICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1N0YXRpY0hhbmRsZXIpIHtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSBSZXNldExvYWRlckRhdGFTeW1ib2w7XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlICYmIHJlc3VsdC5zdGF0dXNDb2RlICE9PSAyMDAgJiYgIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IHJlc3VsdC5zdGF0dXNDb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKHBlbmRpbmdFcnJvciAhPT0gdm9pZCAwICYmIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBlcnJvcnMgPSB7IFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0Vycm9yIH07XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHRbMl0pIHtcbiAgICAgIGxvYWRlckRhdGFbcGVuZGluZ0FjdGlvblJlc3VsdFsyXV0gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnMsXG4gICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSB8fCAyMDAsXG4gICAgbG9hZGVySGVhZGVyc1xuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc0xvYWRlckRhdGEoc3RhdGUsIG1hdGNoZXMsIHJlc3VsdHMsIHBlbmRpbmdBY3Rpb25SZXN1bHQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cykge1xuICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgbWF0Y2hlcyxcbiAgICByZXN1bHRzLFxuICAgIHBlbmRpbmdBY3Rpb25SZXN1bHRcbiAgKTtcbiAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZmlsdGVyKChmKSA9PiAhZi5tYXRjaGVzIHx8IGYubWF0Y2hlcy5zb21lKChtKSA9PiBtLnNob3VsZExvYWQpKS5mb3JFYWNoKChyZikgPT4ge1xuICAgIGxldCB7IGtleSwgbWF0Y2gsIGNvbnRyb2xsZXIgfSA9IHJmO1xuICAgIGlmIChjb250cm9sbGVyICYmIGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGZldGNoZXJSZXN1bHRzW2tleV07XG4gICAgaW52YXJpYW50KHJlc3VsdCwgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiKTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgbWF0Y2g/LnJvdXRlLmlkKTtcbiAgICAgIGlmICghKGVycm9ycyAmJiBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0pKSB7XG4gICAgICAgIGVycm9ycyA9IHtcbiAgICAgICAgICAuLi5lcnJvcnMsXG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgIH0gZWxzZSBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgbG9hZGVyRGF0YSwgZXJyb3JzIH07XG59XG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEobG9hZGVyRGF0YSwgbmV3TG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSB7XG4gIGxldCBtZXJnZWRMb2FkZXJEYXRhID0gT2JqZWN0LmVudHJpZXMobmV3TG9hZGVyRGF0YSkuZmlsdGVyKChbLCB2XSkgPT4gdiAhPT0gUmVzZXRMb2FkZXJEYXRhU3ltYm9sKS5yZWR1Y2UoKG1lcmdlZCwgW2ssIHZdKSA9PiB7XG4gICAgbWVyZ2VkW2tdID0gdjtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7XG4gIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBpZiAoIW5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpICYmIGxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG5mdW5jdGlvbiBnZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgaWYgKCFwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xuICAgIC8vIENsZWFyIG91dCBwcmlvciBhY3Rpb25EYXRhIG9uIGVycm9yc1xuICAgIGFjdGlvbkRhdGE6IHt9XG4gIH0gOiB7XG4gICAgYWN0aW9uRGF0YToge1xuICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGFcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIHJvdXRlSWQpIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWQgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDEpIDogWy4uLm1hdGNoZXNdO1xuICByZXR1cm4gZWxpZ2libGVNYXRjaGVzLnJldmVyc2UoKS5maW5kKChtKSA9PiBtLnJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUpIHx8IG1hdGNoZXNbMF07XG59XG5mdW5jdGlvbiBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlcykge1xuICBsZXQgcm91dGUgPSByb3V0ZXMubGVuZ3RoID09PSAxID8gcm91dGVzWzBdIDogcm91dGVzLmZpbmQoKHIpID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IGBfX3NoaW0tZXJyb3Itcm91dGVfX2BcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiBbXG4gICAgICB7XG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICAgIHJvdXRlXG4gICAgICB9XG4gICAgXSxcbiAgICByb3V0ZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihzdGF0dXMsIHtcbiAgcGF0aG5hbWUsXG4gIHJvdXRlSWQsXG4gIG1ldGhvZCxcbiAgdHlwZSxcbiAgbWVzc2FnZVxufSA9IHt9KSB7XG4gIGxldCBzdGF0dXNUZXh0ID0gXCJVbmtub3duIFNlcnZlciBFcnJvclwiO1xuICBsZXQgZXJyb3JNZXNzYWdlID0gXCJVbmtub3duIEByZW1peC1ydW4vcm91dGVyIGVycm9yXCI7XG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgWW91IG1hZGUgYSAke21ldGhvZH0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGRpZCBub3QgcHJvdmlkZSBhIFxcYGxvYWRlclxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW52YWxpZC1ib2R5XCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5hYmxlIHRvIGVuY29kZSBzdWJtaXNzaW9uIGJvZHlcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgbWF0Y2ggVVJMIFwiJHtwYXRobmFtZX1cImA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBgTm8gcm91dGUgbWF0Y2hlcyBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNSkge1xuICAgIHN0YXR1c1RleHQgPSBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiO1xuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYFlvdSBtYWRlIGEgJHttZXRob2QudG9VcHBlckNhc2UoKX0gcmVxdWVzdCB0byBcIiR7cGF0aG5hbWV9XCIgYnV0IGRpZCBub3QgcHJvdmlkZSBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHtyb3V0ZUlkfVwiLCBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFwiJHttZXRob2QudG9VcHBlckNhc2UoKX1cImA7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgc3RhdHVzIHx8IDUwMCxcbiAgICBzdGF0dXNUZXh0LFxuICAgIG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLFxuICAgIHRydWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGxldCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocmVzdWx0cyk7XG4gIGZvciAobGV0IGkgPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IFtrZXksIHJlc3VsdF0gPSBlbnRyaWVzW2ldO1xuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiB7IGtleSwgcmVzdWx0IH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aCh7IC4uLnBhcnNlZFBhdGgsIGhhc2g6IFwiXCIgfSk7XG59XG5mdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGEsIGIpIHtcbiAgaWYgKGEucGF0aG5hbWUgIT09IGIucGF0aG5hbWUgfHwgYS5zZWFyY2ggIT09IGIuc2VhcmNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhLmhhc2ggPT09IFwiXCIpIHtcbiAgICByZXR1cm4gYi5oYXNoICE9PSBcIlwiO1xuICB9IGVsc2UgaWYgKGEuaGFzaCA9PT0gYi5oYXNoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYi5oYXNoICE9PSBcIlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGF0YVdpdGhSZXNwb25zZUluaXRUb1Jlc3BvbnNlKGRhdGEyKSB7XG4gIHJldHVybiBSZXNwb25zZS5qc29uKGRhdGEyLmRhdGEsIGRhdGEyLmluaXQgPz8gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGFXaXRoUmVzcG9uc2VJbml0VG9FcnJvclJlc3BvbnNlKGRhdGEyKSB7XG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgZGF0YTIuaW5pdD8uc3RhdHVzID8/IDUwMCxcbiAgICBkYXRhMi5pbml0Py5zdGF0dXNUZXh0ID8/IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gICAgZGF0YTIuZGF0YVxuICApO1xufVxuZnVuY3Rpb24gaXNEYXRhU3RyYXRlZ3lSZXN1bHRzKHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuZW50cmllcyhyZXN1bHQpLmV2ZXJ5KFxuICAgIChba2V5LCB2YWx1ZV0pID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgaXNEYXRhU3RyYXRlZ3lSZXN1bHQodmFsdWUpXG4gICk7XG59XG5mdW5jdGlvbiBpc0RhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gcmVzdWx0ICYmIFwicmVzdWx0XCIgaW4gcmVzdWx0ICYmIChyZXN1bHQudHlwZSA9PT0gXCJkYXRhXCIgLyogZGF0YSAqLyB8fCByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKTtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlc3VsdC5yZXN1bHQuc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBcInJlZGlyZWN0XCIgLyogcmVkaXJlY3QgKi87XG59XG5mdW5jdGlvbiBpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCAmJiBcInR5cGVcIiBpbiB2YWx1ZSAmJiBcImRhdGFcIiBpbiB2YWx1ZSAmJiBcImluaXRcIiBpbiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIkRhdGFXaXRoUmVzcG9uc2VJbml0XCI7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0U3RhdHVzQ29kZShzdGF0dXNDb2RlKSB7XG4gIHJldHVybiByZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXNDb2RlKTtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQpIHtcbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSAmJiBpc1JlZGlyZWN0U3RhdHVzQ29kZShyZXN1bHQuc3RhdHVzKSAmJiByZXN1bHQuaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiB2YWxpZFJlcXVlc3RNZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBpc011dGF0aW9uTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRNdXRhdGlvbk1ldGhvZHMuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2gpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSB7XG4gIGxldCBzZWFyY2ggPSB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb24pLnNlYXJjaCA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgaWYgKG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCAmJiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoIHx8IFwiXCIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKG5hdmlnYXRpb24pIHtcbiAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIHRleHQsIGZvcm1EYXRhLCBqc29uIH0gPSBuYXZpZ2F0aW9uO1xuICBpZiAoIWZvcm1NZXRob2QgfHwgIWZvcm1BY3Rpb24gfHwgIWZvcm1FbmNUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmb3JtRGF0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoanNvbiAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbixcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9IGVsc2Uge1xuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gICAgICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBsb2NhdGlvbixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgfTtcbiAgcmV0dXJuIG5hdmlnYXRpb247XG59XG5mdW5jdGlvbiBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBkYXRhMikge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICAgIGRhdGE6IGRhdGEyXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgICAgIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbjogdm9pZCAwLFxuICAgICAgdGV4dDogdm9pZCAwLFxuICAgICAgZGF0YTogZGF0YTJcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIGdldERvbmVGZXRjaGVyKGRhdGEyKSB7XG4gIGxldCBmZXRjaGVyID0ge1xuICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICBqc29uOiB2b2lkIDAsXG4gICAgdGV4dDogdm9pZCAwLFxuICAgIGRhdGE6IGRhdGEyXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICB0cnkge1xuICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVlcbiAgICApO1xuICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICBsZXQganNvbiA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbiB8fCB7fSkpIHtcbiAgICAgICAgaWYgKHYgJiYgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zLnNldChrLCBuZXcgU2V0KHYgfHwgW10pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5mdW5jdGlvbiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKF93aW5kb3csIHRyYW5zaXRpb25zKSB7XG4gIGlmICh0cmFuc2l0aW9ucy5zaXplID4gMCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHRyYW5zaXRpb25zKSB7XG4gICAgICBqc29uW2tdID0gWy4uLnZdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBgRmFpbGVkIHRvIHNhdmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlICgke2Vycm9yfSkuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgICAgcmVzKHZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gICAgcmVqZWN0ID0gYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICByZWooZXJyb3IpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlc29sdmUsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIGxpYi9jb250ZXh0LnRzXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbnZhciBEYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5EYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xudmFyIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRGF0YVJvdXRlclN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclN0YXRlXCI7XG52YXIgUlNDUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuZnVuY3Rpb24gdXNlSXNSU0NSb3V0ZXJDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSU0NSb3V0ZXJDb250ZXh0KTtcbn1cbnZhciBWaWV3VHJhbnNpdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxufSk7XG5WaWV3VHJhbnNpdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlZpZXdUcmFuc2l0aW9uXCI7XG52YXIgRmV0Y2hlcnNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChcbiAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuKTtcbkZldGNoZXJzQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRmV0Y2hlcnNcIjtcbnZhciBBd2FpdENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuQXdhaXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBd2FpdFwiO1xudmFyIEF3YWl0Q29udGV4dFByb3ZpZGVyID0gKHByb3BzKSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwgcHJvcHMpO1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChcbiAgbnVsbFxuKTtcbk5hdmlnYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJOYXZpZ2F0aW9uXCI7XG52YXIgTG9jYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChcbiAgbnVsbFxuKTtcbkxvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbnZhciBSb3V0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXSxcbiAgaXNEYXRhUm91dGU6IGZhbHNlXG59KTtcblJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbnZhciBSb3V0ZUVycm9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5Sb3V0ZUVycm9yQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVFcnJvclwiO1xudmFyIEVOQUJMRV9ERVZfV0FSTklOR1MgPSB0cnVlO1xuXG4vLyBsaWIvaG9va3MudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VIcmVmKHRvLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0Mi51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgaGFzaCwgcGF0aG5hbWUsIHNlYXJjaCB9ID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0pO1xuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7IHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0pO1xufVxuZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QyLnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuZnVuY3Rpb24gdXNlTG9jYXRpb24oKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKSB7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBwYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aChwYXR0ZXJuLCBkZWNvZGVQYXRoKHBhdGhuYW1lKSksXG4gICAgW3BhdGhuYW1lLCBwYXR0ZXJuXVxuICApO1xufVxudmFyIG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiB5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5gO1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjYikge1xuICBsZXQgaXNTdGF0aWMgPSBSZWFjdDIudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgUmVhY3QyLnVzZUxheW91dEVmZmVjdChjYik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKCkge1xuICBsZXQgeyBpc0RhdGFSb3V0ZSB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgcmV0dXJuIGlzRGF0YVJvdXRlID8gdXNlTmF2aWdhdGVTdGFibGUoKSA6IHVzZU5hdmlnYXRlVW5zdGFibGUoKTtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlVW5zdGFibGUoKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0Mi51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcykpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QyLnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAodG8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICAgIG9wdGlvbnMucmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICAgICApO1xuICAgICAgaWYgKGRhdGFSb3V0ZXJDb250ZXh0ID09IG51bGwgJiYgYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgICAgfVxuICAgICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9wdGlvbnMuc3RhdGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfSxcbiAgICBbXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHJvdXRlUGF0aG5hbWVzSnNvbixcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICBkYXRhUm91dGVyQ29udGV4dFxuICAgIF1cbiAgKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxudmFyIE91dGxldENvbnRleHQgPSBSZWFjdDIuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZU91dGxldENvbnRleHQoKSB7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0KSB7XG4gIGxldCBvdXRsZXQgPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IG91dGxldCAmJiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoT3V0bGV0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBvdXRsZXQpLFxuICAgIFtvdXRsZXQsIGNvbnRleHRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG59XG5mdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSk7XG4gIHJldHVybiBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiByZXNvbHZlVG8oXG4gICAgICB0byxcbiAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUsXG4gICAgICByZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgICApLFxuICAgIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnKSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcpO1xufVxuZnVuY3Rpb24gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBkYXRhUm91dGVyU3RhdGUsIHVuc3RhYmxlX29uRXJyb3IsIGZ1dHVyZSkge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VSb3V0ZXMoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgbmF2aWdhdG9yIH0gPSBSZWFjdDIudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IG1hdGNoZXM6IHBhcmVudE1hdGNoZXMgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgIGxldCBwYXJlbnRQYXRoID0gcGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCB8fCBcIlwiO1xuICAgIHdhcm5pbmdPbmNlKFxuICAgICAgcGFyZW50UGF0aG5hbWUsXG4gICAgICAhcGFyZW50Um91dGUgfHwgcGFyZW50UGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGFyZW50UGF0aC5lbmRzV2l0aChcIio/XCIpLFxuICAgICAgYFlvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgXFxgdXNlUm91dGVzKClcXGApIGF0IFwiJHtwYXJlbnRQYXRobmFtZX1cIiAodW5kZXIgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+KSBidXQgdGhlIHBhcmVudCByb3V0ZSBwYXRoIGhhcyBubyB0cmFpbGluZyBcIipcIi4gVGhpcyBtZWFucyBpZiB5b3UgbmF2aWdhdGUgZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgcm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxuXG5QbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+IHRvIDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogYCR7cGFyZW50UGF0aH0vKmB9XCI+LmBcbiAgICApO1xuICB9XG4gIGxldCBsb2NhdGlvbkZyb21Db250ZXh0ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IGxvY2F0aW9uO1xuICBpZiAobG9jYXRpb25BcmcpIHtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fCBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZT8uc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpLFxuICAgICAgYFdoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgXFxgPFJvdXRlcyBsb2NhdGlvbj5cXGAgb3IgXFxgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pXFxgLCB0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBieSBhbGwgcGFyZW50IHJvdXRlcy4gVGhlIGN1cnJlbnQgcGF0aG5hbWUgYmFzZSBpcyBcIiR7cGFyZW50UGF0aG5hbWVCYXNlfVwiIGJ1dCBwYXRobmFtZSBcIiR7cGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWV9XCIgd2FzIGdpdmVuIGluIHRoZSBcXGBsb2NhdGlvblxcYCBwcm9wLmBcbiAgICApO1xuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG4gIGxldCBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiO1xuICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgaWYgKHBhcmVudFBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICBsZXQgcGFyZW50U2VnbWVudHMgPSBwYXJlbnRQYXRobmFtZUJhc2UucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBsZXQgc2VnbWVudHMgPSBwYXRobmFtZS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gXCIvXCIgKyBzZWdtZW50cy5zbGljZShwYXJlbnRTZWdtZW50cy5sZW5ndGgpLmpvaW4oXCIvXCIpO1xuICB9XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7IHBhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSB9KTtcbiAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgcGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLFxuICAgICAgYE5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgYFxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIG1hdGNoZXMgPT0gbnVsbCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdm9pZCAwIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5Db21wb25lbnQgIT09IHZvaWQgMCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUubGF6eSAhPT0gdm9pZCAwLFxuICAgICAgYE1hdGNoZWQgbGVhZiByb3V0ZSBhdCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGRvZXMgbm90IGhhdmUgYW4gZWxlbWVudCBvciBDb21wb25lbnQuIFRoaXMgbWVhbnMgaXQgd2lsbCByZW5kZXIgYW4gPE91dGxldCAvPiB3aXRoIGEgbnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcImVtcHR5XCIgcGFnZS5gXG4gICAgKTtcbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gX3JlbmRlck1hdGNoZXMoXG4gICAgbWF0Y2hlcyAmJiBtYXRjaGVzLm1hcChcbiAgICAgIChtYXRjaCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICAgICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW1xuICAgICAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAgICAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlcy5cbiAgICAgICAgICAvLyBQcmUtZW5jb2RlIGA/YCBhbmQgYCNgIGFoZWFkIG9mIGBlbmNvZGVMb2NhdGlvbmAgYmVjYXVzZSBpdCB1c2VzXG4gICAgICAgICAgLy8gYG5ldyBVUkwoKWAgaW50ZXJuYWxseSBhbmQgd2UgbmVlZCB0byBwcmV2ZW50IGl0IGZyb20gdHJlYXRpbmdcbiAgICAgICAgICAvLyB0aGVtIGFzIHNlcGFyYXRvcnNcbiAgICAgICAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24oXG4gICAgICAgICAgICBtYXRjaC5wYXRobmFtZS5yZXBsYWNlKC9cXD8vZywgXCIlM0ZcIikucmVwbGFjZSgvIy9nLCBcIiUyM1wiKVxuICAgICAgICAgICkucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZVxuICAgICAgICBdKSxcbiAgICAgICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogam9pblBhdGhzKFtcbiAgICAgICAgICBwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgICAgICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICAgICAgICAvLyBQcmUtZW5jb2RlIGA/YCBhbmQgYCNgIGFoZWFkIG9mIGBlbmNvZGVMb2NhdGlvbmAgYmVjYXVzZSBpdCB1c2VzXG4gICAgICAgICAgLy8gYG5ldyBVUkwoKWAgaW50ZXJuYWxseSBhbmQgd2UgbmVlZCB0byBwcmV2ZW50IGl0IGZyb20gdHJlYXRpbmdcbiAgICAgICAgICAvLyB0aGVtIGFzIHNlcGFyYXRvcnNcbiAgICAgICAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24oXG4gICAgICAgICAgICBtYXRjaC5wYXRobmFtZUJhc2UucmVwbGFjZSgvXFw/L2csIFwiJTNGXCIpLnJlcGxhY2UoLyMvZywgXCIlMjNcIilcbiAgICAgICAgICApLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlXG4gICAgICAgIF0pXG4gICAgICB9KVxuICAgICksXG4gICAgcGFyZW50TWF0Y2hlcyxcbiAgICBkYXRhUm91dGVyU3RhdGUsXG4gICAgdW5zdGFibGVfb25FcnJvcixcbiAgICBmdXR1cmVcbiAgKTtcbiAgaWYgKGxvY2F0aW9uQXJnICYmIHJlbmRlcmVkTWF0Y2hlcykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBcIi9cIixcbiAgICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGtleTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAuLi5sb2NhdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF2aWdhdGlvblR5cGU6IFwiUE9QXCIgLyogUG9wICovXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXJlZE1hdGNoZXNcbiAgICApO1xuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5mdW5jdGlvbiBEZWZhdWx0RXJyb3JDb21wb25lbnQoKSB7XG4gIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgbGV0IG1lc3NhZ2UgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBgJHtlcnJvci5zdGF0dXN9ICR7ZXJyb3Iuc3RhdHVzVGV4dH1gIDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gIGxldCBzdGFjayA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IG51bGw7XG4gIGxldCBsaWdodGdyZXkgPSBcInJnYmEoMjAwLDIwMCwyMDAsIDAuNSlcIjtcbiAgbGV0IHByZVN0eWxlcyA9IHsgcGFkZGluZzogXCIwLjVyZW1cIiwgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXkgfTtcbiAgbGV0IGNvZGVTdHlsZXMgPSB7IHBhZGRpbmc6IFwiMnB4IDRweFwiLCBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleSB9O1xuICBsZXQgZGV2SW5mbyA9IG51bGw7XG4gIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiRXJyb3IgaGFuZGxlZCBieSBSZWFjdCBSb3V0ZXIgZGVmYXVsdCBFcnJvckJvdW5kYXJ5OlwiLFxuICAgICAgZXJyb3JcbiAgICApO1xuICAgIGRldkluZm8gPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUmVhY3QyLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiXFx1ezFGNEJGfSBIZXkgZGV2ZWxvcGVyIFxcdXsxRjQ0Qn1cIiksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMgYnkgcHJvdmlkaW5nIHlvdXIgb3duIFwiLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHsgc3R5bGU6IGNvZGVTdHlsZXMgfSwgXCJFcnJvckJvdW5kYXJ5XCIpLCBcIiBvclwiLCBcIiBcIiwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7IHN0eWxlOiBjb2RlU3R5bGVzIH0sIFwiZXJyb3JFbGVtZW50XCIpLCBcIiBwcm9wIG9uIHlvdXIgcm91dGUuXCIpKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJVbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yIVwiKSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiaDNcIiwgeyBzdHlsZTogeyBmb250U3R5bGU6IFwiaXRhbGljXCIgfSB9LCBtZXNzYWdlKSwgc3RhY2sgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBzdHlsZTogcHJlU3R5bGVzIH0sIHN0YWNrKSA6IG51bGwsIGRldkluZm8pO1xufVxudmFyIGRlZmF1bHRFcnJvckVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVycm9yQ29tcG9uZW50LCBudWxsKTtcbnZhciBSZW5kZXJFcnJvckJvdW5kYXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDIuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uLFxuICAgICAgZXJyb3I6IHByb3BzLmVycm9yXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uICE9PSBcImlkbGVcIiAmJiBwcm9wcy5yZXZhbGlkYXRpb24gPT09IFwiaWRsZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgIT09IHZvaWQgMCA/IHByb3BzLmVycm9yIDogc3RhdGUuZXJyb3IsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb25cbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBpZiAodGhpcy5wcm9wcy51bnN0YWJsZV9vbkVycm9yKSB7XG4gICAgICB0aGlzLnByb3BzLnVuc3RhYmxlX29uRXJyb3IoZXJyb3IsIGVycm9ySW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiUmVhY3QgUm91dGVyIGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgICAgZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciAhPT0gdm9pZCAwID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5wcm9wcy5yb3V0ZUNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgUm91dGVFcnJvckNvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jb21wb25lbnRcbiAgICAgIH1cbiAgICApKSA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn07XG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKHsgcm91dGVDb250ZXh0LCBtYXRjaCwgY2hpbGRyZW4gfSkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGlmIChkYXRhUm91dGVyQ29udGV4dCAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dCAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpKSB7XG4gICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByb3V0ZUNvbnRleHQgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMobWF0Y2hlcywgcGFyZW50TWF0Y2hlcyA9IFtdLCBkYXRhUm91dGVyU3RhdGUgPSBudWxsLCB1bnN0YWJsZV9vbkVycm9yID0gbnVsbCwgZnV0dXJlID0gbnVsbCkge1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgaWYgKCFkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlLmVycm9ycykge1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzO1xuICAgIH0gZWxzZSBpZiAocGFyZW50TWF0Y2hlcy5sZW5ndGggPT09IDAgJiYgIWRhdGFSb3V0ZXJTdGF0ZS5pbml0aWFsaXplZCAmJiBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlcztcbiAgbGV0IGVycm9ycyA9IGRhdGFSb3V0ZXJTdGF0ZT8uZXJyb3JzO1xuICBpZiAoZXJyb3JzICE9IG51bGwpIHtcbiAgICBsZXQgZXJyb3JJbmRleCA9IHJlbmRlcmVkTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5pZCAmJiBlcnJvcnM/LlttLnJvdXRlLmlkXSAhPT0gdm9pZCAwXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBlcnJvckluZGV4ID49IDAsXG4gICAgICBgQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyByb3V0ZSBmb3IgZXJyb3JzIG9uIHJvdXRlIElEczogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgZXJyb3JzXG4gICAgICApLmpvaW4oXCIsXCIpfWBcbiAgICApO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSlcbiAgICApO1xuICB9XG4gIGxldCByZW5kZXJGYWxsYmFjayA9IGZhbHNlO1xuICBsZXQgZmFsbGJhY2tJbmRleCA9IC0xO1xuICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtYXRjaCA9IHJlbmRlcmVkTWF0Y2hlc1tpXTtcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xuICAgICAgICBmYWxsYmFja0luZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCkge1xuICAgICAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnM6IGVycm9yczIgfSA9IGRhdGFSb3V0ZXJTdGF0ZTtcbiAgICAgICAgbGV0IG5lZWRzVG9SdW5Mb2FkZXIgPSBtYXRjaC5yb3V0ZS5sb2FkZXIgJiYgIWxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkobWF0Y2gucm91dGUuaWQpICYmICghZXJyb3JzMiB8fCBlcnJvcnMyW21hdGNoLnJvdXRlLmlkXSA9PT0gdm9pZCAwKTtcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbmVlZHNUb1J1bkxvYWRlcikge1xuICAgICAgICAgIHJlbmRlckZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgZmFsbGJhY2tJbmRleCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSBbcmVuZGVyZWRNYXRjaGVzWzBdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodChcbiAgICAob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIGxldCBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgIGxldCBlcnJvckVsZW1lbnQgPSBudWxsO1xuICAgICAgbGV0IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgICAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSkge1xuICAgICAgICBlcnJvciA9IGVycm9ycyAmJiBtYXRjaC5yb3V0ZS5pZCA/IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICAgIGVycm9yRWxlbWVudCA9IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBkZWZhdWx0RXJyb3JFbGVtZW50O1xuICAgICAgICBpZiAocmVuZGVyRmFsbGJhY2spIHtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA8IDAgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHdhcm5pbmdPbmNlKFxuICAgICAgICAgICAgICBcInJvdXRlLWZhbGxiYWNrXCIsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBcIk5vIGBIeWRyYXRlRmFsbGJhY2tgIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVuZGVyIGR1cmluZyBpbml0aWFsIGh5ZHJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCB8fCBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG1hdGNoZXMyID0gcGFyZW50TWF0Y2hlcy5jb25jYXQocmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpO1xuICAgICAgbGV0IGdldENoaWxkcmVuID0gKCkgPT4ge1xuICAgICAgICBsZXQgY2hpbGRyZW47XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNoaWxkcmVuID0gZXJyb3JFbGVtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjaykge1xuICAgICAgICAgIGNoaWxkcmVuID0gaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5Db21wb25lbnQpIHtcbiAgICAgICAgICBjaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChtYXRjaC5yb3V0ZS5Db21wb25lbnQsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgICBjaGlsZHJlbiA9IG1hdGNoLnJvdXRlLmVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBSZW5kZXJlZFJvdXRlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgcm91dGVDb250ZXh0OiB7XG4gICAgICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hlczIsXG4gICAgICAgICAgICAgIGlzRGF0YVJvdXRlOiBkYXRhUm91dGVyU3RhdGUgIT0gbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBkYXRhUm91dGVyU3RhdGUgJiYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkgfHwgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUmVuZGVyRXJyb3JCb3VuZGFyeSxcbiAgICAgICAge1xuICAgICAgICAgIGxvY2F0aW9uOiBkYXRhUm91dGVyU3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgcmV2YWxpZGF0aW9uOiBkYXRhUm91dGVyU3RhdGUucmV2YWxpZGF0aW9uLFxuICAgICAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbigpLFxuICAgICAgICAgIHJvdXRlQ29udGV4dDogeyBvdXRsZXQ6IG51bGwsIG1hdGNoZXM6IG1hdGNoZXMyLCBpc0RhdGFSb3V0ZTogdHJ1ZSB9LFxuICAgICAgICAgIHVuc3RhYmxlX29uRXJyb3JcbiAgICAgICAgfVxuICAgICAgKSA6IGdldENoaWxkcmVuKCk7XG4gICAgfSxcbiAgICBudWxsXG4gICk7XG59XG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XG4gIHJldHVybiBgJHtob29rTmFtZX0gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2VuL21haW4vcm91dGVycy9waWNraW5nLWEtcm91dGVyLmA7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHJvdXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiByb3V0ZTtcbn1cbmZ1bmN0aW9uIHVzZUN1cnJlbnRSb3V0ZUlkKGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGludmFyaWFudChcbiAgICB0aGlzUm91dGUucm91dGUuaWQsXG4gICAgYCR7aG9va05hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICByZXR1cm4gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VSb3V0ZUlkXCIgLyogVXNlUm91dGVJZCAqLyk7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VOYXZpZ2F0aW9uXCIgLyogVXNlTmF2aWdhdGlvbiAqLyk7XG4gIHJldHVybiBzdGF0ZS5uYXZpZ2F0aW9uO1xufVxuZnVuY3Rpb24gdXNlUmV2YWxpZGF0b3IoKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFwidXNlUmV2YWxpZGF0b3JcIiAvKiBVc2VSZXZhbGlkYXRvciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZVJldmFsaWRhdG9yXCIgLyogVXNlUmV2YWxpZGF0b3IgKi8pO1xuICBsZXQgcmV2YWxpZGF0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUoKTtcbiAgfSwgW2RhdGFSb3V0ZXJDb250ZXh0LnJvdXRlcl0pO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gKHsgcmV2YWxpZGF0ZSwgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvbiB9KSxcbiAgICBbcmV2YWxpZGF0ZSwgc3RhdGUucmV2YWxpZGF0aW9uXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWF0Y2hlcygpIHtcbiAgbGV0IHsgbWF0Y2hlcywgbG9hZGVyRGF0YSB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKFxuICAgIFwidXNlTWF0Y2hlc1wiIC8qIFVzZU1hdGNoZXMgKi9cbiAgKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoZXMubWFwKChtKSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBsb2FkZXJEYXRhKSksXG4gICAgW21hdGNoZXMsIGxvYWRlckRhdGFdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuZnVuY3Rpb24gdXNlUm91dGVMb2FkZXJEYXRhKHJvdXRlSWQpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlUm91dGVMb2FkZXJEYXRhXCIgLyogVXNlUm91dGVMb2FkZXJEYXRhICovKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5mdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VBY3Rpb25EYXRhXCIgLyogVXNlQWN0aW9uRGF0YSAqLyk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VMb2FkZXJEYXRhXCIgLyogVXNlTG9hZGVyRGF0YSAqLyk7XG4gIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhID8gc3RhdGUuYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlRXJyb3IoKSB7XG4gIGxldCBlcnJvciA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlUm91dGVFcnJvclwiIC8qIFVzZVJvdXRlRXJyb3IgKi8pO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlUm91dGVFcnJvclwiIC8qIFVzZVJvdXRlRXJyb3IgKi8pO1xuICBpZiAoZXJyb3IgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByZXR1cm4gc3RhdGUuZXJyb3JzPy5bcm91dGVJZF07XG59XG5mdW5jdGlvbiB1c2VBc3luY1ZhbHVlKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdDIudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWU/Ll9kYXRhO1xufVxuZnVuY3Rpb24gdXNlQXN5bmNFcnJvcigpIHtcbiAgbGV0IHZhbHVlID0gUmVhY3QyLnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlPy5fZXJyb3I7XG59XG52YXIgYmxvY2tlcklkID0gMDtcbmZ1bmN0aW9uIHVzZUJsb2NrZXIoc2hvdWxkQmxvY2spIHtcbiAgbGV0IHsgcm91dGVyLCBiYXNlbmFtZSB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoXCJ1c2VCbG9ja2VyXCIgLyogVXNlQmxvY2tlciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZUJsb2NrZXJcIiAvKiBVc2VCbG9ja2VyICovKTtcbiAgbGV0IFtibG9ja2VyS2V5LCBzZXRCbG9ja2VyS2V5XSA9IFJlYWN0Mi51c2VTdGF0ZShcIlwiKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICAoYXJnKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNob3VsZEJsb2NrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xuICAgICAgfVxuICAgICAgbGV0IHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSA9IGFyZztcbiAgICAgIHJldHVybiBzaG91bGRCbG9jayh7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjoge1xuICAgICAgICAgIC4uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dExvY2F0aW9uOiB7XG4gICAgICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9LFxuICAgICAgICBoaXN0b3J5QWN0aW9uXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtiYXNlbmFtZSwgc2hvdWxkQmxvY2tdXG4gICk7XG4gIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgIHNldEJsb2NrZXJLZXkoa2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgfSwgW3JvdXRlcl0pO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgcm91dGVyLmdldEJsb2NrZXIoYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0pO1xuICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSkgPyBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgOiBJRExFX0JMT0NLRVI7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVN0YWJsZSgpIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChcInVzZU5hdmlnYXRlXCIgLyogVXNlTmF2aWdhdGVTdGFibGUgKi8pO1xuICBsZXQgaWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZU5hdmlnYXRlXCIgLyogVXNlTmF2aWdhdGVTdGFibGUgKi8pO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QyLnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICBhc3luYyAodG8sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKTtcbiAgICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcm91dGVyLm5hdmlnYXRlKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHJvdXRlci5uYXZpZ2F0ZSh0bywgeyBmcm9tUm91dGVJZDogaWQsIC4uLm9wdGlvbnMgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLCBpZF1cbiAgKTtcbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxudmFyIGFscmVhZHlXYXJuZWQgPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleSwgY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL2NvbXBvbmVudHMudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDMgZnJvbSBcInJlYWN0XCI7XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS93YXJuaW5ncy50c1xudmFyIGFscmVhZHlXYXJuZWQyID0ge307XG5mdW5jdGlvbiB3YXJuT25jZShjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24gJiYgIWFscmVhZHlXYXJuZWQyW21lc3NhZ2VdKSB7XG4gICAgYWxyZWFkeVdhcm5lZDJbbWVzc2FnZV0gPSB0cnVlO1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvY29tcG9uZW50cy50c3hcbmZ1bmN0aW9uIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSkge1xuICBsZXQgdXBkYXRlcyA9IHtcbiAgICAvLyBOb3RlOiB0aGlzIGNoZWNrIGFsc28gb2NjdXJzIGluIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBzbyB1cGRhdGVcbiAgICAvLyB0aGVyZSBpZiB5b3UgY2hhbmdlIHRoaXMgLS0gcGxlYXNlIGFuZCB0aGFuayB5b3UhXG4gICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuaGFzRXJyb3JCb3VuZGFyeSB8fCByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGxcbiAgfTtcbiAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBDb21wb25lbnRgIGFuZCBgZWxlbWVudGAgb24geW91ciByb3V0ZSAtIGBDb21wb25lbnRgIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVsZW1lbnQ6IFJlYWN0My5jcmVhdGVFbGVtZW50KHJvdXRlLkNvbXBvbmVudCksXG4gICAgICBDb21wb25lbnQ6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIGlmIChyb3V0ZS5IeWRyYXRlRmFsbGJhY2spIHtcbiAgICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgICAgaWYgKHJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgSHlkcmF0ZUZhbGxiYWNrYCBhbmQgYGh5ZHJhdGVGYWxsYmFja0VsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBgSHlkcmF0ZUZhbGxiYWNrYCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiBSZWFjdDMuY3JlYXRlRWxlbWVudChyb3V0ZS5IeWRyYXRlRmFsbGJhY2spLFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuRXJyb3JCb3VuZGFyeSkge1xuICAgIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgICBpZiAocm91dGUuZXJyb3JFbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEVycm9yQm91bmRhcnlgIGFuZCBgZXJyb3JFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gYEVycm9yQm91bmRhcnlgIHdpbGwgYmUgdXNlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVycm9yRWxlbWVudDogUmVhY3QzLmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICBFcnJvckJvdW5kYXJ5OiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbnZhciBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMgPSBbXG4gIFwiSHlkcmF0ZUZhbGxiYWNrXCIsXG4gIFwiaHlkcmF0ZUZhbGxiYWNrRWxlbWVudFwiXG5dO1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5Um91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgZ2V0Q29udGV4dDogb3B0cz8uZ2V0Q29udGV4dCxcbiAgICBmdXR1cmU6IG9wdHM/LmZ1dHVyZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzPy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleDogb3B0cz8uaW5pdGlhbEluZGV4XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXMsXG4gICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHM/LmRhdGFTdHJhdGVneSxcbiAgICBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbjogb3B0cz8ucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25cbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxudmFyIERlZmVycmVkID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlc29sdmVkXCI7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc2hhbGxvd0RpZmYoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgbGV0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGtleSBvZiBhS2V5cykge1xuICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIFVOU1RBQkxFX1RyYW5zaXRpb25FbmFibGVkUm91dGVyUHJvdmlkZXIoe1xuICByb3V0ZXIsXG4gIGZsdXNoU3luYzogcmVhY3REb21GbHVzaFN5bmNJbXBsLFxuICB1bnN0YWJsZV9vbkVycm9yXG59KSB7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0My51c2VSZWYoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGxldCBbcmV2YWxpZGF0aW5nLCBzdGFydFJldmFsaWRhdGlvbl0gPSBSZWFjdDMudXNlVHJhbnNpdGlvbigpO1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdDMudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcbiAgcm91dGVyLl9fc2V0UGVuZGluZ1JlcmVuZGVyID0gKHByb21pc2UpID0+IHN0YXJ0UmV2YWxpZGF0aW9uKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBuZWVkIHJlYWN0IDE5IHR5cGVzIGZvciB0aGlzIHRvIGJlIGFzeW5jXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVyZW5kZXIgPSBhd2FpdCBwcm9taXNlO1xuICAgICAgc3RhcnRSZXZhbGlkYXRpb24oKCkgPT4ge1xuICAgICAgICByZXJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QzLnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogKG4pID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUyLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGU6IHN0YXRlMixcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZTIsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICBzdGF0ZTogc3RhdGUyLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHJvdXRlcixcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHVuc3RhYmxlX29uRXJyb3JcbiAgICB9KSxcbiAgICBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lLCB1bnN0YWJsZV9vbkVycm9yXVxuICApO1xuICBSZWFjdDMudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gcm91dGVyLnN1YnNjcmliZShcbiAgICAgIChuZXdTdGF0ZSwgeyBkZWxldGVkRmV0Y2hlcnMsIGZsdXNoU3luYywgdmlld1RyYW5zaXRpb25PcHRzIH0pID0+IHtcbiAgICAgICAgbmV3U3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKGZldGNoZXIuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmZXRjaGVyRGF0YS5jdXJyZW50LnNldChrZXksIGZldGNoZXIuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmZvckVhY2goKGtleSkgPT4gZmV0Y2hlckRhdGEuY3VycmVudC5kZWxldGUoa2V5KSk7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBzaGFsbG93RGlmZihzdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICBpZiAoIWRpZmYpIHJldHVybjtcbiAgICAgICAgaWYgKGZsdXNoU3luYykge1xuICAgICAgICAgIGlmIChyZWFjdERvbUZsdXNoU3luY0ltcGwpIHtcbiAgICAgICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiBzZXRTdGF0ZShuZXdTdGF0ZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlYWN0My5zdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfSwgW3JvdXRlciwgcmVhY3REb21GbHVzaFN5bmNJbXBsLCBzdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlYWN0My5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgcmV2YWxpZGF0aW9uOiByZXZhbGlkYXRpbmcgPyBcImxvYWRpbmdcIiA6IHN0YXRlLnJldmFsaWRhdGlvblxuICAgICAgfVxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZmV0Y2hlckRhdGEuY3VycmVudCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBSb3V0ZXIsXG4gICAgICB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgICBuYXZpZ2F0b3JcbiAgICAgIH0sXG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIE1lbW9pemVkRGF0YVJvdXRlcyxcbiAgICAgICAge1xuICAgICAgICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICAgICAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgdW5zdGFibGVfb25FcnJvclxuICAgICAgICB9XG4gICAgICApXG4gICAgKSlcbiAgKSksIG51bGwpO1xufVxuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoe1xuICByb3V0ZXIsXG4gIGZsdXNoU3luYzogcmVhY3REb21GbHVzaFN5bmNJbXBsLFxuICB1bnN0YWJsZV9vbkVycm9yXG59KSB7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDMudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcbiAgbGV0IFtwZW5kaW5nU3RhdGUsIHNldFBlbmRpbmdTdGF0ZV0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IFt2dENvbnRleHQsIHNldFZ0Q29udGV4dF0gPSBSZWFjdDMudXNlU3RhdGUoe1xuICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgfSk7XG4gIGxldCBbcmVuZGVyRGZkLCBzZXRSZW5kZXJEZmRdID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBbdHJhbnNpdGlvbiwgc2V0VHJhbnNpdGlvbl0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IFtpbnRlcnJ1cHRpb24sIHNldEludGVycnVwdGlvbl0gPSBSZWFjdDMudXNlU3RhdGUoKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QzLnVzZVJlZigvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgbGV0IGxvZ0Vycm9yc0FuZFNldFN0YXRlID0gUmVhY3QzLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgc2V0U3RhdGVJbXBsKChwcmV2U3RhdGUpID0+IHtcbiAgICAgICAgaWYgKG5ld1N0YXRlLmVycm9ycyAmJiB1bnN0YWJsZV9vbkVycm9yKSB7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMobmV3U3RhdGUuZXJyb3JzKS5mb3JFYWNoKChbcm91dGVJZCwgZXJyb3JdKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldlN0YXRlLmVycm9ycz8uW3JvdXRlSWRdICE9PSBlcnJvcikge1xuICAgICAgICAgICAgICB1bnN0YWJsZV9vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFt1bnN0YWJsZV9vbkVycm9yXVxuICApO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlLCB7IGRlbGV0ZWRGZXRjaGVycywgZmx1c2hTeW5jLCB2aWV3VHJhbnNpdGlvbk9wdHMgfSkgPT4ge1xuICAgICAgbmV3U3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChmZXRjaGVyLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGZldGNoZXJEYXRhLmN1cnJlbnQuc2V0KGtleSwgZmV0Y2hlci5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZWxldGVkRmV0Y2hlcnMuZm9yRWFjaCgoa2V5KSA9PiBmZXRjaGVyRGF0YS5jdXJyZW50LmRlbGV0ZShrZXkpKTtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBmbHVzaFN5bmMgPT09IGZhbHNlIHx8IHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAhPSBudWxsLFxuICAgICAgICAnWW91IHByb3ZpZGVkIHRoZSBgZmx1c2hTeW5jYCBvcHRpb24gdG8gYSByb3V0ZXIgdXBkYXRlLCBidXQgeW91IGFyZSBub3QgdXNpbmcgdGhlIGA8Um91dGVyUHJvdmlkZXI+YCBmcm9tIGByZWFjdC1yb3V0ZXIvZG9tYCBzbyBgUmVhY3RET00uZmx1c2hTeW5jKClgIGlzIHVuYXZhaWxhYmxlLiAgUGxlYXNlIHVwZGF0ZSB5b3VyIGFwcCB0byBgaW1wb3J0IHsgUm91dGVyUHJvdmlkZXIgfSBmcm9tIFwicmVhY3Qtcm91dGVyL2RvbVwiYCBhbmQgZW5zdXJlIHlvdSBoYXZlIGByZWFjdC1kb21gIGluc3RhbGxlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdXNlIHRoZSBgZmx1c2hTeW5jYCBvcHRpb24uJ1xuICAgICAgKTtcbiAgICAgIGxldCBpc1ZpZXdUcmFuc2l0aW9uQXZhaWxhYmxlID0gcm91dGVyLndpbmRvdyAhPSBudWxsICYmIHJvdXRlci53aW5kb3cuZG9jdW1lbnQgIT0gbnVsbCAmJiB0eXBlb2Ygcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID09IG51bGwgfHwgaXNWaWV3VHJhbnNpdGlvbkF2YWlsYWJsZSxcbiAgICAgICAgXCJZb3UgcHJvdmlkZWQgdGhlIGB2aWV3VHJhbnNpdGlvbmAgb3B0aW9uIHRvIGEgcm91dGVyIHVwZGF0ZSwgYnV0IHlvdSBkbyBub3QgYXBwZWFyIHRvIGJlIHJ1bm5pbmcgaW4gYSBET00gZW52aXJvbm1lbnQgYXMgYHdpbmRvdy5zdGFydFZpZXdUcmFuc2l0aW9uYCBpcyBub3QgYXZhaWxhYmxlLlwiXG4gICAgICApO1xuICAgICAgaWYgKCF2aWV3VHJhbnNpdGlvbk9wdHMgfHwgIWlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUpIHtcbiAgICAgICAgaWYgKHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAmJiBmbHVzaFN5bmMpIHtcbiAgICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4gbG9nRXJyb3JzQW5kU2V0U3RhdGUobmV3U3RhdGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IGxvZ0Vycm9yc0FuZFNldFN0YXRlKG5ld1N0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWN0RG9tRmx1c2hTeW5jSW1wbCAmJiBmbHVzaFN5bmMpIHtcbiAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHtcbiAgICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFZ0Q29udGV4dCh7XG4gICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgICBmbHVzaFN5bmM6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0ID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4gbG9nRXJyb3JzQW5kU2V0U3RhdGUobmV3U3RhdGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHQuZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHtcbiAgICAgICAgICAgIHNldFJlbmRlckRmZCh2b2lkIDApO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbih2b2lkIDApO1xuICAgICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHZvaWQgMCk7XG4gICAgICAgICAgICBzZXRWdENvbnRleHQoeyBpc1RyYW5zaXRpb25pbmc6IGZhbHNlIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHNldFRyYW5zaXRpb24odCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgICBzZXRJbnRlcnJ1cHRpb24oe1xuICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UGVuZGluZ1N0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgcm91dGVyLndpbmRvdyxcbiAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCxcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICByZW5kZXJEZmQsXG4gICAgICBsb2dFcnJvcnNBbmRTZXRTdGF0ZVxuICAgIF1cbiAgKTtcbiAgUmVhY3QzLnVzZUxheW91dEVmZmVjdCgoKSA9PiByb3V0ZXIuc3Vic2NyaWJlKHNldFN0YXRlKSwgW3JvdXRlciwgc2V0U3RhdGVdKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcgJiYgIXZ0Q29udGV4dC5mbHVzaFN5bmMpIHtcbiAgICAgIHNldFJlbmRlckRmZChuZXcgRGVmZXJyZWQoKSk7XG4gICAgfVxuICB9LCBbdnRDb250ZXh0XSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHJvdXRlci53aW5kb3cpIHtcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHBlbmRpbmdTdGF0ZTtcbiAgICAgIGxldCByZW5kZXJQcm9taXNlID0gcmVuZGVyRGZkLnByb21pc2U7XG4gICAgICBsZXQgdHJhbnNpdGlvbjIgPSByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IGxvZ0Vycm9yc0FuZFNldFN0YXRlKG5ld1N0YXRlKSk7XG4gICAgICAgIGF3YWl0IHJlbmRlclByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zaXRpb24yLmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJEZmQodm9pZCAwKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbih2b2lkIDApO1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUodm9pZCAwKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHsgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSB9KTtcbiAgICAgIH0pO1xuICAgICAgc2V0VHJhbnNpdGlvbih0cmFuc2l0aW9uMik7XG4gICAgfVxuICB9LCBbcGVuZGluZ1N0YXRlLCByZW5kZXJEZmQsIHJvdXRlci53aW5kb3csIGxvZ0Vycm9yc0FuZFNldFN0YXRlXSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleSkge1xuICAgICAgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmIGludGVycnVwdGlvbikge1xuICAgICAgc2V0UGVuZGluZ1N0YXRlKGludGVycnVwdGlvbi5zdGF0ZSk7XG4gICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW50ZXJydXB0aW9uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBpbnRlcnJ1cHRpb24ubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICAgIHNldEludGVycnVwdGlvbih2b2lkIDApO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcsIGludGVycnVwdGlvbl0pO1xuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QzLnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogKG4pID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUyLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGU6IHN0YXRlMixcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZTIsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICBzdGF0ZTogc3RhdGUyLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHM/LnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIHJvdXRlcixcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHVuc3RhYmxlX29uRXJyb3JcbiAgICB9KSxcbiAgICBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lLCB1bnN0YWJsZV9vbkVycm9yXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlYWN0My5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogc3RhdGUgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZmV0Y2hlckRhdGEuY3VycmVudCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoVmlld1RyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2dENvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBNZW1vaXplZERhdGFSb3V0ZXMsXG4gICAgICB7XG4gICAgICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICAgICAgZnV0dXJlOiByb3V0ZXIuZnV0dXJlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdW5zdGFibGVfb25FcnJvclxuICAgICAgfVxuICAgIClcbiAgKSkpKSksIG51bGwpO1xufVxudmFyIE1lbW9pemVkRGF0YVJvdXRlcyA9IFJlYWN0My5tZW1vKERhdGFSb3V0ZXMpO1xuZnVuY3Rpb24gRGF0YVJvdXRlcyh7XG4gIHJvdXRlcyxcbiAgZnV0dXJlLFxuICBzdGF0ZSxcbiAgdW5zdGFibGVfb25FcnJvclxufSkge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHZvaWQgMCwgc3RhdGUsIHVuc3RhYmxlX29uRXJyb3IsIGZ1dHVyZSk7XG59XG5mdW5jdGlvbiBNZW1vcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxFbnRyaWVzLFxuICBpbml0aWFsSW5kZXhcbn0pIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdDMudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXgsXG4gICAgICB2NUNvbXBhdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QzLnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QzLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIE5hdmlnYXRlKHtcbiAgdG8sXG4gIHJlcGxhY2U6IHJlcGxhY2UyLFxuICBzdGF0ZSxcbiAgcmVsYXRpdmVcbn0pIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgc3RhdGljOiBpc1N0YXRpYyB9ID0gUmVhY3QzLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICB3YXJuaW5nKFxuICAgICFpc1N0YXRpYyxcbiAgICBgPE5hdmlnYXRlPiBtdXN0IG5vdCBiZSB1c2VkIG9uIHRoZSBpbml0aWFsIHJlbmRlciBpbiBhIDxTdGF0aWNSb3V0ZXI+LiBUaGlzIGlzIGEgbm8tb3AsIGJ1dCB5b3Ugc2hvdWxkIG1vZGlmeSB5b3VyIGNvZGUgc28gdGhlIDxOYXZpZ2F0ZT4gaXMgb25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuYFxuICApO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDMudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgdG8sXG4gICAgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSxcbiAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICApO1xuICBsZXQganNvblBhdGggPSBKU09OLnN0cmluZ2lmeShwYXRoKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbmF2aWdhdGUoSlNPTi5wYXJzZShqc29uUGF0aCksIHsgcmVwbGFjZTogcmVwbGFjZTIsIHN0YXRlLCByZWxhdGl2ZSB9KTtcbiAgfSwgW25hdmlnYXRlLCBqc29uUGF0aCwgcmVsYXRpdmUsIHJlcGxhY2UyLCBzdGF0ZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIE91dGxldChwcm9wcykge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuZnVuY3Rpb24gUm91dGUocHJvcHMpIHtcbiAgaW52YXJpYW50KFxuICAgIGZhbHNlLFxuICAgIGBBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIG5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5gXG4gICk7XG59XG5mdW5jdGlvbiBSb3V0ZXIoe1xuICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgbmF2aWdhdGlvblR5cGUgPSBcIlBPUFwiIC8qIFBvcCAqLyxcbiAgbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufSkge1xuICBpbnZhcmlhbnQoXG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIGBZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LiBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5gXG4gICk7XG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBzdGF0aWNQcm9wLFxuICAgICAgZnV0dXJlOiB7fVxuICAgIH0pLFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXVxuICApO1xuICBpZiAodHlwZW9mIGxvY2F0aW9uUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2F0aW9uUHJvcCA9IHBhcnNlUGF0aChsb2NhdGlvblByb3ApO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxuICB9ID0gbG9jYXRpb25Qcm9wO1xuICBsZXQgbG9jYXRpb25Db250ZXh0ID0gUmVhY3QzLnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCB0cmFpbGluZ1BhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgaGFzaCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGtleVxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25UeXBlXG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5LCBuYXZpZ2F0aW9uVHlwZV0pO1xuICB3YXJuaW5nKFxuICAgIGxvY2F0aW9uQ29udGV4dCAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuICBpZiAobG9jYXRpb25Db250ZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBuYXZpZ2F0aW9uQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IGNoaWxkcmVuLCB2YWx1ZTogbG9jYXRpb25Db250ZXh0IH0pKTtcbn1cbmZ1bmN0aW9uIFJvdXRlcyh7XG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvblxufSkge1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIEF3YWl0KHtcbiAgY2hpbGRyZW4sXG4gIGVycm9yRWxlbWVudCxcbiAgcmVzb2x2ZVxufSkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdDMudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgQXdhaXRFcnJvckJvdW5kYXJ5LFxuICAgIHtcbiAgICAgIHJlc29sdmUsXG4gICAgICBlcnJvckVsZW1lbnQsXG4gICAgICB1bnN0YWJsZV9vbkVycm9yOiBkYXRhUm91dGVyQ29udGV4dD8udW5zdGFibGVfb25FcnJvclxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlc29sdmVBd2FpdCwgbnVsbCwgY2hpbGRyZW4pXG4gICk7XG59XG52YXIgQXdhaXRFcnJvckJvdW5kYXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDMuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgZXJyb3I6IG51bGwgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgaWYgKHRoaXMucHJvcHMudW5zdGFibGVfb25FcnJvcikge1xuICAgICAgdGhpcy5wcm9wcy51bnN0YWJsZV9vbkVycm9yKGVycm9yLCBlcnJvckluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIjxBd2FpdD4gY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZXJyb3JJbmZvXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4sIGVycm9yRWxlbWVudCwgcmVzb2x2ZSB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgbGV0IHN0YXR1cyA9IDAgLyogcGVuZGluZyAqLztcbiAgICBpZiAoIShyZXNvbHZlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIHN0YXR1cyA9IDEgLyogc3VjY2VzcyAqLztcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IHJlc29sdmUgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICBzdGF0dXMgPSAyIC8qIGVycm9yICovO1xuICAgICAgbGV0IHJlbmRlckVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdCgpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IHJlbmRlckVycm9yIH0pO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZS5fdHJhY2tlZCkge1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICBzdGF0dXMgPSBcIl9lcnJvclwiIGluIHByb21pc2UgPyAyIC8qIGVycm9yICovIDogXCJfZGF0YVwiIGluIHByb21pc2UgPyAxIC8qIHN1Y2Nlc3MgKi8gOiAwIC8qIHBlbmRpbmcgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1cyA9IDAgLyogcGVuZGluZyAqLztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihcbiAgICAgICAgKGRhdGEyKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YTIgfSksXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIHRoaXMucHJvcHMudW5zdGFibGVfb25FcnJvcj8uKGVycm9yKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAyIC8qIGVycm9yICovICYmICFlcnJvckVsZW1lbnQpIHtcbiAgICAgIHRocm93IHByb21pc2UuX2Vycm9yO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAyIC8qIGVycm9yICovKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvbWlzZSwgY2hpbGRyZW46IGVycm9yRWxlbWVudCB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gMSAvKiBzdWNjZXNzICovKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvbWlzZSwgY2hpbGRyZW4gfSk7XG4gICAgfVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn07XG5mdW5jdGlvbiBSZXNvbHZlQXdhaXQoe1xuICBjaGlsZHJlblxufSkge1xuICBsZXQgZGF0YTIgPSB1c2VBc3luY1ZhbHVlKCk7XG4gIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YTIpIDogY2hpbGRyZW47XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoUmVhY3QzLkZyYWdtZW50LCBudWxsLCB0b1JlbmRlcik7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFBhdGggPSBbXSkge1xuICBsZXQgcm91dGVzID0gW107XG4gIFJlYWN0My5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIVJlYWN0My5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0My5GcmFnbWVudCkge1xuICAgICAgcm91dGVzLnB1c2guYXBwbHkoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHRyZWVQYXRoKVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZWxlbWVudC50eXBlID09PSBSb3V0ZSxcbiAgICAgIGBbJHt0eXBlb2YgZWxlbWVudC50eXBlID09PSBcInN0cmluZ1wiID8gZWxlbWVudC50eXBlIDogZWxlbWVudC50eXBlLm5hbWV9XSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+YFxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIWVsZW1lbnQucHJvcHMuaW5kZXggfHwgIWVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIlxuICAgICk7XG4gICAgbGV0IHJvdXRlID0ge1xuICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBlbGVtZW50LnByb3BzLmNhc2VTZW5zaXRpdmUsXG4gICAgICBlbGVtZW50OiBlbGVtZW50LnByb3BzLmVsZW1lbnQsXG4gICAgICBDb21wb25lbnQ6IGVsZW1lbnQucHJvcHMuQ29tcG9uZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgICBtaWRkbGV3YXJlOiBlbGVtZW50LnByb3BzLm1pZGRsZXdhcmUsXG4gICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxuICAgICAgYWN0aW9uOiBlbGVtZW50LnByb3BzLmFjdGlvbixcbiAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IGVsZW1lbnQucHJvcHMuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCxcbiAgICAgIEh5ZHJhdGVGYWxsYmFjazogZWxlbWVudC5wcm9wcy5IeWRyYXRlRmFsbGJhY2ssXG4gICAgICBlcnJvckVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50LFxuICAgICAgRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5LFxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5oYXNFcnJvckJvdW5kYXJ5ID09PSB0cnVlIHx8IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiBlbGVtZW50LnByb3BzLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5XG4gICAgfTtcbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oXG4gICAgICAgIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHRyZWVQYXRoXG4gICAgICApO1xuICAgIH1cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxudmFyIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjtcbmZ1bmN0aW9uIHJlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUNvbXBvbmVudFByb3BzKCkge1xuICByZXR1cm4ge1xuICAgIHBhcmFtczogdXNlUGFyYW1zKCksXG4gICAgbG9hZGVyRGF0YTogdXNlTG9hZGVyRGF0YSgpLFxuICAgIGFjdGlvbkRhdGE6IHVzZUFjdGlvbkRhdGEoKSxcbiAgICBtYXRjaGVzOiB1c2VNYXRjaGVzKClcbiAgfTtcbn1cbmZ1bmN0aW9uIFdpdGhDb21wb25lbnRQcm9wcyh7XG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IHByb3BzID0gdXNlUm91dGVDb21wb25lbnRQcm9wcygpO1xuICByZXR1cm4gUmVhY3QzLmNsb25lRWxlbWVudChjaGlsZHJlbiwgcHJvcHMpO1xufVxuZnVuY3Rpb24gd2l0aENvbXBvbmVudFByb3BzKENvbXBvbmVudDQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdpdGhDb21wb25lbnRQcm9wczIoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB1c2VSb3V0ZUNvbXBvbmVudFByb3BzKCk7XG4gICAgcmV0dXJuIFJlYWN0My5jcmVhdGVFbGVtZW50KENvbXBvbmVudDQsIHByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUh5ZHJhdGVGYWxsYmFja1Byb3BzKCkge1xuICByZXR1cm4ge1xuICAgIHBhcmFtczogdXNlUGFyYW1zKCksXG4gICAgbG9hZGVyRGF0YTogdXNlTG9hZGVyRGF0YSgpLFxuICAgIGFjdGlvbkRhdGE6IHVzZUFjdGlvbkRhdGEoKVxuICB9O1xufVxuZnVuY3Rpb24gV2l0aEh5ZHJhdGVGYWxsYmFja1Byb3BzKHtcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgcHJvcHMgPSB1c2VIeWRyYXRlRmFsbGJhY2tQcm9wcygpO1xuICByZXR1cm4gUmVhY3QzLmNsb25lRWxlbWVudChjaGlsZHJlbiwgcHJvcHMpO1xufVxuZnVuY3Rpb24gd2l0aEh5ZHJhdGVGYWxsYmFja1Byb3BzKEh5ZHJhdGVGYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gV2l0aEh5ZHJhdGVGYWxsYmFja1Byb3BzMigpIHtcbiAgICBjb25zdCBwcm9wcyA9IHVzZUh5ZHJhdGVGYWxsYmFja1Byb3BzKCk7XG4gICAgcmV0dXJuIFJlYWN0My5jcmVhdGVFbGVtZW50KEh5ZHJhdGVGYWxsYmFjaywgcHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gdXNlRXJyb3JCb3VuZGFyeVByb3BzKCkge1xuICByZXR1cm4ge1xuICAgIHBhcmFtczogdXNlUGFyYW1zKCksXG4gICAgbG9hZGVyRGF0YTogdXNlTG9hZGVyRGF0YSgpLFxuICAgIGFjdGlvbkRhdGE6IHVzZUFjdGlvbkRhdGEoKSxcbiAgICBlcnJvcjogdXNlUm91dGVFcnJvcigpXG4gIH07XG59XG5mdW5jdGlvbiBXaXRoRXJyb3JCb3VuZGFyeVByb3BzKHtcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgcHJvcHMgPSB1c2VFcnJvckJvdW5kYXJ5UHJvcHMoKTtcbiAgcmV0dXJuIFJlYWN0My5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHByb3BzKTtcbn1cbmZ1bmN0aW9uIHdpdGhFcnJvckJvdW5kYXJ5UHJvcHMoRXJyb3JCb3VuZGFyeSkge1xuICByZXR1cm4gZnVuY3Rpb24gV2l0aEVycm9yQm91bmRhcnlQcm9wczIoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB1c2VFcnJvckJvdW5kYXJ5UHJvcHMoKTtcbiAgICByZXR1cm4gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgcHJvcHMpO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL2RvbS50c1xudmFyIGRlZmF1bHRNZXRob2QgPSBcImdldFwiO1xudmFyIGRlZmF1bHRFbmNUeXBlID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnRhZ05hbWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbn1cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCI7XG59XG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDAgJiYgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhpbml0ID0gXCJcIikge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGluaXQpIHx8IGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBpbml0IDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vMiwga2V5KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICByZXR1cm4gbWVtbzIuY29uY2F0KFxuICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodikgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV1cbiAgICAgICk7XG4gICAgfSwgW10pXG4gICk7XG59XG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvblNlYXJjaCwgZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uU2VhcmNoKTtcbiAgaWYgKGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG52YXIgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBudWxsO1xuZnVuY3Rpb24gaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpIHtcbiAgaWYgKF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID09PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGb3JtRGF0YShcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgRm9ybURhdGEgc3VwcG9ydHMgdGhlIHN1Ym1pdHRlciBwYXJhbWV0ZXIsIHRoaXMgd2lsbCB0aHJvd1xuICAgICAgICAwXG4gICAgICApO1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcbn1cbnZhciBzdXBwb3J0ZWRGb3JtRW5jVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLFxuICBcInRleHQvcGxhaW5cIlxuXSk7XG5mdW5jdGlvbiBnZXRGb3JtRW5jVHlwZShlbmNUeXBlKSB7XG4gIGlmIChlbmNUeXBlICE9IG51bGwgJiYgIXN1cHBvcnRlZEZvcm1FbmNUeXBlcy5oYXMoZW5jVHlwZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgXCIke2VuY1R5cGV9XCIgaXMgbm90IGEgdmFsaWQgXFxgZW5jVHlwZVxcYCBmb3IgXFxgPEZvcm0+XFxgL1xcYDxmZXRjaGVyLkZvcm0+XFxgIGFuZCB3aWxsIGRlZmF1bHQgdG8gXCIke2RlZmF1bHRFbmNUeXBlfVwiYFxuICAgICk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVuY1R5cGU7XG59XG5mdW5jdGlvbiBnZXRGb3JtU3VibWlzc2lvbkluZm8odGFyZ2V0LCBiYXNlbmFtZSkge1xuICBsZXQgbWV0aG9kO1xuICBsZXQgYWN0aW9uO1xuICBsZXQgZW5jVHlwZTtcbiAgbGV0IGZvcm1EYXRhO1xuICBsZXQgYm9keTtcbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICBsZXQgZm9ybSA9IHRhcmdldC5mb3JtO1xuICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiPiB3aXRob3V0IGEgPGZvcm0+YFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSkgfHwgZ2V0Rm9ybUVuY1R5cGUoZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xuICAgIGlmICghaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpKSB7XG4gICAgICBsZXQgeyBuYW1lLCB0eXBlLCB2YWx1ZSB9ID0gdGFyZ2V0O1xuICAgICAgaWYgKHR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBsZXQgcHJlZml4ID0gbmFtZSA/IGAke25hbWV9LmAgOiBcIlwiO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7cHJlZml4fXhgLCBcIjBcIik7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtwcmVmaXh9eWAsIFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBudWxsO1xuICAgIGVuY1R5cGUgPSBkZWZhdWx0RW5jVHlwZTtcbiAgICBib2R5ID0gdGFyZ2V0O1xuICB9XG4gIGlmIChmb3JtRGF0YSAmJiBlbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgIGJvZHkgPSBmb3JtRGF0YTtcbiAgICBmb3JtRGF0YSA9IHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBhY3Rpb24sIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH07XG59XG5cbi8vIGxpYi9kb20vc3NyL3NpbmdsZS1mZXRjaC50c3hcbmltcG9ydCAqIGFzIFJlYWN0NCBmcm9tIFwicmVhY3RcIjtcblxuLy8gdmVuZG9yL3R1cmJvLXN0cmVhbS12Mi91dGlscy50c1xudmFyIEhPTEUgPSAtMTtcbnZhciBOQU4gPSAtMjtcbnZhciBORUdBVElWRV9JTkZJTklUWSA9IC0zO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAtNDtcbnZhciBOVUxMID0gLTU7XG52YXIgUE9TSVRJVkVfSU5GSU5JVFkgPSAtNjtcbnZhciBVTkRFRklORUQgPSAtNztcbnZhciBUWVBFX0JJR0lOVCA9IFwiQlwiO1xudmFyIFRZUEVfREFURSA9IFwiRFwiO1xudmFyIFRZUEVfRVJST1IgPSBcIkVcIjtcbnZhciBUWVBFX01BUCA9IFwiTVwiO1xudmFyIFRZUEVfTlVMTF9PQkpFQ1QgPSBcIk5cIjtcbnZhciBUWVBFX1BST01JU0UgPSBcIlBcIjtcbnZhciBUWVBFX1JFR0VYUCA9IFwiUlwiO1xudmFyIFRZUEVfU0VUID0gXCJTXCI7XG52YXIgVFlQRV9TWU1CT0wgPSBcIllcIjtcbnZhciBUWVBFX1VSTCA9IFwiVVwiO1xudmFyIFRZUEVfUFJFVklPVVNfUkVTT0xWRUQgPSBcIlpcIjtcbnZhciBEZWZlcnJlZDIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpbmVTcGxpdHRpbmdUcmFuc2Zvcm0oKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGxlZnRvdmVyID0gXCJcIjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3Qgc3RyID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFydHMgPSAobGVmdG92ZXIgKyBzdHIpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgbGVmdG92ZXIgPSBwYXJ0cy5wb3AoKSB8fCBcIlwiO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmIChsZWZ0b3Zlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobGVmdG92ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHZlbmRvci90dXJiby1zdHJlYW0tdjIvZmxhdHRlbi50c1xuZnVuY3Rpb24gZmxhdHRlbihpbnB1dCkge1xuICBjb25zdCB7IGluZGljZXMgfSA9IHRoaXM7XG4gIGNvbnN0IGV4aXN0aW5nID0gaW5kaWNlcy5nZXQoaW5wdXQpO1xuICBpZiAoZXhpc3RpbmcpIHJldHVybiBbZXhpc3RpbmddO1xuICBpZiAoaW5wdXQgPT09IHZvaWQgMCkgcmV0dXJuIFVOREVGSU5FRDtcbiAgaWYgKGlucHV0ID09PSBudWxsKSByZXR1cm4gTlVMTDtcbiAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIHJldHVybiBOQU47XG4gIGlmIChpbnB1dCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSByZXR1cm4gUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGlmIChpbnB1dCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSByZXR1cm4gTkVHQVRJVkVfSU5GSU5JVFk7XG4gIGlmIChpbnB1dCA9PT0gMCAmJiAxIC8gaW5wdXQgPCAwKSByZXR1cm4gTkVHQVRJVkVfWkVSTztcbiAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gIGluZGljZXMuc2V0KGlucHV0LCBpbmRleCk7XG4gIHN0cmluZ2lmeS5jYWxsKHRoaXMsIGlucHV0LCBpbmRleCk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShpbnB1dCwgaW5kZXgpIHtcbiAgY29uc3QgeyBkZWZlcnJlZCwgcGx1Z2lucywgcG9zdFBsdWdpbnMgfSA9IHRoaXM7XG4gIGNvbnN0IHN0ciA9IHRoaXMuc3RyaW5naWZpZWQ7XG4gIGNvbnN0IHN0YWNrID0gW1tpbnB1dCwgaW5kZXhdXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBbaW5wdXQyLCBpbmRleDJdID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcGFydHNGb3JPYmogPSAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopLm1hcCgoaykgPT4gYFwiXyR7ZmxhdHRlbi5jYWxsKHRoaXMsIGspfVwiOiR7ZmxhdHRlbi5jYWxsKHRoaXMsIG9ialtrXSl9YCkuam9pbihcIixcIik7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBzd2l0Y2ggKHR5cGVvZiBpbnB1dDIpIHtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHN0cltpbmRleDJdID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9CSUdJTlR9XCIsXCIke2lucHV0Mn1cIl1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjoge1xuICAgICAgICBjb25zdCBrZXlGb3IgPSBTeW1ib2wua2V5Rm9yKGlucHV0Mik7XG4gICAgICAgIGlmICgha2V5Rm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBlbmNvZGUgc3ltYm9sIHVubGVzcyBjcmVhdGVkIHdpdGggU3ltYm9sLmZvcigpXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9TWU1CT0x9XCIsJHtKU09OLnN0cmluZ2lmeShrZXlGb3IpfV1gO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaW5wdXQyKSB7XG4gICAgICAgICAgc3RyW2luZGV4Ml0gPSBgJHtOVUxMfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5wdXQyKTtcbiAgICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFpc0FycmF5ICYmIHBsdWdpbnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBwbHVnaW4oaW5wdXQyKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcGx1Z2luSGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtwbHVnaW5JZGVudGlmaWVyLCAuLi5yZXN0XSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgICAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtyZXN0Lm1hcCgodikgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHYpKS5qb2luKFwiLFwiKX1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IFwiXVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGlzQXJyYXkgPyBcIltcIiA6IFwie1wiO1xuICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Mi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IChpID8gXCIsXCIgOiBcIlwiKSArIChpIGluIGlucHV0MiA/IGZsYXR0ZW4uY2FsbCh0aGlzLCBpbnB1dDJbaV0pIDogSE9MRSk7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGAke3Jlc3VsdH1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVUaW1lID0gaW5wdXQyLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9EQVRFfVwiLCR7TnVtYmVyLmlzTmFOKGRhdGVUaW1lKSA/IEpTT04uc3RyaW5naWZ5KFwiaW52YWxpZFwiKSA6IGRhdGVUaW1lfV1gO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfVVJMfVwiLCR7SlNPTi5zdHJpbmdpZnkoaW5wdXQyLmhyZWYpfV1gO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfUkVHRVhQfVwiLCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIGlucHV0Mi5zb3VyY2VcbiAgICAgICAgICAgICl9LCR7SlNPTi5zdHJpbmdpZnkoaW5wdXQyLmZsYWdzKX1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Mi5zaXplID4gMCkge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfU0VUfVwiLCR7Wy4uLmlucHV0Ml0ubWFwKCh2YWwpID0+IGZsYXR0ZW4uY2FsbCh0aGlzLCB2YWwpKS5qb2luKFwiLFwiKX1dYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9TRVR9XCJdYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Mi5zaXplID4gMCkge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfTUFQfVwiLCR7Wy4uLmlucHV0Ml0uZmxhdE1hcCgoW2ssIHZdKSA9PiBbXG4gICAgICAgICAgICAgICAgZmxhdHRlbi5jYWxsKHRoaXMsIGspLFxuICAgICAgICAgICAgICAgIGZsYXR0ZW4uY2FsbCh0aGlzLCB2KVxuICAgICAgICAgICAgICBdKS5qb2luKFwiLFwiKX1dYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9NQVB9XCJdYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9QUk9NSVNFfVwiLCR7aW5kZXgyfV1gO1xuICAgICAgICAgICAgZGVmZXJyZWRbaW5kZXgyXSA9IGlucHV0MjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0MiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfRVJST1J9XCIsJHtKU09OLnN0cmluZ2lmeShpbnB1dDIubWVzc2FnZSl9YDtcbiAgICAgICAgICAgIGlmIChpbnB1dDIubmFtZSAhPT0gXCJFcnJvclwiKSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtKU09OLnN0cmluZ2lmeShpbnB1dDIubmFtZSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cltpbmRleDJdICs9IFwiXVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0MikgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9OVUxMX09CSkVDVH1cIix7JHtwYXJ0c0Zvck9iaihpbnB1dDIpfX1dYDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5wdXQyKSkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgeyR7cGFydHNGb3JPYmooaW5wdXQyKX19YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZW5jb2RlIG9iamVjdCB3aXRoIHByb3RvdHlwZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGlucHV0Mik7XG4gICAgICAgIGxldCBwbHVnaW5IYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghaXNBcnJheSAmJiBwbHVnaW5zKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgY29uc3QgcGx1Z2luUmVzdWx0ID0gcGx1Z2luKGlucHV0Mik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHBsdWdpbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCBbcGx1Z2luSWRlbnRpZmllciwgLi4ucmVzdF0gPSBwbHVnaW5SZXN1bHQ7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFske0pTT04uc3RyaW5naWZ5KHBsdWdpbklkZW50aWZpZXIpfWA7XG4gICAgICAgICAgICAgIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBgLCR7cmVzdC5tYXAoKHYpID0+IGZsYXR0ZW4uY2FsbCh0aGlzLCB2KSkuam9pbihcIixcIil9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGx1Z2luSGFuZGxlZCkge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQ2Fubm90IGVuY29kZSBmdW5jdGlvbiBvciB1bmV4cGVjdGVkIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBsZXQgcGx1Z2luSGFuZGxlZCA9IGZhbHNlO1xuICAgICAgaWYgKHBvc3RQbHVnaW5zKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBvc3RQbHVnaW5zKSB7XG4gICAgICAgICAgY29uc3QgcGx1Z2luUmVzdWx0ID0gcGx1Z2luKGlucHV0Mik7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luUmVzdWx0KSkge1xuICAgICAgICAgICAgcGx1Z2luSGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBbcGx1Z2luSWRlbnRpZmllciwgLi4ucmVzdF0gPSBwbHVnaW5SZXN1bHQ7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbJHtKU09OLnN0cmluZ2lmeShwbHVnaW5JZGVudGlmaWVyKX1gO1xuICAgICAgICAgICAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBgLCR7cmVzdC5tYXAoKHYpID0+IGZsYXR0ZW4uY2FsbCh0aGlzLCB2KSkuam9pbihcIixcIil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cltpbmRleDJdICs9IFwiXVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXBsdWdpbkhhbmRsZWQpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgb2JqZWN0UHJvdG9OYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpLnNvcnQoKS5qb2luKFwiXFwwXCIpO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh0aGluZykge1xuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGluZyk7XG4gIHJldHVybiBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbCB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuc29ydCgpLmpvaW4oXCJcXDBcIikgPT09IG9iamVjdFByb3RvTmFtZXM7XG59XG5cbi8vIHZlbmRvci90dXJiby1zdHJlYW0tdjIvdW5mbGF0dGVuLnRzXG52YXIgZ2xvYmFsT2JqID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHZvaWQgMDtcbmZ1bmN0aW9uIHVuZmxhdHRlbihwYXJzZWQpIHtcbiAgY29uc3QgeyBoeWRyYXRlZCwgdmFsdWVzIH0gPSB0aGlzO1xuICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGh5ZHJhdGUuY2FsbCh0aGlzLCBwYXJzZWQpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyc2VkKSB8fCAhcGFyc2VkLmxlbmd0aCkgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHBhcnNlZCkge1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxuICBoeWRyYXRlZC5sZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gaHlkcmF0ZS5jYWxsKHRoaXMsIHN0YXJ0SW5kZXgpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZShpbmRleCkge1xuICBjb25zdCB7IGh5ZHJhdGVkLCB2YWx1ZXMsIGRlZmVycmVkLCBwbHVnaW5zIH0gPSB0aGlzO1xuICBsZXQgcmVzdWx0O1xuICBjb25zdCBzdGFjayA9IFtcbiAgICBbXG4gICAgICBpbmRleCxcbiAgICAgICh2KSA9PiB7XG4gICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICB9XG4gICAgXVxuICBdO1xuICBsZXQgcG9zdFJ1biA9IFtdO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IFtpbmRleDIsIHNldF0gPSBzdGFjay5wb3AoKTtcbiAgICBzd2l0Y2ggKGluZGV4Mikge1xuICAgICAgY2FzZSBVTkRFRklORUQ6XG4gICAgICAgIHNldCh2b2lkIDApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgTlVMTDpcbiAgICAgICAgc2V0KG51bGwpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgTkFOOlxuICAgICAgICBzZXQoTmFOKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIFBPU0lUSVZFX0lORklOSVRZOlxuICAgICAgICBzZXQoSW5maW5pdHkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgTkVHQVRJVkVfSU5GSU5JVFk6XG4gICAgICAgIHNldCgtSW5maW5pdHkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgTkVHQVRJVkVfWkVSTzpcbiAgICAgICAgc2V0KC0wKTtcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChoeWRyYXRlZFtpbmRleDJdKSB7XG4gICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXgyXTtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IHZhbHVlO1xuICAgICAgc2V0KHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgW3R5cGUsIGIsIGNdID0gdmFsdWU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgVFlQRV9EQVRFOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBuZXcgRGF0ZShiKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfVVJMOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBuZXcgVVJMKGIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9CSUdJTlQ6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IEJpZ0ludChiKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfUkVHRVhQOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBuZXcgUmVnRXhwKGIsIGMpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9TWU1CT0w6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IFN5bWJvbC5mb3IoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1NFVDpcbiAgICAgICAgICAgIGNvbnN0IG5ld1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICBoeWRyYXRlZFtpbmRleDJdID0gbmV3U2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHZhbHVlLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pXG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBzZXQobmV3U2V0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9NQVA6XG4gICAgICAgICAgICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG1hcDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZS5sZW5ndGggLSAyOyBpID4gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgdmFsdWVbaSArIDFdLFxuICAgICAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICByWzFdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAoaykgPT4ge1xuICAgICAgICAgICAgICAgICAgclswXSA9IGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgcG9zdFJ1bi5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KHJbMF0sIHJbMV0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldChtYXApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX05VTExfT0JKRUNUOlxuICAgICAgICAgICAgY29uc3Qgb2JqID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBoeWRyYXRlZFtpbmRleDJdID0gb2JqO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYikucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgYltrZXldLFxuICAgICAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICByWzFdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICBOdW1iZXIoa2V5LnNsaWNlKDEpKSxcbiAgICAgICAgICAgICAgICAoaykgPT4ge1xuICAgICAgICAgICAgICAgICAgclswXSA9IGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgcG9zdFJ1bi5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvYmpbclswXV0gPSByWzFdO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldChvYmopO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1BST01JU0U6XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZWRbYl0pIHtcbiAgICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBoeWRyYXRlZFtiXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBkID0gbmV3IERlZmVycmVkMigpO1xuICAgICAgICAgICAgICBkZWZlcnJlZFtiXSA9IGQ7XG4gICAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gZC5wcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9FUlJPUjpcbiAgICAgICAgICAgIGNvbnN0IFssIG1lc3NhZ2UsIGVycm9yVHlwZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IGVycm9yVHlwZSAmJiBnbG9iYWxPYmogJiYgZ2xvYmFsT2JqW2Vycm9yVHlwZV0gPyBuZXcgZ2xvYmFsT2JqW2Vycm9yVHlwZV0obWVzc2FnZSkgOiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBoeWRyYXRlZFtpbmRleDJdID0gZXJyb3I7XG4gICAgICAgICAgICBzZXQoZXJyb3IpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1BSRVZJT1VTX1JFU09MVkVEOlxuICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBoeWRyYXRlZFtiXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICAgICAgICBjb25zdCB2YWxzID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB2YWxzW2ldO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICAgICh2MikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByW2ldID0gdjI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9zdFJ1bi5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gcGx1Z2luKHZhbHVlWzBdLCAuLi5yKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gcmVzdWx0Mi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgICAgICBoeWRyYXRlZFtpbmRleDJdID0gYXJyYXk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBuID0gdmFsdWVbaV07XG4gICAgICAgICAgaWYgKG4gIT09IEhPTEUpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldChhcnJheSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvYmplY3QgPSB7fTtcbiAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBvYmplY3Q7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkucmV2ZXJzZSgpKSB7XG4gICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgdmFsdWVba2V5XSxcbiAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgclsxXSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICBdKTtcbiAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgTnVtYmVyKGtleS5zbGljZSgxKSksXG4gICAgICAgICAgKGspID0+IHtcbiAgICAgICAgICAgIHJbMF0gPSBrO1xuICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgICAgIHBvc3RSdW4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgb2JqZWN0W3JbMF1dID0gclsxXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzZXQob2JqZWN0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAocG9zdFJ1bi5sZW5ndGggPiAwKSB7XG4gICAgcG9zdFJ1bi5wb3AoKSgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHZlbmRvci90dXJiby1zdHJlYW0tdjIvdHVyYm8tc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBkZWNvZGUocmVhZGFibGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBwbHVnaW5zIH0gPSBvcHRpb25zID8/IHt9O1xuICBjb25zdCBkb25lID0gbmV3IERlZmVycmVkMigpO1xuICBjb25zdCByZWFkZXIgPSByZWFkYWJsZS5waXBlVGhyb3VnaChjcmVhdGVMaW5lU3BsaXR0aW5nVHJhbnNmb3JtKCkpLmdldFJlYWRlcigpO1xuICBjb25zdCBkZWNvZGVyID0ge1xuICAgIHZhbHVlczogW10sXG4gICAgaHlkcmF0ZWQ6IFtdLFxuICAgIGRlZmVycmVkOiB7fSxcbiAgICBwbHVnaW5zXG4gIH07XG4gIGNvbnN0IGRlY29kZWQgPSBhd2FpdCBkZWNvZGVJbml0aWFsLmNhbGwoZGVjb2RlciwgcmVhZGVyKTtcbiAgbGV0IGRvbmVQcm9taXNlID0gZG9uZS5wcm9taXNlO1xuICBpZiAoZGVjb2RlZC5kb25lKSB7XG4gICAgZG9uZS5yZXNvbHZlKCk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZVByb21pc2UgPSBkZWNvZGVEZWZlcnJlZC5jYWxsKGRlY29kZXIsIHJlYWRlcikudGhlbihkb25lLnJlc29sdmUpLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgIGZvciAoY29uc3QgZGVmZXJyZWQgb2YgT2JqZWN0LnZhbHVlcyhkZWNvZGVyLmRlZmVycmVkKSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgIH1cbiAgICAgIGRvbmUucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkb25lOiBkb25lUHJvbWlzZS50aGVuKCgpID0+IHJlYWRlci5jbG9zZWQpLFxuICAgIHZhbHVlOiBkZWNvZGVkLnZhbHVlXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGVJbml0aWFsKHJlYWRlcikge1xuICBjb25zdCByZWFkID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgaWYgKCFyZWFkLnZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gIH1cbiAgbGV0IGxpbmU7XG4gIHRyeSB7XG4gICAgbGluZSA9IEpTT04ucGFyc2UocmVhZC52YWx1ZSk7XG4gIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZG9uZTogcmVhZC5kb25lLFxuICAgIHZhbHVlOiB1bmZsYXR0ZW4uY2FsbCh0aGlzLCBsaW5lKVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlRGVmZXJyZWQocmVhZGVyKSB7XG4gIGxldCByZWFkID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgd2hpbGUgKCFyZWFkLmRvbmUpIHtcbiAgICBpZiAoIXJlYWQudmFsdWUpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGxpbmUgPSByZWFkLnZhbHVlO1xuICAgIHN3aXRjaCAobGluZVswXSkge1xuICAgICAgY2FzZSBUWVBFX1BST01JU0U6IHtcbiAgICAgICAgY29uc3QgY29sb25JbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkSWQgPSBOdW1iZXIobGluZS5zbGljZSgxLCBjb2xvbkluZGV4KSk7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5kZWZlcnJlZFtkZWZlcnJlZElkXTtcbiAgICAgICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVmZXJyZWQgSUQgJHtkZWZlcnJlZElkfSBub3QgZm91bmQgaW4gc3RyZWFtYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZURhdGEgPSBsaW5lLnNsaWNlKGNvbG9uSW5kZXggKyAxKTtcbiAgICAgICAgbGV0IGpzb25MaW5lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGpzb25MaW5lID0gSlNPTi5wYXJzZShsaW5lRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdW5mbGF0dGVuLmNhbGwodGhpcywganNvbkxpbmUpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRZUEVfRVJST1I6IHtcbiAgICAgICAgY29uc3QgY29sb25JbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkSWQgPSBOdW1iZXIobGluZS5zbGljZSgxLCBjb2xvbkluZGV4KSk7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5kZWZlcnJlZFtkZWZlcnJlZElkXTtcbiAgICAgICAgaWYgKCFkZWZlcnJlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVmZXJyZWQgSUQgJHtkZWZlcnJlZElkfSBub3QgZm91bmQgaW4gc3RyZWFtYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZURhdGEgPSBsaW5lLnNsaWNlKGNvbG9uSW5kZXggKyAxKTtcbiAgICAgICAgbGV0IGpzb25MaW5lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGpzb25MaW5lID0gSlNPTi5wYXJzZShsaW5lRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdW5mbGF0dGVuLmNhbGwodGhpcywganNvbkxpbmUpO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgIH1cbiAgICByZWFkID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgcGx1Z2lucywgcG9zdFBsdWdpbnMsIHNpZ25hbCB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgY29uc3QgZW5jb2RlciA9IHtcbiAgICBkZWZlcnJlZDoge30sXG4gICAgaW5kZXg6IDAsXG4gICAgaW5kaWNlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBzdHJpbmdpZmllZDogW10sXG4gICAgcGx1Z2lucyxcbiAgICBwb3N0UGx1Z2lucyxcbiAgICBzaWduYWxcbiAgfTtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGxhc3RTZW50SW5kZXggPSAwO1xuICBjb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgaWQgPSBmbGF0dGVuLmNhbGwoZW5jb2RlciwgaW5wdXQpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZCA8IDApIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShgJHtpZH1cbmApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoYFske2VuY29kZXIuc3RyaW5naWZpZWQuam9pbihcIixcIil9XVxuYClcbiAgICAgICAgKTtcbiAgICAgICAgbGFzdFNlbnRJbmRleCA9IGVuY29kZXIuc3RyaW5naWZpZWQubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlZW5Qcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGVuY29kZXIuZGVmZXJyZWQpLmxlbmd0aCkge1xuICAgICAgICBsZXQgcmFjZURvbmU7XG4gICAgICAgIGNvbnN0IHJhY2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJhY2VEb25lID0gcmVzb2x2ZTtcbiAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBjb25zdCByZWplY3RQcm9taXNlID0gKCkgPT4gcmVqZWN0KHNpZ25hbC5yZWFzb24gfHwgbmV3IEVycm9yKFwiU2lnbmFsIHdhcyBhYm9ydGVkLlwiKSk7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChPYmplY3Qua2V5cyhlbmNvZGVyLmRlZmVycmVkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZGVmZXJyZWRJZCwgZGVmZXJyZWRdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgICAgICAgZW5jb2Rlci5kZWZlcnJlZFxuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIGlmIChzZWVuUHJvbWlzZXMuaGFzKGRlZmVycmVkKSkgY29udGludWU7XG4gICAgICAgICAgICBzZWVuUHJvbWlzZXMuYWRkKFxuICAgICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vQXNzaWduSW5FeHByZXNzaW9uczogPGV4cGxhbmF0aW9uPlxuICAgICAgICAgICAgICBlbmNvZGVyLmRlZmVycmVkW051bWJlcihkZWZlcnJlZElkKV0gPSBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHJhY2VQcm9taXNlLFxuICAgICAgICAgICAgICAgIGRlZmVycmVkXG4gICAgICAgICAgICAgIF0pLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlc29sdmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpZDIgPSBmbGF0dGVuLmNhbGwoZW5jb2RlciwgcmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9QUk9NSVNFfSR7ZGVmZXJyZWRJZH06W1tcIiR7VFlQRV9QUkVWSU9VU19SRVNPTFZFRH1cIiwke2lkMlswXX1dXVxuYFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlkMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfUFJPTUlTRX0ke2RlZmVycmVkSWR9OiR7aWQyfVxuYFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGVuY29kZXIuc3RyaW5naWZpZWQuc2xpY2UobGFzdFNlbnRJbmRleCArIDEpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9QUk9NSVNFfSR7ZGVmZXJyZWRJZH06WyR7dmFsdWVzfV1cbmBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXggPSBlbmNvZGVyLnN0cmluZ2lmaWVkLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXJlYXNvbiB8fCB0eXBlb2YgcmVhc29uICE9PSBcIm9iamVjdFwiIHx8ICEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IG5ldyBFcnJvcihcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBpZDIgPSBmbGF0dGVuLmNhbGwoZW5jb2RlciwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkMikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfRVJST1J9JHtkZWZlcnJlZElkfTpbW1wiJHtUWVBFX1BSRVZJT1VTX1JFU09MVkVEfVwiLCR7aWQyWzBdfV1dXG5gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVyLmluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZW50SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9FUlJPUn0ke2RlZmVycmVkSWR9OiR7aWQyfVxuYFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGVuY29kZXIuc3RyaW5naWZpZWQuc2xpY2UobGFzdFNlbnRJbmRleCArIDEpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9FUlJPUn0ke2RlZmVycmVkSWR9Olske3ZhbHVlc31dXG5gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4ID0gZW5jb2Rlci5zdHJpbmdpZmllZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW5jb2Rlci5kZWZlcnJlZFtOdW1iZXIoZGVmZXJyZWRJZCldO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKE9iamVjdC52YWx1ZXMoZW5jb2Rlci5kZWZlcnJlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJhY2VEb25lKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKGVuY29kZXIuZGVmZXJyZWQpKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVhZGFibGU7XG59XG5cbi8vIGxpYi9kb20vc3NyL2RhdGEudHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpIHtcbiAgbGV0IGluaXQgPSB7IHNpZ25hbDogcmVxdWVzdC5zaWduYWwgfTtcbiAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgaW5pdC5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5oZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSB9O1xuICAgICAgaW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYXdhaXQgcmVxdWVzdC5qc29uKCkpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgJiYgL1xcYnRleHRcXC9wbGFpblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGUgfTtcbiAgICAgIGluaXQuYm9keSA9IGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgaW5pdC5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCByZXF1ZXN0LnRleHQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQuYm9keSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluaXQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL21hcmt1cC50c1xudmFyIEVTQ0FQRV9MT09LVVAgPSB7XG4gIFwiJlwiOiBcIlxcXFx1MDAyNlwiLFxuICBcIj5cIjogXCJcXFxcdTAwM2VcIixcbiAgXCI8XCI6IFwiXFxcXHUwMDNjXCIsXG4gIFwiXFx1MjAyOFwiOiBcIlxcXFx1MjAyOFwiLFxuICBcIlxcdTIwMjlcIjogXCJcXFxcdTIwMjlcIlxufTtcbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cblxuLy8gbGliL2RvbS9zc3IvaW52YXJpYW50LnRzXG5mdW5jdGlvbiBpbnZhcmlhbnQyKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9kb20vc3NyL3NpbmdsZS1mZXRjaC50c3hcbnZhciBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sID0gU3ltYm9sKFwiU2luZ2xlRmV0Y2hSZWRpcmVjdFwiKTtcbnZhciBTaW5nbGVGZXRjaE5vUmVzdWx0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG52YXIgU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyA9IDIwMjtcbnZhciBOT19CT0RZX1NUQVRVU19DT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsxMDAsIDEwMSwgMjA0LCAyMDVdKTtcbmZ1bmN0aW9uIFN0cmVhbVRyYW5zZmVyKHtcbiAgY29udGV4dCxcbiAgaWRlbnRpZmllcixcbiAgcmVhZGVyLFxuICB0ZXh0RGVjb2RlcixcbiAgbm9uY2Vcbn0pIHtcbiAgaWYgKCFjb250ZXh0LnJlbmRlck1ldGEgfHwgIWNvbnRleHQucmVuZGVyTWV0YS5kaWRSZW5kZXJTY3JpcHRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFjb250ZXh0LnJlbmRlck1ldGEuc3RyZWFtQ2FjaGUpIHtcbiAgICBjb250ZXh0LnJlbmRlck1ldGEuc3RyZWFtQ2FjaGUgPSB7fTtcbiAgfVxuICBsZXQgeyBzdHJlYW1DYWNoZSB9ID0gY29udGV4dC5yZW5kZXJNZXRhO1xuICBsZXQgcHJvbWlzZSA9IHN0cmVhbUNhY2hlW2lkZW50aWZpZXJdO1xuICBpZiAoIXByb21pc2UpIHtcbiAgICBwcm9taXNlID0gc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0gPSByZWFkZXIucmVhZCgpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0ucmVzdWx0ID0ge1xuICAgICAgICBkb25lOiByZXN1bHQuZG9uZSxcbiAgICAgICAgdmFsdWU6IHRleHREZWNvZGVyLmRlY29kZShyZXN1bHQudmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICB9O1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXS5lcnJvciA9IGU7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21pc2UuZXJyb3IpIHtcbiAgICB0aHJvdyBwcm9taXNlLmVycm9yO1xuICB9XG4gIGlmIChwcm9taXNlLnJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxuICBsZXQgeyBkb25lLCB2YWx1ZSB9ID0gcHJvbWlzZS5yZXN1bHQ7XG4gIGxldCBzY3JpcHRUYWcgPSB2YWx1ZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIG5vbmNlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSgke2VzY2FwZUh0bWwoXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgICAgICl9KTtgXG4gICAgICB9XG4gICAgfVxuICApIDogbnVsbDtcbiAgaWYgKGRvbmUpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJlYWN0NC5GcmFnbWVudCwgbnVsbCwgc2NyaXB0VGFnLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICBfX2h0bWw6IGB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO2BcbiAgICAgICAgfVxuICAgICAgfVxuICAgICkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUmVhY3Q0LkZyYWdtZW50LCBudWxsLCBzY3JpcHRUYWcsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSZWFjdDQuU3VzcGVuc2UsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0cmVhbVRyYW5zZmVyLFxuICAgICAge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyICsgMSxcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICB0ZXh0RGVjb2RlcixcbiAgICAgICAgbm9uY2VcbiAgICAgIH1cbiAgICApKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3koZ2V0Um91dGVyLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBzc3IsIGJhc2VuYW1lKSB7XG4gIGxldCBkYXRhU3RyYXRlZ3kgPSBnZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneUltcGwoXG4gICAgZ2V0Um91dGVyLFxuICAgIChtYXRjaCkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaW52YXJpYW50MihtYW5pZmVzdFJvdXRlLCBcIlJvdXRlIG5vdCBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNMb2FkZXI6IG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyLFxuICAgICAgICBoYXNDbGllbnRMb2FkZXI6IG1hbmlmZXN0Um91dGUuaGFzQ2xpZW50TG9hZGVyLFxuICAgICAgICBoYXNTaG91bGRSZXZhbGlkYXRlOiBCb29sZWFuKHJvdXRlTW9kdWxlPy5zaG91bGRSZXZhbGlkYXRlKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGZldGNoQW5kRGVjb2RlVmlhVHVyYm9TdHJlYW0sXG4gICAgc3NyLFxuICAgIGJhc2VuYW1lXG4gICk7XG4gIHJldHVybiBhc3luYyAoYXJncykgPT4gYXJncy5ydW5DbGllbnRNaWRkbGV3YXJlKGRhdGFTdHJhdGVneSk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVGZXRjaERhdGFTdHJhdGVneUltcGwoZ2V0Um91dGVyLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBzc3IsIGJhc2VuYW1lLCBzaG91bGRBbGxvd09wdE91dCA9ICgpID0+IHRydWUpIHtcbiAgcmV0dXJuIGFzeW5jIChhcmdzKSA9PiB7XG4gICAgbGV0IHsgcmVxdWVzdCwgbWF0Y2hlcywgZmV0Y2hlcktleSB9ID0gYXJncztcbiAgICBsZXQgcm91dGVyID0gZ2V0Um91dGVyKCk7XG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgICByZXR1cm4gc2luZ2xlRmV0Y2hBY3Rpb25TdHJhdGVneShhcmdzLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpO1xuICAgIH1cbiAgICBsZXQgZm91bmRSZXZhbGlkYXRpbmdTZXJ2ZXJMb2FkZXIgPSBtYXRjaGVzLnNvbWUoKG0pID0+IHtcbiAgICAgIGxldCB7IGhhc0xvYWRlciwgaGFzQ2xpZW50TG9hZGVyIH0gPSBnZXRSb3V0ZUluZm8obSk7XG4gICAgICByZXR1cm4gbS51bnN0YWJsZV9zaG91bGRDYWxsSGFuZGxlcigpICYmIGhhc0xvYWRlciAmJiAhaGFzQ2xpZW50TG9hZGVyO1xuICAgIH0pO1xuICAgIGlmICghc3NyICYmICFmb3VuZFJldmFsaWRhdGluZ1NlcnZlckxvYWRlcikge1xuICAgICAgcmV0dXJuIG5vblNzclN0cmF0ZWd5KGFyZ3MsIGdldFJvdXRlSW5mbywgZmV0Y2hBbmREZWNvZGUsIGJhc2VuYW1lKTtcbiAgICB9XG4gICAgaWYgKGZldGNoZXJLZXkpIHtcbiAgICAgIHJldHVybiBzaW5nbGVGZXRjaExvYWRlckZldGNoZXJTdHJhdGVneShhcmdzLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xlRmV0Y2hMb2FkZXJOYXZpZ2F0aW9uU3RyYXRlZ3koXG4gICAgICBhcmdzLFxuICAgICAgcm91dGVyLFxuICAgICAgZ2V0Um91dGVJbmZvLFxuICAgICAgZmV0Y2hBbmREZWNvZGUsXG4gICAgICBzc3IsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHNob3VsZEFsbG93T3B0T3V0XG4gICAgKTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoQWN0aW9uU3RyYXRlZ3koYXJncywgZmV0Y2hBbmREZWNvZGUsIGJhc2VuYW1lKSB7XG4gIGxldCBhY3Rpb25NYXRjaCA9IGFyZ3MubWF0Y2hlcy5maW5kKChtKSA9PiBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKCkpO1xuICBpbnZhcmlhbnQyKGFjdGlvbk1hdGNoLCBcIk5vIGFjdGlvbiBtYXRjaCBmb3VuZFwiKTtcbiAgbGV0IGFjdGlvblN0YXR1cyA9IHZvaWQgMDtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbk1hdGNoLnJlc29sdmUoYXN5bmMgKGhhbmRsZXIpID0+IHtcbiAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHsgZGF0YTogZGF0YTIsIHN0YXR1cyB9ID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUoYXJncywgYmFzZW5hbWUsIFtcbiAgICAgICAgYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgIF0pO1xuICAgICAgYWN0aW9uU3RhdHVzID0gc3RhdHVzO1xuICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH0pO1xuICBpZiAoaXNSZXNwb25zZShyZXN1bHQucmVzdWx0KSB8fCBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQucmVzdWx0KSB8fCBpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdC5yZXN1bHQpKSB7XG4gICAgcmV0dXJuIHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0IH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiB7XG4gICAgICB0eXBlOiByZXN1bHQudHlwZSxcbiAgICAgIHJlc3VsdDogZGF0YShyZXN1bHQucmVzdWx0LCBhY3Rpb25TdGF0dXMpXG4gICAgfVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbm9uU3NyU3RyYXRlZ3koYXJncywgZ2V0Um91dGVJbmZvLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpIHtcbiAgbGV0IG1hdGNoZXNUb0xvYWQgPSBhcmdzLm1hdGNoZXMuZmlsdGVyKFxuICAgIChtKSA9PiBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKClcbiAgKTtcbiAgbGV0IHJlc3VsdHMgPSB7fTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbWF0Y2hlc1RvTG9hZC5tYXAoXG4gICAgICAobSkgPT4gbS5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHsgaGFzQ2xpZW50TG9hZGVyIH0gPSBnZXRSb3V0ZUluZm8obSk7XG4gICAgICAgICAgbGV0IHJvdXRlSWQgPSBtLnJvdXRlLmlkO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBoYXNDbGllbnRMb2FkZXIgPyBhd2FpdCBoYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRhdGE6IGRhdGEyIH0gPSBhd2FpdCBmZXRjaEFuZERlY29kZShhcmdzLCBiYXNlbmFtZSwgW3JvdXRlSWRdKTtcbiAgICAgICAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChkYXRhMiwgcm91dGVJZCk7XG4gICAgICAgICAgfSkgOiBhd2FpdCBoYW5kbGVyKCk7XG4gICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdCB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGUgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gICk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hMb2FkZXJOYXZpZ2F0aW9uU3RyYXRlZ3koYXJncywgcm91dGVyLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBzc3IsIGJhc2VuYW1lLCBzaG91bGRBbGxvd09wdE91dCA9ICgpID0+IHRydWUpIHtcbiAgbGV0IHJvdXRlc1BhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gIGxldCByb3V0ZURmZHMgPSBhcmdzLm1hdGNoZXMubWFwKCgpID0+IGNyZWF0ZURlZmVycmVkMigpKTtcbiAgbGV0IHNpbmdsZUZldGNoRGZkID0gY3JlYXRlRGVmZXJyZWQyKCk7XG4gIGxldCByZXN1bHRzID0ge307XG4gIGxldCByZXNvbHZlUHJvbWlzZSA9IFByb21pc2UuYWxsKFxuICAgIGFyZ3MubWF0Y2hlcy5tYXAoXG4gICAgICBhc3luYyAobSwgaSkgPT4gbS5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHJvdXRlRGZkc1tpXS5yZXNvbHZlKCk7XG4gICAgICAgIGxldCByb3V0ZUlkID0gbS5yb3V0ZS5pZDtcbiAgICAgICAgbGV0IHsgaGFzTG9hZGVyLCBoYXNDbGllbnRMb2FkZXIsIGhhc1Nob3VsZFJldmFsaWRhdGUgfSA9IGdldFJvdXRlSW5mbyhtKTtcbiAgICAgICAgbGV0IGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlID0gIW0udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgfHwgbS51bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncy5hY3Rpb25TdGF0dXMgPT0gbnVsbCB8fCBtLnVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzLmFjdGlvblN0YXR1cyA8IDQwMDtcbiAgICAgICAgbGV0IHNob3VsZENhbGwgPSBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlKTtcbiAgICAgICAgaWYgKCFzaG91bGRDYWxsKSB7XG4gICAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSB8fCAoZm91bmRPcHRPdXRSb3V0ZSA9IG0udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgIT0gbnVsbCAmJiAvLyBUaGlzIGlzIGEgcmV2YWxpZGF0aW9uLFxuICAgICAgICAgIGhhc0xvYWRlciAmJiAvLyBmb3IgYSByb3V0ZSB3aXRoIGEgc2VydmVyIGxvYWRlcixcbiAgICAgICAgICBoYXNTaG91bGRSZXZhbGlkYXRlID09PSB0cnVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZEFsbG93T3B0T3V0KG0pICYmIGhhc0NsaWVudExvYWRlcikge1xuICAgICAgICAgIGlmIChoYXNMb2FkZXIpIHtcbiAgICAgICAgICAgIGZvdW5kT3B0T3V0Um91dGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgeyBkYXRhOiBkYXRhMiB9ID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUoYXJncywgYmFzZW5hbWUsIFtyb3V0ZUlkXSk7XG4gICAgICAgICAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChkYXRhMiwgcm91dGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdHNbcm91dGVJZF0gPSB7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQgfTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xvYWRlcikge1xuICAgICAgICAgIHJvdXRlc1BhcmFtcy5hZGQocm91dGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YTIgPSBhd2FpdCBzaW5nbGVGZXRjaERmZC5wcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCByb3V0ZUlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0IH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwocm91dGVEZmRzLm1hcCgoZCkgPT4gZC5wcm9taXNlKSk7XG4gIGxldCBpc0luaXRpYWxMb2FkID0gIXJvdXRlci5zdGF0ZS5pbml0aWFsaXplZCAmJiByb3V0ZXIuc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCI7XG4gIGlmICgoaXNJbml0aWFsTG9hZCB8fCByb3V0ZXNQYXJhbXMuc2l6ZSA9PT0gMCkgJiYgIXdpbmRvdy5fX3JlYWN0Um91dGVySGRyQWN0aXZlKSB7XG4gICAgc2luZ2xlRmV0Y2hEZmQucmVzb2x2ZSh7IHJvdXRlczoge30gfSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHRhcmdldFJvdXRlcyA9IHNzciAmJiBmb3VuZE9wdE91dFJvdXRlICYmIHJvdXRlc1BhcmFtcy5zaXplID4gMCA/IFsuLi5yb3V0ZXNQYXJhbXMua2V5cygpXSA6IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgbGV0IGRhdGEyID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUoYXJncywgYmFzZW5hbWUsIHRhcmdldFJvdXRlcyk7XG4gICAgICBzaW5nbGVGZXRjaERmZC5yZXNvbHZlKGRhdGEyLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNpbmdsZUZldGNoRGZkLnJlamVjdChlKTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgcmVzb2x2ZVByb21pc2U7XG4gIGF3YWl0IGJ1YmJsZU1pZGRsZXdhcmVFcnJvcnMoXG4gICAgc2luZ2xlRmV0Y2hEZmQucHJvbWlzZSxcbiAgICBhcmdzLm1hdGNoZXMsXG4gICAgcm91dGVzUGFyYW1zLFxuICAgIHJlc3VsdHNcbiAgKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBidWJibGVNaWRkbGV3YXJlRXJyb3JzKHNpbmdsZUZldGNoUHJvbWlzZSwgbWF0Y2hlcywgcm91dGVzUGFyYW1zLCByZXN1bHRzKSB7XG4gIHRyeSB7XG4gICAgbGV0IG1pZGRsZXdhcmVFcnJvcjtcbiAgICBsZXQgZmV0Y2hlZERhdGEgPSBhd2FpdCBzaW5nbGVGZXRjaFByb21pc2U7XG4gICAgaWYgKFwicm91dGVzXCIgaW4gZmV0Y2hlZERhdGEpIHtcbiAgICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkIGluIGZldGNoZWREYXRhLnJvdXRlcykge1xuICAgICAgICAgIGxldCByb3V0ZVJlc3VsdCA9IGZldGNoZWREYXRhLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByb3V0ZVJlc3VsdCkge1xuICAgICAgICAgICAgbWlkZGxld2FyZUVycm9yID0gcm91dGVSZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICBpZiAocmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF0/LnJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHNbbWF0Y2gucm91dGUuaWRdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICByZXN1bHQ6IG1pZGRsZXdhcmVFcnJvclxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaWRkbGV3YXJlRXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgQXJyYXkuZnJvbShyb3V0ZXNQYXJhbXMudmFsdWVzKCkpLmZvckVhY2goKHJvdXRlSWQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdHNbcm91dGVJZF0ucmVzdWx0IGluc3RhbmNlb2YgU2luZ2xlRmV0Y2hOb1Jlc3VsdEVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0c1tyb3V0ZUlkXS5yZXN1bHQgPSBtaWRkbGV3YXJlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaExvYWRlckZldGNoZXJTdHJhdGVneShhcmdzLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpIHtcbiAgbGV0IGZldGNoZXJNYXRjaCA9IGFyZ3MubWF0Y2hlcy5maW5kKChtKSA9PiBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKCkpO1xuICBpbnZhcmlhbnQyKGZldGNoZXJNYXRjaCwgXCJObyBmZXRjaGVyIG1hdGNoIGZvdW5kXCIpO1xuICBsZXQgcm91dGVJZCA9IGZldGNoZXJNYXRjaC5yb3V0ZS5pZDtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoZXJNYXRjaC5yZXNvbHZlKFxuICAgIGFzeW5jIChoYW5kbGVyKSA9PiBoYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB7IGRhdGE6IGRhdGEyIH0gPSBhd2FpdCBmZXRjaEFuZERlY29kZShhcmdzLCBiYXNlbmFtZSwgW3JvdXRlSWRdKTtcbiAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChkYXRhMiwgcm91dGVJZCk7XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIHsgW2ZldGNoZXJNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdCB9O1xufVxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtKHVybCkge1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB0b0tlZXAgb2YgaW5kZXhWYWx1ZXNUb0tlZXApIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHRvS2VlcCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIHNpbmdsZUZldGNoVXJsKHJlcVVybCwgYmFzZW5hbWUsIGV4dGVuc2lvbikge1xuICBsZXQgdXJsID0gdHlwZW9mIHJlcVVybCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBVUkwoXG4gICAgcmVxVXJsLFxuICAgIC8vIFRoaXMgY2FuIGJlIGNhbGxlZCBkdXJpbmcgdGhlIFNTUiBmbG93IHZpYSBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwgc29cbiAgICAvLyBkb24ndCBhc3N1bWUgd2luZG93IGlzIGF2YWlsYWJsZVxuICAgIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInNlcnZlcjovL3NpbmdsZWZldGNoL1wiIDogd2luZG93LmxvY2F0aW9uLm9yaWdpblxuICApIDogcmVxVXJsO1xuICBpZiAodXJsLnBhdGhuYW1lID09PSBcIi9cIikge1xuICAgIHVybC5wYXRobmFtZSA9IGBfcm9vdC4ke2V4dGVuc2lvbn1gO1xuICB9IGVsc2UgaWYgKGJhc2VuYW1lICYmIHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgPT09IFwiL1wiKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gYCR7YmFzZW5hbWUucmVwbGFjZSgvXFwvJC8sIFwiXCIpfS9fcm9vdC4ke2V4dGVuc2lvbn1gO1xuICB9IGVsc2Uge1xuICAgIHVybC5wYXRobmFtZSA9IGAke3VybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8kLywgXCJcIil9LiR7ZXh0ZW5zaW9ufWA7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kRGVjb2RlVmlhVHVyYm9TdHJlYW0oYXJncywgYmFzZW5hbWUsIHRhcmdldFJvdXRlcykge1xuICBsZXQgeyByZXF1ZXN0IH0gPSBhcmdzO1xuICBsZXQgdXJsID0gc2luZ2xlRmV0Y2hVcmwocmVxdWVzdC51cmwsIGJhc2VuYW1lLCBcImRhdGFcIik7XG4gIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgIHVybCA9IHN0cmlwSW5kZXhQYXJhbSh1cmwpO1xuICAgIGlmICh0YXJnZXRSb3V0ZXMpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiX3JvdXRlc1wiLCB0YXJnZXRSb3V0ZXMuam9pbihcIixcIikpO1xuICAgIH1cbiAgfVxuICBsZXQgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBhd2FpdCBjcmVhdGVSZXF1ZXN0SW5pdChyZXF1ZXN0KSk7XG4gIGlmIChyZXMuc3RhdHVzID49IDQwMCAmJiAhcmVzLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXNwb25zZVwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbChyZXMuc3RhdHVzLCByZXMuc3RhdHVzVGV4dCwgYXdhaXQgcmVzLnRleHQoKSk7XG4gIH1cbiAgaWYgKHJlcy5zdGF0dXMgPT09IDIwNCAmJiByZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlZGlyZWN0XCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVUyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVkaXJlY3Q6IHtcbiAgICAgICAgICByZWRpcmVjdDogcmVzLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiKSxcbiAgICAgICAgICBzdGF0dXM6IE51bWJlcihyZXMuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVN0YXR1c1wiKSB8fCBcIjMwMlwiKSxcbiAgICAgICAgICByZXZhbGlkYXRlOiByZXMuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJldmFsaWRhdGVcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgIHJlbG9hZDogcmVzLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgICAgIHJlcGxhY2U6IHJlcy5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVwbGFjZVwiKSA9PT0gXCJ0cnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaWYgKE5PX0JPRFlfU1RBVFVTX0NPREVTLmhhcyhyZXMuc3RhdHVzKSkge1xuICAgIGxldCByb3V0ZXMgPSB7fTtcbiAgICBpZiAodGFyZ2V0Um91dGVzICYmIHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgICByb3V0ZXNbdGFyZ2V0Um91dGVzWzBdXSA9IHsgZGF0YTogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICBkYXRhOiB7IHJvdXRlcyB9XG4gICAgfTtcbiAgfVxuICBpbnZhcmlhbnQyKHJlcy5ib2R5LCBcIk5vIHJlc3BvbnNlIGJvZHkgdG8gZGVjb2RlXCIpO1xuICB0cnkge1xuICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlVmlhVHVyYm9TdHJlYW0ocmVzLmJvZHksIHdpbmRvdyk7XG4gICAgbGV0IGRhdGEyO1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgbGV0IHR5cGVkID0gZGVjb2RlZC52YWx1ZTtcbiAgICAgIGlmIChTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIHR5cGVkKSB7XG4gICAgICAgIGRhdGEyID0geyByZWRpcmVjdDogdHlwZWRbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF0gfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEyID0geyByb3V0ZXM6IHR5cGVkIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0eXBlZCA9IGRlY29kZWQudmFsdWU7XG4gICAgICBsZXQgcm91dGVJZCA9IHRhcmdldFJvdXRlcz8uWzBdO1xuICAgICAgaW52YXJpYW50Mihyb3V0ZUlkLCBcIk5vIHJvdXRlSWQgZm91bmQgZm9yIHNpbmdsZSBmZXRjaCBjYWxsIGRlY29kaW5nXCIpO1xuICAgICAgaWYgKFwicmVkaXJlY3RcIiBpbiB0eXBlZCkge1xuICAgICAgICBkYXRhMiA9IHsgcmVkaXJlY3Q6IHR5cGVkIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhMiA9IHsgcm91dGVzOiB7IFtyb3V0ZUlkXTogdHlwZWQgfSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGE6IGRhdGEyIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIHR1cmJvLXN0cmVhbSByZXNwb25zZVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb2RlVmlhVHVyYm9TdHJlYW0oYm9keSwgZ2xvYmFsKSB7XG4gIHJldHVybiBkZWNvZGUoYm9keSwge1xuICAgIHBsdWdpbnM6IFtcbiAgICAgICh0eXBlLCAuLi5yZXN0KSA9PiB7XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNhbml0aXplZEVycm9yXCIpIHtcbiAgICAgICAgICBsZXQgW25hbWUsIG1lc3NhZ2UsIHN0YWNrXSA9IHJlc3Q7XG4gICAgICAgICAgbGV0IENvbnN0cnVjdG9yID0gRXJyb3I7XG4gICAgICAgICAgaWYgKG5hbWUgJiYgbmFtZSBpbiBnbG9iYWwgJiYgdHlwZW9mIGdsb2JhbFtuYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IGdsb2JhbFtuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGVycm9yID0gbmV3IENvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2s7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiRXJyb3JSZXNwb25zZVwiKSB7XG4gICAgICAgICAgbGV0IFtkYXRhMiwgc3RhdHVzLCBzdGF0dXNUZXh0XSA9IHJlc3Q7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzLCBzdGF0dXNUZXh0LCBkYXRhMilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNpbmdsZUZldGNoUmVkaXJlY3RcIikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB7IFtTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTogcmVzdFswXSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiU2luZ2xlRmV0Y2hDbGFzc0luc3RhbmNlXCIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogcmVzdFswXSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcIlNpbmdsZUZldGNoRmFsbGJhY2tcIikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF1cbiAgfSk7XG59XG5mdW5jdGlvbiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChyZXN1bHQsIHJvdXRlSWQpIHtcbiAgaWYgKFwicmVkaXJlY3RcIiBpbiByZXN1bHQpIHtcbiAgICBsZXQge1xuICAgICAgcmVkaXJlY3Q6IGxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgIHJlbG9hZCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgICAgc3RhdHVzXG4gICAgfSA9IHJlc3VsdC5yZWRpcmVjdDtcbiAgICB0aHJvdyByZWRpcmVjdChsb2NhdGlvbiwge1xuICAgICAgc3RhdHVzLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyBUaHJlZSBSJ3Mgb2YgcmVkaXJlY3RpbmcgKGxvbCBWZWVwKVxuICAgICAgICAuLi5yZXZhbGlkYXRlID8geyBcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiOiBcInllc1wiIH0gOiBudWxsLFxuICAgICAgICAuLi5yZWxvYWQgPyB7IFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIjogXCJ5ZXNcIiB9IDogbnVsbCxcbiAgICAgICAgLi4ucmVwbGFjZTIgPyB7IFwiWC1SZW1peC1SZXBsYWNlXCI6IFwieWVzXCIgfSA6IG51bGxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgcm91dGVSZXN1bHQgPSByZXN1bHQucm91dGVzW3JvdXRlSWRdO1xuICBpZiAocm91dGVSZXN1bHQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBTaW5nbGVGZXRjaE5vUmVzdWx0RXJyb3IoXG4gICAgICBgTm8gcmVzdWx0IGZvdW5kIGZvciByb3V0ZUlkIFwiJHtyb3V0ZUlkfVwiYFxuICAgICk7XG4gIH0gZWxzZSBpZiAoXCJlcnJvclwiIGluIHJvdXRlUmVzdWx0KSB7XG4gICAgdGhyb3cgcm91dGVSZXN1bHQuZXJyb3I7XG4gIH0gZWxzZSBpZiAoXCJkYXRhXCIgaW4gcm91dGVSZXN1bHQpIHtcbiAgICByZXR1cm4gcm91dGVSZXN1bHQuZGF0YTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgZm91bmQgZm9yIHJvdXRlSWQgXCIke3JvdXRlSWR9XCJgKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWQyKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgICAgcmVzKHZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gICAgcmVqZWN0ID0gYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICByZWooZXJyb3IpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlc29sdmUsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIGxpYi9kb20vc3NyL2Vycm9yQm91bmRhcmllcy50c3hcbmltcG9ydCAqIGFzIFJlYWN0OSBmcm9tIFwicmVhY3RcIjtcblxuLy8gbGliL2RvbS9zc3IvY29tcG9uZW50cy50c3hcbmltcG9ydCAqIGFzIFJlYWN0OCBmcm9tIFwicmVhY3RcIjtcblxuLy8gbGliL2RvbS9zc3Ivcm91dGVNb2R1bGVzLnRzXG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gIGlmIChyb3V0ZS5pZCBpbiByb3V0ZU1vZHVsZXNDYWNoZSkge1xuICAgIHJldHVybiByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF07XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSBhd2FpdCBpbXBvcnQoXG4gICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgIHJvdXRlLm1vZHVsZVxuICAgICk7XG4gICAgcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdID0gcm91dGVNb2R1bGU7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgRXJyb3IgbG9hZGluZyByb3V0ZSBtb2R1bGUgXFxgJHtyb3V0ZS5tb2R1bGV9XFxgLCByZWxvYWRpbmcgcGFnZS4uLmBcbiAgICApO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIGlmICh3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQgJiYgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LmlzU3BhTW9kZSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaW1wb3J0Lm1ldGEuaG90KSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gbGliL2RvbS9zc3IvbGlua3MudHNcbmZ1bmN0aW9uIGdldEtleWVkTGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpIHtcbiAgbGV0IGRlc2NyaXB0b3JzID0gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgbGV0IG1vZHVsZSA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICByZXR1cm4gW1xuICAgICAgcm91dGUgJiYgcm91dGUuY3NzID8gcm91dGUuY3NzLm1hcCgoaHJlZikgPT4gKHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZiB9KSkgOiBbXSxcbiAgICAgIG1vZHVsZT8ubGlua3M/LigpIHx8IFtdXG4gICAgXTtcbiAgfSkuZmxhdCgyKTtcbiAgbGV0IHByZWxvYWRzID0gZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0KTtcbiAgcmV0dXJuIGRlZHVwZUxpbmtEZXNjcmlwdG9ycyhkZXNjcmlwdG9ycywgcHJlbG9hZHMpO1xufVxuZnVuY3Rpb24gZ2V0Um91dGVDc3NEZXNjcmlwdG9ycyhyb3V0ZSkge1xuICBpZiAoIXJvdXRlLmNzcykgcmV0dXJuIFtdO1xuICByZXR1cm4gcm91dGUuY3NzLm1hcCgoaHJlZikgPT4gKHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZiB9KSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFJvdXRlQ3NzKHJvdXRlKSB7XG4gIGlmICghcm91dGUuY3NzKSByZXR1cm47XG4gIGxldCBkZXNjcmlwdG9ycyA9IGdldFJvdXRlQ3NzRGVzY3JpcHRvcnMocm91dGUpO1xuICBhd2FpdCBQcm9taXNlLmFsbChkZXNjcmlwdG9ycy5tYXAocHJlZmV0Y2hTdHlsZUxpbmspKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGUpIHtcbiAgaWYgKCFyb3V0ZS5jc3MgJiYgIXJvdXRlTW9kdWxlLmxpbmtzIHx8ICFpc1ByZWxvYWRTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICBsZXQgZGVzY3JpcHRvcnMgPSBbXTtcbiAgaWYgKHJvdXRlLmNzcykge1xuICAgIGRlc2NyaXB0b3JzLnB1c2goLi4uZ2V0Um91dGVDc3NEZXNjcmlwdG9ycyhyb3V0ZSkpO1xuICB9XG4gIGlmIChyb3V0ZU1vZHVsZS5saW5rcykge1xuICAgIGRlc2NyaXB0b3JzLnB1c2goLi4ucm91dGVNb2R1bGUubGlua3MoKSk7XG4gIH1cbiAgaWYgKGRlc2NyaXB0b3JzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBsZXQgc3R5bGVMaW5rcyA9IFtdO1xuICBmb3IgKGxldCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKCFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIpIHtcbiAgICAgIHN0eWxlTGlua3MucHVzaCh7XG4gICAgICAgIC4uLmRlc2NyaXB0b3IsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhd2FpdCBQcm9taXNlLmFsbChzdHlsZUxpbmtzLm1hcChwcmVmZXRjaFN0eWxlTGluaykpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmsoZGVzY3JpcHRvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBpZiAoZGVzY3JpcHRvci5tZWRpYSAmJiAhd2luZG93Lm1hdGNoTWVkaWEoZGVzY3JpcHRvci5tZWRpYSkubWF0Y2hlcyB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgYGxpbmtbcmVsPVwic3R5bGVzaGVldFwiXVtocmVmPVwiJHtkZXNjcmlwdG9yLmhyZWZ9XCJdYFxuICAgICkpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfVxuICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgT2JqZWN0LmFzc2lnbihsaW5rLCBkZXNjcmlwdG9yKTtcbiAgICBmdW5jdGlvbiByZW1vdmVMaW5rKCkge1xuICAgICAgaWYgKGRvY3VtZW50LmhlYWQuY29udGFpbnMobGluaykpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGluay5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBsaW5rLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzUGFnZUxpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5wYWdlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNIdG1sTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqZWN0LmhyZWYgPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmplY3QucmVsID09PSBcInByZWxvYWRcIiAmJiB0eXBlb2Ygb2JqZWN0LmltYWdlU3JjU2V0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuaW1hZ2VTaXplcyA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICByZXR1cm4gdHlwZW9mIG9iamVjdC5yZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5ocmVmID09PSBcInN0cmluZ1wiO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0S2V5ZWRQcmVmZXRjaExpbmtzKG1hdGNoZXMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IGxpbmtzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbWF0Y2hlcy5tYXAoYXN5bmMgKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgIGxldCBtb2QgPSBhd2FpdCBsb2FkUm91dGVNb2R1bGUocm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gICAgICAgIHJldHVybiBtb2QubGlua3MgPyBtb2QubGlua3MoKSA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoXG4gICAgbGlua3MuZmxhdCgxKS5maWx0ZXIoaXNIdG1sTGlua0Rlc2NyaXB0b3IpLmZpbHRlcigobGluaykgPT4gbGluay5yZWwgPT09IFwic3R5bGVzaGVldFwiIHx8IGxpbmsucmVsID09PSBcInByZWxvYWRcIikubWFwKFxuICAgICAgKGxpbmspID0+IGxpbmsucmVsID09PSBcInN0eWxlc2hlZXRcIiA/IHsgLi4ubGluaywgcmVsOiBcInByZWZldGNoXCIsIGFzOiBcInN0eWxlXCIgfSA6IHsgLi4ubGluaywgcmVsOiBcInByZWZldGNoXCIgfVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgY3VycmVudE1hdGNoZXMsIG1hbmlmZXN0LCBsb2NhdGlvbiwgbW9kZSkge1xuICBsZXQgaXNOZXcgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFjdXJyZW50TWF0Y2hlc1tpbmRleF0pIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoZXNbaW5kZXhdLnJvdXRlLmlkO1xuICB9O1xuICBsZXQgbWF0Y2hQYXRoQ2hhbmdlZCA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gcGFyYW0gY2hhbmdlLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICAgIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgICBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUucGF0aD8uZW5kc1dpdGgoXCIqXCIpICYmIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICAgKTtcbiAgfTtcbiAgaWYgKG1vZGUgPT09IFwiYXNzZXRzXCIpIHtcbiAgICByZXR1cm4gbmV4dE1hdGNoZXMuZmlsdGVyKFxuICAgICAgKG1hdGNoLCBpbmRleCkgPT4gaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleClcbiAgICApO1xuICB9XG4gIGlmIChtb2RlID09PSBcImRhdGFcIikge1xuICAgIHJldHVybiBuZXh0TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFtYW5pZmVzdFJvdXRlIHx8ICFtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICBsZXQgcm91dGVDaG9pY2UgPSBtYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKHtcbiAgICAgICAgICBjdXJyZW50VXJsOiBuZXcgVVJMKFxuICAgICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoLFxuICAgICAgICAgICAgd2luZG93Lm9yaWdpblxuICAgICAgICAgICksXG4gICAgICAgICAgY3VycmVudFBhcmFtczogY3VycmVudE1hdGNoZXNbMF0/LnBhcmFtcyB8fCB7fSxcbiAgICAgICAgICBuZXh0VXJsOiBuZXcgVVJMKHBhZ2UsIHdpbmRvdy5vcmlnaW4pLFxuICAgICAgICAgIG5leHRQYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGdldE1vZHVsZUxpbmtIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCwgeyBpbmNsdWRlSHlkcmF0ZUZhbGxiYWNrIH0gPSB7fSkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMoXG4gICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIFtdO1xuICAgICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG4gICAgICBpZiAocm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmNsaWVudEFjdGlvbk1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAocm91dGUuY2xpZW50TG9hZGVyTW9kdWxlKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmNsaWVudExvYWRlck1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZUh5ZHJhdGVGYWxsYmFjayAmJiByb3V0ZS5oeWRyYXRlRmFsbGJhY2tNb2R1bGUpIHtcbiAgICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaHlkcmF0ZUZhbGxiYWNrTW9kdWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3V0ZS5pbXBvcnRzKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhyZWZzO1xuICAgIH0pLmZsYXQoMSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZUhyZWZzKGhyZWZzKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChocmVmcyldO1xufVxuZnVuY3Rpb24gc29ydEtleXMob2JqKSB7XG4gIGxldCBzb3J0ZWQgPSB7fTtcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKTtcbiAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICBzb3J0ZWRba2V5XSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBzb3J0ZWQ7XG59XG5mdW5jdGlvbiBkZWR1cGVMaW5rRGVzY3JpcHRvcnMoZGVzY3JpcHRvcnMsIHByZWxvYWRzKSB7XG4gIGxldCBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgcHJlbG9hZHNTZXQgPSBuZXcgU2V0KHByZWxvYWRzKTtcbiAgcmV0dXJuIGRlc2NyaXB0b3JzLnJlZHVjZSgoZGVkdXBlZCwgZGVzY3JpcHRvcikgPT4ge1xuICAgIGxldCBhbHJlYWR5TW9kdWxlUHJlbG9hZCA9IHByZWxvYWRzICYmICFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLmFzID09PSBcInNjcmlwdFwiICYmIGRlc2NyaXB0b3IuaHJlZiAmJiBwcmVsb2Fkc1NldC5oYXMoZGVzY3JpcHRvci5ocmVmKTtcbiAgICBpZiAoYWxyZWFkeU1vZHVsZVByZWxvYWQpIHtcbiAgICAgIHJldHVybiBkZWR1cGVkO1xuICAgIH1cbiAgICBsZXQga2V5ID0gSlNPTi5zdHJpbmdpZnkoc29ydEtleXMoZGVzY3JpcHRvcikpO1xuICAgIGlmICghc2V0LmhhcyhrZXkpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgICBkZWR1cGVkLnB1c2goeyBrZXksIGxpbms6IGRlc2NyaXB0b3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWR1cGVkO1xuICB9LCBbXSk7XG59XG52YXIgX2lzUHJlbG9hZFN1cHBvcnRlZDtcbmZ1bmN0aW9uIGlzUHJlbG9hZFN1cHBvcnRlZCgpIHtcbiAgaWYgKF9pc1ByZWxvYWRTdXBwb3J0ZWQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBfaXNQcmVsb2FkU3VwcG9ydGVkO1xuICB9XG4gIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICBfaXNQcmVsb2FkU3VwcG9ydGVkID0gZWwucmVsTGlzdC5zdXBwb3J0cyhcInByZWxvYWRcIik7XG4gIGVsID0gbnVsbDtcbiAgcmV0dXJuIF9pc1ByZWxvYWRTdXBwb3J0ZWQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL2ZvZy1vZi13YXIudHNcbmltcG9ydCAqIGFzIFJlYWN0NyBmcm9tIFwicmVhY3RcIjtcblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3Q2IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBsaWIvZG9tL3Nzci9mYWxsYmFjay50c3hcbmltcG9ydCAqIGFzIFJlYWN0NSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRIeWRyYXRlRmFsbGJhY2soKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoQm91bmRhcnlTaGVsbCwgeyB0aXRsZTogXCJMb2FkaW5nLi4uXCIsIHJlbmRlclNjcmlwdHM6IHRydWUgfSwgRU5BQkxFX0RFVl9XQVJOSU5HUyA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9LiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyBcIiArXG4gICAgICAgICAgICAgICAgXCJ3aGVuIHlvdXIgYXBwIGlzIGxvYWRpbmcgSlMgbW9kdWxlcyBhbmQvb3IgcnVubmluZyBcXGBjbGllbnRMb2FkZXJcXGAgXCIgK1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25zLiBDaGVjayBvdXQgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vc3RhcnQvZnJhbWV3b3JrL3JvdXRlLW1vZHVsZSNoeWRyYXRlZmFsbGJhY2sgXCIgK1xuICAgICAgICAgICAgICAgIFwiZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGBcbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsKTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxuZnVuY3Rpb24gZ3JvdXBSb3V0ZXNCeVBhcmVudElkKG1hbmlmZXN0KSB7XG4gIGxldCByb3V0ZXMgPSB7fTtcbiAgT2JqZWN0LnZhbHVlcyhtYW5pZmVzdCkuZm9yRWFjaCgocm91dGUpID0+IHtcbiAgICBpZiAocm91dGUpIHtcbiAgICAgIGxldCBwYXJlbnRJZCA9IHJvdXRlLnBhcmVudElkIHx8IFwiXCI7XG4gICAgICBpZiAoIXJvdXRlc1twYXJlbnRJZF0pIHtcbiAgICAgICAgcm91dGVzW3BhcmVudElkXSA9IFtdO1xuICAgICAgfVxuICAgICAgcm91dGVzW3BhcmVudElkXS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuZnVuY3Rpb24gZ2V0Um91dGVDb21wb25lbnRzKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSB7XG4gIGxldCBDb21wb25lbnQ0ID0gZ2V0Um91dGVNb2R1bGVDb21wb25lbnQocm91dGVNb2R1bGUpO1xuICBsZXQgSHlkcmF0ZUZhbGxiYWNrID0gcm91dGVNb2R1bGUuSHlkcmF0ZUZhbGxiYWNrICYmICghaXNTcGFNb2RlIHx8IHJvdXRlLmlkID09PSBcInJvb3RcIikgPyByb3V0ZU1vZHVsZS5IeWRyYXRlRmFsbGJhY2sgOiByb3V0ZS5pZCA9PT0gXCJyb290XCIgPyBSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrIDogdm9pZCAwO1xuICBsZXQgRXJyb3JCb3VuZGFyeSA9IHJvdXRlTW9kdWxlLkVycm9yQm91bmRhcnkgPyByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5IDogcm91dGUuaWQgPT09IFwicm9vdFwiID8gKCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5LCB7IGVycm9yOiB1c2VSb3V0ZUVycm9yKCkgfSkgOiB2b2lkIDA7XG4gIGlmIChyb3V0ZS5pZCA9PT0gXCJyb290XCIgJiYgcm91dGVNb2R1bGUuTGF5b3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkNvbXBvbmVudDQgPyB7XG4gICAgICAgIGVsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChDb21wb25lbnQ0LCBudWxsKSlcbiAgICAgIH0gOiB7IENvbXBvbmVudDogQ29tcG9uZW50NCB9LFxuICAgICAgLi4uRXJyb3JCb3VuZGFyeSA/IHtcbiAgICAgICAgZXJyb3JFbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgbnVsbCkpXG4gICAgICB9IDogeyBFcnJvckJvdW5kYXJ5IH0sXG4gICAgICAuLi5IeWRyYXRlRmFsbGJhY2sgPyB7XG4gICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChyb3V0ZU1vZHVsZS5MYXlvdXQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChIeWRyYXRlRmFsbGJhY2ssIG51bGwpKVxuICAgICAgfSA6IHsgSHlkcmF0ZUZhbGxiYWNrIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IENvbXBvbmVudDogQ29tcG9uZW50NCwgRXJyb3JCb3VuZGFyeSwgSHlkcmF0ZUZhbGxiYWNrIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJSb3V0ZXMobWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgZnV0dXJlLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIHNwYU1vZGVMYXp5UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh7IENvbXBvbmVudDogKCkgPT4gbnVsbCB9KSkge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlLmlkXTtcbiAgICBpbnZhcmlhbnQyKFxuICAgICAgcm91dGVNb2R1bGUsXG4gICAgICBcIk5vIGByb3V0ZU1vZHVsZWAgYXZhaWxhYmxlIHRvIGNyZWF0ZSBzZXJ2ZXIgcm91dGVzXCJcbiAgICApO1xuICAgIGxldCBkYXRhUm91dGUgPSB7XG4gICAgICAuLi5nZXRSb3V0ZUNvbXBvbmVudHMocm91dGUsIHJvdXRlTW9kdWxlLCBpc1NwYU1vZGUpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICAgIC8vIEZvciBTUEEgTW9kZSwgYWxsIHJvdXRlcyBhcmUgbGF6eSBleGNlcHQgcm9vdC4gIEhvd2V2ZXIgd2UgdGVsbCB0aGVcbiAgICAgIC8vIHJvdXRlciByb290IGlzIGFsc28gbGF6eSBoZXJlIHRvbyBzaW5jZSB3ZSBkb24ndCBuZWVkIGEgZnVsbFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gLSB3ZSBqdXN0IG5lZWQgYSBgbGF6eWAgcHJvcCB0byB0ZWxsIHRoZSBSUiByZW5kZXJpbmdcbiAgICAgIC8vIHdoZXJlIHRvIHN0b3Agd2hpY2ggaXMgYWx3YXlzIGF0IHRoZSByb290IHJvdXRlIGluIFNQQSBtb2RlXG4gICAgICBsYXp5OiBpc1NwYU1vZGUgPyAoKSA9PiBzcGFNb2RlTGF6eVByb21pc2UgOiB2b2lkIDAsXG4gICAgICAvLyBGb3IgcGFydGlhbCBoeWRyYXRpb24gcmVuZGVyaW5nLCB3ZSBuZWVkIHRvIGluZGljYXRlIHdoZW4gdGhlIHJvdXRlXG4gICAgICAvLyBoYXMgYSBsb2FkZXIvY2xpZW50TG9hZGVyLCBidXQgaXQgd29uJ3QgZXZlciBiZSBjYWxsZWQgZHVyaW5nIHRoZSBzdGF0aWNcbiAgICAgIC8vIHJlbmRlciwgc28ganVzdCBnaXZlIGl0IGEgbm8tb3AgZnVuY3Rpb24gc28gd2UgY2FuIHJlbmRlciBkb3duIHRvIHRoZVxuICAgICAgLy8gcHJvcGVyIGZhbGxiYWNrXG4gICAgICBsb2FkZXI6IHJvdXRlLmhhc0xvYWRlciB8fCByb3V0ZS5oYXNDbGllbnRMb2FkZXIgPyAoKSA9PiBudWxsIDogdm9pZCAwXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIG1pZGRsZXdhcmUvYWN0aW9uL3Nob3VsZFJldmFsaWRhdGUgb24gdGhlc2Ugcm91dGVzIHNpbmNlXG4gICAgICAvLyB0aGV5J3JlIGZvciBhIHN0YXRpYyByZW5kZXJcbiAgICB9O1xuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZVNlcnZlclJvdXRlcyhcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgZnV0dXJlLFxuICAgICAgaXNTcGFNb2RlLFxuICAgICAgcm91dGUuaWQsXG4gICAgICByb3V0ZXNCeVBhcmVudElkLFxuICAgICAgc3BhTW9kZUxhenlQcm9taXNlXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkgZGF0YVJvdXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGRhdGFSb3V0ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0KG5lZWRzUmV2YWxpZGF0aW9uLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIGluaXRpYWxTdGF0ZSwgc3NyLCBpc1NwYU1vZGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudFJvdXRlcyhcbiAgICBtYW5pZmVzdCxcbiAgICByb3V0ZU1vZHVsZXNDYWNoZSxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgc3NyLFxuICAgIGlzU3BhTW9kZSxcbiAgICBcIlwiLFxuICAgIGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksXG4gICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwodHlwZSwgcm91dGUpIHtcbiAgaWYgKHR5cGUgPT09IFwibG9hZGVyXCIgJiYgIXJvdXRlLmhhc0xvYWRlciB8fCB0eXBlID09PSBcImFjdGlvblwiICYmICFyb3V0ZS5oYXNBY3Rpb24pIHtcbiAgICBsZXQgZm4gPSB0eXBlID09PSBcImFjdGlvblwiID8gXCJzZXJ2ZXJBY3Rpb24oKVwiIDogXCJzZXJ2ZXJMb2FkZXIoKVwiO1xuICAgIGxldCBtc2cgPSBgWW91IGFyZSB0cnlpbmcgdG8gY2FsbCAke2ZufSBvbiBhIHJvdXRlIHRoYXQgZG9lcyBub3QgaGF2ZSBhIHNlcnZlciAke3R5cGV9IChyb3V0ZUlkOiBcIiR7cm91dGUuaWR9XCIpYDtcbiAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2VJbXBsKDQwMCwgXCJCYWQgUmVxdWVzdFwiLCBuZXcgRXJyb3IobXNnKSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQWN0aW9uRGVmaW5lZEVycm9yKHR5cGUsIHJvdXRlSWQpIHtcbiAgbGV0IGFydGljbGUgPSB0eXBlID09PSBcImNsaWVudEFjdGlvblwiID8gXCJhXCIgOiBcImFuXCI7XG4gIGxldCBtc2cgPSBgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgaGF2ZSAke2FydGljbGV9ICR7dHlwZX0sIGJ1dCB5b3UgYXJlIHRyeWluZyB0byBzdWJtaXQgdG8gaXQuIFRvIGZpeCB0aGlzLCBwbGVhc2UgYWRkICR7YXJ0aWNsZX0gXFxgJHt0eXBlfVxcYCBmdW5jdGlvbiB0byB0aGUgcm91dGVgO1xuICBjb25zb2xlLmVycm9yKG1zZyk7XG4gIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbCg0MDUsIFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsIG5ldyBFcnJvcihtc2cpLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdCwgcm91dGVNb2R1bGVzQ2FjaGUsIGluaXRpYWxTdGF0ZSwgc3NyLCBpc1NwYU1vZGUsIHBhcmVudElkID0gXCJcIiwgcm91dGVzQnlQYXJlbnRJZCA9IGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCksIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIHJldHVybiAocm91dGVzQnlQYXJlbnRJZFtwYXJlbnRJZF0gfHwgW10pLm1hcCgocm91dGUpID0+IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF07XG4gICAgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJIYW5kbGVyKHNpbmdsZUZldGNoKSB7XG4gICAgICBpbnZhcmlhbnQyKFxuICAgICAgICB0eXBlb2Ygc2luZ2xlRmV0Y2ggPT09IFwiZnVuY3Rpb25cIixcbiAgICAgICAgXCJObyBzaW5nbGUgZmV0Y2ggZnVuY3Rpb24gYXZhaWxhYmxlIGZvciByb3V0ZSBoYW5kbGVyXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gc2luZ2xlRmV0Y2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpIHtcbiAgICAgIGlmICghcm91dGUuaGFzTG9hZGVyKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0FjdGlvbikge1xuICAgICAgICB0aHJvdyBub0FjdGlvbkRlZmluZWRFcnJvcihcImFjdGlvblwiLCByb3V0ZS5pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJIYW5kbGVyKHNpbmdsZUZldGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlZmV0Y2hNb2R1bGUobW9kdWxlUGF0aCkge1xuICAgICAgaW1wb3J0KFxuICAgICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqL1xuICAgICAgICBtb2R1bGVQYXRoXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzKHJvdXRlMikge1xuICAgICAgaWYgKHJvdXRlMi5jbGllbnRBY3Rpb25Nb2R1bGUpIHtcbiAgICAgICAgcHJlZmV0Y2hNb2R1bGUocm91dGUyLmNsaWVudEFjdGlvbk1vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAocm91dGUyLmNsaWVudExvYWRlck1vZHVsZSkge1xuICAgICAgICBwcmVmZXRjaE1vZHVsZShyb3V0ZTIuY2xpZW50TG9hZGVyTW9kdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICBsZXQgY2FjaGVkTW9kdWxlID0gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICAgICAgbGV0IGxpbmtQcmVmZXRjaFByb21pc2UgPSBjYWNoZWRNb2R1bGUgPyBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGUsIGNhY2hlZE1vZHVsZSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCBsaW5rUHJlZmV0Y2hQcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGF0YVJvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgaW5kZXg6IHJvdXRlLmluZGV4LFxuICAgICAgcGF0aDogcm91dGUucGF0aFxuICAgIH07XG4gICAgaWYgKHJvdXRlTW9kdWxlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGRhdGFSb3V0ZSwge1xuICAgICAgICAuLi5kYXRhUm91dGUsXG4gICAgICAgIC4uLmdldFJvdXRlQ29tcG9uZW50cyhyb3V0ZSwgcm91dGVNb2R1bGUsIGlzU3BhTW9kZSksXG4gICAgICAgIG1pZGRsZXdhcmU6IHJvdXRlTW9kdWxlLmNsaWVudE1pZGRsZXdhcmUsXG4gICAgICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgICAgICBzaG91bGRSZXZhbGlkYXRlOiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24oXG4gICAgICAgICAgZGF0YVJvdXRlLnBhdGgsXG4gICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgcm91dGUsXG4gICAgICAgICAgc3NyLFxuICAgICAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgbGV0IGhhc0luaXRpYWxEYXRhID0gaW5pdGlhbFN0YXRlICYmIGluaXRpYWxTdGF0ZS5sb2FkZXJEYXRhICYmIHJvdXRlLmlkIGluIGluaXRpYWxTdGF0ZS5sb2FkZXJEYXRhO1xuICAgICAgbGV0IGluaXRpYWxEYXRhID0gaGFzSW5pdGlhbERhdGEgPyBpbml0aWFsU3RhdGU/LmxvYWRlckRhdGE/Lltyb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICBsZXQgaGFzSW5pdGlhbEVycm9yID0gaW5pdGlhbFN0YXRlICYmIGluaXRpYWxTdGF0ZS5lcnJvcnMgJiYgcm91dGUuaWQgaW4gaW5pdGlhbFN0YXRlLmVycm9ycztcbiAgICAgIGxldCBpbml0aWFsRXJyb3IgPSBoYXNJbml0aWFsRXJyb3IgPyBpbml0aWFsU3RhdGU/LmVycm9ycz8uW3JvdXRlLmlkXSA6IHZvaWQgMDtcbiAgICAgIGxldCBpc0h5ZHJhdGlvblJlcXVlc3QgPSBuZWVkc1JldmFsaWRhdGlvbiA9PSBudWxsICYmIChyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXI/Lmh5ZHJhdGUgPT09IHRydWUgfHwgIXJvdXRlLmhhc0xvYWRlcik7XG4gICAgICBkYXRhUm91dGUubG9hZGVyID0gYXN5bmMgKHsgcmVxdWVzdCwgcGFyYW1zLCBjb250ZXh0IH0sIHNpbmdsZUZldGNoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaW52YXJpYW50MihcbiAgICAgICAgICAgICAgcm91dGVNb2R1bGUsXG4gICAgICAgICAgICAgIFwiTm8gYHJvdXRlTW9kdWxlYCBhdmFpbGFibGUgZm9yIGNyaXRpY2FsLXJvdXRlIGxvYWRlclwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFyb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIoe1xuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIGFzeW5jIHNlcnZlckxvYWRlcigpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIeWRyYXRpb25SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzSW5pdGlhbERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxEYXRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGhhc0luaXRpYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaXNIeWRyYXRpb25SZXF1ZXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkYXRhUm91dGUubG9hZGVyLmh5ZHJhdGUgPSBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIoXG4gICAgICAgIHJvdXRlLmlkLFxuICAgICAgICByb3V0ZU1vZHVsZS5jbGllbnRMb2FkZXIsXG4gICAgICAgIHJvdXRlLmhhc0xvYWRlcixcbiAgICAgICAgaXNTcGFNb2RlXG4gICAgICApO1xuICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9ICh7IHJlcXVlc3QsIHBhcmFtcywgY29udGV4dCB9LCBzaW5nbGVGZXRjaCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaW52YXJpYW50MihcbiAgICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgICAgXCJObyBgcm91dGVNb2R1bGVgIGF2YWlsYWJsZSBmb3IgY3JpdGljYWwtcm91dGUgYWN0aW9uXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNTcGFNb2RlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5vQWN0aW9uRGVmaW5lZEVycm9yKFwiY2xpZW50QWN0aW9uXCIsIHJvdXRlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5jbGllbnRBY3Rpb24oe1xuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBhc3luYyBzZXJ2ZXJBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHByZXZlbnRJbnZhbGlkU2VydmVySGFuZGxlckNhbGwoXCJhY3Rpb25cIiwgcm91dGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcm91dGUuaGFzQ2xpZW50TG9hZGVyKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5sb2FkZXIgPSAoXywgc2luZ2xlRmV0Y2gpID0+IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyb3V0ZS5oYXNDbGllbnRBY3Rpb24pIHtcbiAgICAgICAgZGF0YVJvdXRlLmFjdGlvbiA9IChfLCBzaW5nbGVGZXRjaCkgPT4gcHJlZmV0Y2hTdHlsZXNBbmRDYWxsSGFuZGxlcigoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzU3BhTW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbm9BY3Rpb25EZWZpbmVkRXJyb3IoXCJjbGllbnRBY3Rpb25cIiwgcm91dGUuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxldCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0TGF6eVJvdXRlKCkge1xuICAgICAgICBpZiAobGF6eVJvdXRlUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGxhenlSb3V0ZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChyb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGUgfHwgcm91dGUuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByb3V0ZU1vZHVsZVByb21pc2UgPSBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcm91dGVNb2R1bGVzQ2FjaGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHByZWZldGNoUm91dGVNb2R1bGVDaHVua3Mocm91dGUpO1xuICAgICAgICAgIHJldHVybiBhd2FpdCByb3V0ZU1vZHVsZVByb21pc2U7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBsYXp5Um91dGVQcm9taXNlO1xuICAgICAgfVxuICAgICAgZGF0YVJvdXRlLmxhenkgPSB7XG4gICAgICAgIGxvYWRlcjogcm91dGUuaGFzQ2xpZW50TG9hZGVyID8gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGxldCB7IGNsaWVudExvYWRlciB9ID0gcm91dGUuY2xpZW50TG9hZGVyTW9kdWxlID8gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICAgICAgICByb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGVcbiAgICAgICAgICApIDogYXdhaXQgZ2V0TGF6eVJvdXRlKCk7XG4gICAgICAgICAgaW52YXJpYW50MihjbGllbnRMb2FkZXIsIFwiTm8gYGNsaWVudExvYWRlcmAgZXhwb3J0IGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiAoYXJncywgc2luZ2xlRmV0Y2gpID0+IGNsaWVudExvYWRlcih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyTG9hZGVyKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwibG9hZGVyXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgYWN0aW9uOiByb3V0ZS5oYXNDbGllbnRBY3Rpb24gPyBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgbGV0IGNsaWVudEFjdGlvblByb21pc2UgPSByb3V0ZS5jbGllbnRBY3Rpb25Nb2R1bGUgPyBpbXBvcnQoXG4gICAgICAgICAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAgICAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgICAgICAgIHJvdXRlLmNsaWVudEFjdGlvbk1vZHVsZVxuICAgICAgICAgICkgOiBnZXRMYXp5Um91dGUoKTtcbiAgICAgICAgICBwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzKHJvdXRlKTtcbiAgICAgICAgICBsZXQgeyBjbGllbnRBY3Rpb24gfSA9IGF3YWl0IGNsaWVudEFjdGlvblByb21pc2U7XG4gICAgICAgICAgaW52YXJpYW50MihjbGllbnRBY3Rpb24sIFwiTm8gYGNsaWVudEFjdGlvbmAgZXhwb3J0IGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiAoYXJncywgc2luZ2xlRmV0Y2gpID0+IGNsaWVudEFjdGlvbih7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwiYWN0aW9uXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgbWlkZGxld2FyZTogcm91dGUuaGFzQ2xpZW50TWlkZGxld2FyZSA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBsZXQgeyBjbGllbnRNaWRkbGV3YXJlIH0gPSByb3V0ZS5jbGllbnRNaWRkbGV3YXJlTW9kdWxlID8gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICAgICAgICByb3V0ZS5jbGllbnRNaWRkbGV3YXJlTW9kdWxlXG4gICAgICAgICAgKSA6IGF3YWl0IGdldExhenlSb3V0ZSgpO1xuICAgICAgICAgIGludmFyaWFudDIoY2xpZW50TWlkZGxld2FyZSwgXCJObyBgY2xpZW50TWlkZGxld2FyZWAgZXhwb3J0IGZvdW5kXCIpO1xuICAgICAgICAgIHJldHVybiBjbGllbnRNaWRkbGV3YXJlO1xuICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICBzaG91bGRSZXZhbGlkYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IGdldExhenlSb3V0ZSgpO1xuICAgICAgICAgIHJldHVybiBnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24oXG4gICAgICAgICAgICBkYXRhUm91dGUucGF0aCxcbiAgICAgICAgICAgIGxhenlSb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgc3NyLFxuICAgICAgICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGU6IGFzeW5jICgpID0+IChhd2FpdCBnZXRMYXp5Um91dGUoKSkuaGFuZGxlLFxuICAgICAgICAvLyBObyBuZWVkIHRvIHdyYXAgdGhlc2UgaW4gbGF5b3V0IHNpbmNlIHRoZSByb290IHJvdXRlIGlzIG5ldmVyXG4gICAgICAgIC8vIGxvYWRlZCB2aWEgcm91dGUubGF6eSgpXG4gICAgICAgIENvbXBvbmVudDogYXN5bmMgKCkgPT4gKGF3YWl0IGdldExhenlSb3V0ZSgpKS5Db21wb25lbnQsXG4gICAgICAgIEVycm9yQm91bmRhcnk6IHJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPyBhc3luYyAoKSA9PiAoYXdhaXQgZ2V0TGF6eVJvdXRlKCkpLkVycm9yQm91bmRhcnkgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNsaWVudFJvdXRlcyhcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzQ2FjaGUsXG4gICAgICBpbml0aWFsU3RhdGUsXG4gICAgICBzc3IsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICByb3V0ZS5pZCxcbiAgICAgIHJvdXRlc0J5UGFyZW50SWQsXG4gICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIGRhdGFSb3V0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBkYXRhUm91dGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKHBhdGgsIHJvdXRlLCBtYW5pZmVzdFJvdXRlLCBzc3IsIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIGlmIChuZWVkc1JldmFsaWRhdGlvbikge1xuICAgIHJldHVybiB3cmFwU2hvdWxkUmV2YWxpZGF0ZUZvckhkcihcbiAgICAgIG1hbmlmZXN0Um91dGUuaWQsXG4gICAgICByb3V0ZS5zaG91bGRSZXZhbGlkYXRlLFxuICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICApO1xuICB9XG4gIGlmICghc3NyICYmIG1hbmlmZXN0Um91dGUuaGFzTG9hZGVyICYmICFtYW5pZmVzdFJvdXRlLmhhc0NsaWVudExvYWRlcikge1xuICAgIGxldCBteVBhcmFtcyA9IHBhdGggPyBjb21waWxlUGF0aChwYXRoKVsxXS5tYXAoKHApID0+IHAucGFyYW1OYW1lKSA6IFtdO1xuICAgIGNvbnN0IGRpZFBhcmFtc0NoYW5nZSA9IChvcHRzKSA9PiBteVBhcmFtcy5zb21lKChwKSA9PiBvcHRzLmN1cnJlbnRQYXJhbXNbcF0gIT09IG9wdHMubmV4dFBhcmFtc1twXSk7XG4gICAgaWYgKHJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIGxldCBmbiA9IHJvdXRlLnNob3VsZFJldmFsaWRhdGU7XG4gICAgICByZXR1cm4gKG9wdHMpID0+IGZuKHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGRpZFBhcmFtc0NoYW5nZShvcHRzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAob3B0cykgPT4gZGlkUGFyYW1zQ2hhbmdlKG9wdHMpO1xuICAgIH1cbiAgfVxuICBpZiAoc3NyICYmIHJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgZm4gPSByb3V0ZS5zaG91bGRSZXZhbGlkYXRlO1xuICAgIHJldHVybiAob3B0cykgPT4gZm4oeyAuLi5vcHRzLCBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gcm91dGUuc2hvdWxkUmV2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIHdyYXBTaG91bGRSZXZhbGlkYXRlRm9ySGRyKHJvdXRlSWQsIHJvdXRlU2hvdWxkUmV2YWxpZGF0ZSwgbmVlZHNSZXZhbGlkYXRpb24pIHtcbiAgbGV0IGhhbmRsZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgcmV0dXJuIChhcmcpID0+IHtcbiAgICBpZiAoIWhhbmRsZWRSZXZhbGlkYXRpb24pIHtcbiAgICAgIGhhbmRsZWRSZXZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgcmV0dXJuIG5lZWRzUmV2YWxpZGF0aW9uLmhhcyhyb3V0ZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlU2hvdWxkUmV2YWxpZGF0ZSA/IHJvdXRlU2hvdWxkUmV2YWxpZGF0ZShhcmcpIDogYXJnLmRlZmF1bHRTaG91bGRSZXZhbGlkYXRlO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgcm91dGVNb2R1bGVQcm9taXNlID0gbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICBsZXQgcHJlZmV0Y2hSb3V0ZUNzc1Byb21pc2UgPSBwcmVmZXRjaFJvdXRlQ3NzKHJvdXRlKTtcbiAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgcm91dGVNb2R1bGVQcm9taXNlO1xuICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgcHJlZmV0Y2hSb3V0ZUNzc1Byb21pc2UsXG4gICAgcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZSlcbiAgXSk7XG4gIHJldHVybiB7XG4gICAgQ29tcG9uZW50OiBnZXRSb3V0ZU1vZHVsZUNvbXBvbmVudChyb3V0ZU1vZHVsZSksXG4gICAgRXJyb3JCb3VuZGFyeTogcm91dGVNb2R1bGUuRXJyb3JCb3VuZGFyeSxcbiAgICBjbGllbnRNaWRkbGV3YXJlOiByb3V0ZU1vZHVsZS5jbGllbnRNaWRkbGV3YXJlLFxuICAgIGNsaWVudEFjdGlvbjogcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uLFxuICAgIGNsaWVudExvYWRlcjogcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyLFxuICAgIGhhbmRsZTogcm91dGVNb2R1bGUuaGFuZGxlLFxuICAgIGxpbmtzOiByb3V0ZU1vZHVsZS5saW5rcyxcbiAgICBtZXRhOiByb3V0ZU1vZHVsZS5tZXRhLFxuICAgIHNob3VsZFJldmFsaWRhdGU6IHJvdXRlTW9kdWxlLnNob3VsZFJldmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKSB7XG4gIGlmIChyb3V0ZU1vZHVsZS5kZWZhdWx0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gIGxldCBpc0VtcHR5T2JqZWN0ID0gdHlwZW9mIHJvdXRlTW9kdWxlLmRlZmF1bHQgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMocm91dGVNb2R1bGUuZGVmYXVsdCkubGVuZ3RoID09PSAwO1xuICBpZiAoIWlzRW1wdHlPYmplY3QpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGUuZGVmYXVsdDtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKHJvdXRlSWQsIGNsaWVudExvYWRlciwgaGFzTG9hZGVyLCBpc1NwYU1vZGUpIHtcbiAgcmV0dXJuIGlzU3BhTW9kZSAmJiByb3V0ZUlkICE9PSBcInJvb3RcIiB8fCBjbGllbnRMb2FkZXIgIT0gbnVsbCAmJiAoY2xpZW50TG9hZGVyLmh5ZHJhdGUgPT09IHRydWUgfHwgaGFzTG9hZGVyICE9PSB0cnVlKTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZm9nLW9mLXdhci50c1xudmFyIG5leHRQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSA9IDFlMztcbnZhciBkaXNjb3ZlcmVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIFVSTF9MSU1JVCA9IDc2ODA7XG5mdW5jdGlvbiBpc0ZvZ09mV2FyRW5hYmxlZChyb3V0ZURpc2NvdmVyeSwgc3NyKSB7XG4gIHJldHVybiByb3V0ZURpc2NvdmVyeS5tb2RlID09PSBcImxhenlcIiAmJiBzc3IgPT09IHRydWU7XG59XG5mdW5jdGlvbiBnZXRQYXJ0aWFsTWFuaWZlc3QoeyBzcmksIC4uLm1hbmlmZXN0IH0sIHJvdXRlcikge1xuICBsZXQgcm91dGVJZHMgPSBuZXcgU2V0KHJvdXRlci5zdGF0ZS5tYXRjaGVzLm1hcCgobSkgPT4gbS5yb3V0ZS5pZCkpO1xuICBsZXQgc2VnbWVudHMgPSByb3V0ZXIuc3RhdGUubG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IHBhdGhzID0gW1wiL1wiXTtcbiAgc2VnbWVudHMucG9wKCk7XG4gIHdoaWxlIChzZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgcGF0aHMucHVzaChgLyR7c2VnbWVudHMuam9pbihcIi9cIil9YCk7XG4gICAgc2VnbWVudHMucG9wKCk7XG4gIH1cbiAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVyLnJvdXRlcywgcGF0aCwgcm91dGVyLmJhc2VuYW1lKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcy5mb3JFYWNoKChtKSA9PiByb3V0ZUlkcy5hZGQobS5yb3V0ZS5pZCkpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBpbml0aWFsUm91dGVzID0gWy4uLnJvdXRlSWRzXS5yZWR1Y2UoXG4gICAgKGFjYywgaWQpID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFtpZF06IG1hbmlmZXN0LnJvdXRlc1tpZF0gfSksXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5tYW5pZmVzdCxcbiAgICByb3V0ZXM6IGluaXRpYWxSb3V0ZXMsXG4gICAgc3JpOiBzcmkgPyB0cnVlIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uKG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHNzciwgcm91dGVEaXNjb3ZlcnksIGlzU3BhTW9kZSwgYmFzZW5hbWUpIHtcbiAgaWYgKCFpc0ZvZ09mV2FyRW5hYmxlZChyb3V0ZURpc2NvdmVyeSwgc3NyKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGFzeW5jICh7IHBhdGgsIHBhdGNoLCBzaWduYWwsIGZldGNoZXJLZXkgfSkgPT4ge1xuICAgIGlmIChkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMoXG4gICAgICBbcGF0aF0sXG4gICAgICBmZXRjaGVyS2V5ID8gd2luZG93LmxvY2F0aW9uLmhyZWYgOiBwYXRoLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzc3IsXG4gICAgICBpc1NwYU1vZGUsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHJvdXRlRGlzY292ZXJ5Lm1hbmlmZXN0UGF0aCxcbiAgICAgIHBhdGNoLFxuICAgICAgc2lnbmFsXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUZvZ09GV2FyRGlzY292ZXJ5KHJvdXRlciwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgc3NyLCByb3V0ZURpc2NvdmVyeSwgaXNTcGFNb2RlKSB7XG4gIFJlYWN0Ny51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNGb2dPZldhckVuYWJsZWQocm91dGVEaXNjb3ZlcnksIHNzcikgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFRTIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHlldFxuICAgIHdpbmRvdy5uYXZpZ2F0b3I/LmNvbm5lY3Rpb24/LnNhdmVEYXRhID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRWxlbWVudChlbCkge1xuICAgICAgbGV0IHBhdGggPSBlbC50YWdOYW1lID09PSBcIkZPUk1cIiA/IGVsLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKSA6IGVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGhuYW1lID0gZWwudGFnTmFtZSA9PT0gXCJBXCIgPyBlbC5wYXRobmFtZSA6IG5ldyBVUkwocGF0aCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikucGF0aG5hbWU7XG4gICAgICBpZiAoIWRpc2NvdmVyZWRQYXRocy5oYXMocGF0aG5hbWUpKSB7XG4gICAgICAgIG5leHRQYXRocy5hZGQocGF0aG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaFBhdGNoZXMoKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiYVtkYXRhLWRpc2NvdmVyXSwgZm9ybVtkYXRhLWRpc2NvdmVyXVwiKS5mb3JFYWNoKHJlZ2lzdGVyRWxlbWVudCk7XG4gICAgICBsZXQgbGF6eVBhdGhzID0gQXJyYXkuZnJvbShuZXh0UGF0aHMua2V5cygpKS5maWx0ZXIoKHBhdGgpID0+IHtcbiAgICAgICAgaWYgKGRpc2NvdmVyZWRQYXRocy5oYXMocGF0aCkpIHtcbiAgICAgICAgICBuZXh0UGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGxhenlQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyhcbiAgICAgICAgICBsYXp5UGF0aHMsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgICAgc3NyLFxuICAgICAgICAgIGlzU3BhTW9kZSxcbiAgICAgICAgICByb3V0ZXIuYmFzZW5hbWUsXG4gICAgICAgICAgcm91dGVEaXNjb3ZlcnkubWFuaWZlc3RQYXRoLFxuICAgICAgICAgIHJvdXRlci5wYXRjaFJvdXRlc1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1hbmlmZXN0IHBhdGNoZXNcIiwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkZWJvdW5jZWRGZXRjaFBhdGNoZXMgPSBkZWJvdW5jZShmZXRjaFBhdGNoZXMsIDEwMCk7XG4gICAgZmV0Y2hQYXRjaGVzKCk7XG4gICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gZGVib3VuY2VkRmV0Y2hQYXRjaGVzKCkpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wiZGF0YS1kaXNjb3ZlclwiLCBcImhyZWZcIiwgXCJhY3Rpb25cIl1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbc3NyLCBpc1NwYU1vZGUsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHJvdXRlciwgcm91dGVEaXNjb3ZlcnldKTtcbn1cbmZ1bmN0aW9uIGdldE1hbmlmZXN0UGF0aChfbWFuaWZlc3RQYXRoLCBiYXNlbmFtZSkge1xuICBsZXQgbWFuaWZlc3RQYXRoID0gX21hbmlmZXN0UGF0aCB8fCBcIi9fX21hbmlmZXN0XCI7XG4gIGlmIChiYXNlbmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1hbmlmZXN0UGF0aDtcbiAgfVxuICByZXR1cm4gYCR7YmFzZW5hbWV9JHttYW5pZmVzdFBhdGh9YC5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbn1cbnZhciBNQU5JRkVTVF9WRVJTSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItbWFuaWZlc3QtdmVyc2lvblwiO1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRBcHBseU1hbmlmZXN0UGF0Y2hlcyhwYXRocywgZXJyb3JSZWxvYWRQYXRoLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBzc3IsIGlzU3BhTW9kZSwgYmFzZW5hbWUsIG1hbmlmZXN0UGF0aCwgcGF0Y2hSb3V0ZXMsIHNpZ25hbCkge1xuICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHNlYXJjaFBhcmFtcy5zZXQoXCJwYXRoc1wiLCBwYXRocy5zb3J0KCkuam9pbihcIixcIikpO1xuICBzZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBtYW5pZmVzdC52ZXJzaW9uKTtcbiAgbGV0IHVybCA9IG5ldyBVUkwoXG4gICAgZ2V0TWFuaWZlc3RQYXRoKG1hbmlmZXN0UGF0aCwgYmFzZW5hbWUpLFxuICAgIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgKTtcbiAgdXJsLnNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xuICBpZiAodXJsLnRvU3RyaW5nKCkubGVuZ3RoID4gVVJMX0xJTUlUKSB7XG4gICAgbmV4dFBhdGhzLmNsZWFyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzZXJ2ZXJQYXRjaGVzO1xuICB0cnkge1xuICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgc2lnbmFsIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH1gKTtcbiAgICB9IGVsc2UgaWYgKHJlcy5zdGF0dXMgPT09IDIwNCAmJiByZXMuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSkge1xuICAgICAgaWYgKCFlcnJvclJlbG9hZFBhdGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBtYW5pZmVzdCB2ZXJzaW9uIG1pc21hdGNoIGR1cmluZyBlYWdlciByb3V0ZSBkaXNjb3ZlcnkuIFRoZSBuZXh0IG5hdmlnYXRpb24vZmV0Y2ggdG8gYW4gdW5kaXNjb3ZlcmVkIHJvdXRlIHdpbGwgcmVzdWx0IGluIGEgbmV3IGRvY3VtZW50IG5hdmlnYXRpb24gdG8gc3luYyB1cCB3aXRoIHRoZSBsYXRlc3QgbWFuaWZlc3QuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oTUFOSUZFU1RfVkVSU0lPTl9TVE9SQUdFX0tFWSkgPT09IG1hbmlmZXN0LnZlcnNpb24pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJVbmFibGUgdG8gZGlzY292ZXIgcm91dGVzIGR1ZSB0byBtYW5pZmVzdCB2ZXJzaW9uIG1pc21hdGNoLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShNQU5JRkVTVF9WRVJTSU9OX1NUT1JBR0VfS0VZLCBtYW5pZmVzdC52ZXJzaW9uKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBlcnJvclJlbG9hZFBhdGg7XG4gICAgICBjb25zb2xlLndhcm4oXCJEZXRlY3RlZCBtYW5pZmVzdCB2ZXJzaW9uIG1pc21hdGNoLCByZWxvYWRpbmcuLi5cIik7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJlcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgcmVzLnRleHQoKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKE1BTklGRVNUX1ZFUlNJT05fU1RPUkFHRV9LRVkpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBzZXJ2ZXJQYXRjaGVzID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHJldHVybjtcbiAgICB0aHJvdyBlO1xuICB9XG4gIGxldCBrbm93blJvdXRlcyA9IG5ldyBTZXQoT2JqZWN0LmtleXMobWFuaWZlc3Qucm91dGVzKSk7XG4gIGxldCBwYXRjaGVzID0gT2JqZWN0LnZhbHVlcyhzZXJ2ZXJQYXRjaGVzKS5yZWR1Y2UoKGFjYywgcm91dGUpID0+IHtcbiAgICBpZiAocm91dGUgJiYgIWtub3duUm91dGVzLmhhcyhyb3V0ZS5pZCkpIHtcbiAgICAgIGFjY1tyb3V0ZS5pZF0gPSByb3V0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICBPYmplY3QuYXNzaWduKG1hbmlmZXN0LnJvdXRlcywgcGF0Y2hlcyk7XG4gIHBhdGhzLmZvckVhY2goKHApID0+IGFkZFRvRmlmb1F1ZXVlKHAsIGRpc2NvdmVyZWRQYXRocykpO1xuICBsZXQgcGFyZW50SWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgT2JqZWN0LnZhbHVlcyhwYXRjaGVzKS5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgIGlmIChwYXRjaCAmJiAoIXBhdGNoLnBhcmVudElkIHx8ICFwYXRjaGVzW3BhdGNoLnBhcmVudElkXSkpIHtcbiAgICAgIHBhcmVudElkcy5hZGQocGF0Y2gucGFyZW50SWQpO1xuICAgIH1cbiAgfSk7XG4gIHBhcmVudElkcy5mb3JFYWNoKFxuICAgIChwYXJlbnRJZCkgPT4gcGF0Y2hSb3V0ZXMoXG4gICAgICBwYXJlbnRJZCB8fCBudWxsLFxuICAgICAgY3JlYXRlQ2xpZW50Um91dGVzKHBhdGNoZXMsIHJvdXRlTW9kdWxlcywgbnVsbCwgc3NyLCBpc1NwYU1vZGUsIHBhcmVudElkKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGFkZFRvRmlmb1F1ZXVlKHBhdGgsIHF1ZXVlKSB7XG4gIGlmIChxdWV1ZS5zaXplID49IGRpc2NvdmVyZWRQYXRoc01heFNpemUpIHtcbiAgICBsZXQgZmlyc3QgPSBxdWV1ZS52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgcXVldWUuZGVsZXRlKGZpcnN0KTtcbiAgfVxuICBxdWV1ZS5hZGQocGF0aCk7XG59XG5mdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgd2FpdCkge1xuICBsZXQgdGltZW91dElkO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soLi4uYXJncyksIHdhaXQpO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9jb21wb25lbnRzLnRzeFxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQyKCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0OC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8RGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q4LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudDIoXG4gICAgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHJlbmRlciB0aGlzIGVsZW1lbnQgaW5zaWRlIGEgPERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbnZhciBGcmFtZXdvcmtDb250ZXh0ID0gUmVhY3Q4LmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbkZyYW1ld29ya0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkZyYW1ld29ya0NvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZUZyYW1ld29ya0NvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q4LnVzZUNvbnRleHQoRnJhbWV3b3JrQ29udGV4dCk7XG4gIGludmFyaWFudDIoXG4gICAgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHJlbmRlciB0aGlzIGVsZW1lbnQgaW5zaWRlIGEgPEh5ZHJhdGVkUm91dGVyPiBlbGVtZW50XCJcbiAgKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCB0aGVpckVsZW1lbnRQcm9wcykge1xuICBsZXQgZnJhbWV3b3JrQ29udGV4dCA9IFJlYWN0OC51c2VDb250ZXh0KEZyYW1ld29ya0NvbnRleHQpO1xuICBsZXQgW21heWJlUHJlZmV0Y2gsIHNldE1heWJlUHJlZmV0Y2hdID0gUmVhY3Q4LnVzZVN0YXRlKGZhbHNlKTtcbiAgbGV0IFtzaG91bGRQcmVmZXRjaCwgc2V0U2hvdWxkUHJlZmV0Y2hdID0gUmVhY3Q4LnVzZVN0YXRlKGZhbHNlKTtcbiAgbGV0IHsgb25Gb2N1cywgb25CbHVyLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgb25Ub3VjaFN0YXJ0IH0gPSB0aGVpckVsZW1lbnRQcm9wcztcbiAgbGV0IHJlZiA9IFJlYWN0OC51c2VSZWYobnVsbCk7XG4gIFJlYWN0OC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJ2aWV3cG9ydFwiKSB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2goZW50cnkuaXNJbnRlcnNlY3RpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoY2FsbGJhY2ssIHsgdGhyZXNob2xkOiAwLjUgfSk7XG4gICAgICBpZiAocmVmLmN1cnJlbnQpIG9ic2VydmVyLm9ic2VydmUocmVmLmN1cnJlbnQpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtwcmVmZXRjaF0pO1xuICBSZWFjdDgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWF5YmVQcmVmZXRjaCkge1xuICAgICAgbGV0IGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldFNob3VsZFByZWZldGNoKHRydWUpO1xuICAgICAgfSwgMTAwKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW21heWJlUHJlZmV0Y2hdKTtcbiAgbGV0IHNldEludGVudCA9ICgpID0+IHtcbiAgICBzZXRNYXliZVByZWZldGNoKHRydWUpO1xuICB9O1xuICBsZXQgY2FuY2VsSW50ZW50ID0gKCkgPT4ge1xuICAgIHNldE1heWJlUHJlZmV0Y2goZmFsc2UpO1xuICAgIHNldFNob3VsZFByZWZldGNoKGZhbHNlKTtcbiAgfTtcbiAgaWYgKCFmcmFtZXdvcmtDb250ZXh0KSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgcmVmLCB7fV07XG4gIH1cbiAgaWYgKHByZWZldGNoICE9PSBcImludGVudFwiKSB7XG4gICAgcmV0dXJuIFtzaG91bGRQcmVmZXRjaCwgcmVmLCB7fV07XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBzaG91bGRQcmVmZXRjaCxcbiAgICByZWYsXG4gICAge1xuICAgICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgc2V0SW50ZW50KSxcbiAgICAgIG9uQmx1cjogY29tcG9zZUV2ZW50SGFuZGxlcnMob25CbHVyLCBjYW5jZWxJbnRlbnQpLFxuICAgICAgb25Nb3VzZUVudGVyOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbk1vdXNlRW50ZXIsIHNldEludGVudCksXG4gICAgICBvbk1vdXNlTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VMZWF2ZSwgY2FuY2VsSW50ZW50KSxcbiAgICAgIG9uVG91Y2hTdGFydDogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Ub3VjaFN0YXJ0LCBzZXRJbnRlbnQpXG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICB0aGVpckhhbmRsZXIgJiYgdGhlaXJIYW5kbGVyKGV2ZW50KTtcbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZU1hdGNoZXMobWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpIHtcbiAgaWYgKGlzU3BhTW9kZSAmJiAhaXNIeWRyYXRlZCkge1xuICAgIHJldHVybiBbbWF0Y2hlc1swXV07XG4gIH1cbiAgaWYgKGVycm9ycykge1xuICAgIGxldCBlcnJvcklkeCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBlcnJvcnNbbS5yb3V0ZS5pZF0gIT09IHZvaWQgMCk7XG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMCwgZXJyb3JJZHggKyAxKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbnZhciBDUklUSUNBTF9DU1NfREFUQV9BVFRSSUJVVEUgPSBcImRhdGEtcmVhY3Qtcm91dGVyLWNyaXRpY2FsLWNzc1wiO1xuZnVuY3Rpb24gTGlua3MoeyBub25jZSB9KSB7XG4gIGxldCB7IGlzU3BhTW9kZSwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgY3JpdGljYWxDc3MgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHsgZXJyb3JzLCBtYXRjaGVzOiByb3V0ZXJNYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gZ2V0QWN0aXZlTWF0Y2hlcyhyb3V0ZXJNYXRjaGVzLCBlcnJvcnMsIGlzU3BhTW9kZSk7XG4gIGxldCBrZXllZExpbmtzID0gUmVhY3Q4LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0S2V5ZWRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCksXG4gICAgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoUmVhY3Q4LkZyYWdtZW50LCBudWxsLCB0eXBlb2YgY3JpdGljYWxDc3MgPT09IFwic3RyaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzdHlsZVwiLFxuICAgIHtcbiAgICAgIC4uLnsgW0NSSVRJQ0FMX0NTU19EQVRBX0FUVFJJQlVURV06IFwiXCIgfSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogY3JpdGljYWxDc3MgfVxuICAgIH1cbiAgKSA6IG51bGwsIHR5cGVvZiBjcml0aWNhbENzcyA9PT0gXCJvYmplY3RcIiA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICAuLi57IFtDUklUSUNBTF9DU1NfREFUQV9BVFRSSUJVVEVdOiBcIlwiIH0sXG4gICAgICByZWw6IFwic3R5bGVzaGVldFwiLFxuICAgICAgaHJlZjogY3JpdGljYWxDc3MuaHJlZixcbiAgICAgIG5vbmNlXG4gICAgfVxuICApIDogbnVsbCwga2V5ZWRMaW5rcy5tYXAoXG4gICAgKHsga2V5LCBsaW5rIH0pID0+IGlzUGFnZUxpbmtEZXNjcmlwdG9yKGxpbmspID8gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCB7IGtleSwgbm9uY2UsIC4uLmxpbmsgfSkgOiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5LCBub25jZSwgLi4ubGluayB9KVxuICApKTtcbn1cbmZ1bmN0aW9uIFByZWZldGNoUGFnZUxpbmtzKHsgcGFnZSwgLi4ubGlua1Byb3BzIH0pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IG1hdGNoZXMgPSBSZWFjdDgudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFJvdXRlcyhyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWUpLFxuICAgIFtyb3V0ZXIucm91dGVzLCBwYWdlLCByb3V0ZXIuYmFzZW5hbWVdXG4gICk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3NJbXBsLCB7IHBhZ2UsIG1hdGNoZXMsIC4uLmxpbmtQcm9wcyB9KTtcbn1cbmZ1bmN0aW9uIHVzZUtleWVkUHJlZmV0Y2hMaW5rcyhtYXRjaGVzKSB7XG4gIGxldCB7IG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IFtrZXllZFByZWZldGNoTGlua3MsIHNldEtleWVkUHJlZmV0Y2hMaW5rc10gPSBSZWFjdDgudXNlU3RhdGUoW10pO1xuICBSZWFjdDgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICB2b2lkIGdldEtleWVkUHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzKS50aGVuKFxuICAgICAgKGxpbmtzKSA9PiB7XG4gICAgICAgIGlmICghaW50ZXJydXB0ZWQpIHtcbiAgICAgICAgICBzZXRLZXllZFByZWZldGNoTGlua3MobGlua3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaW50ZXJydXB0ZWQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFttYXRjaGVzLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzXSk7XG4gIHJldHVybiBrZXllZFByZWZldGNoTGlua3M7XG59XG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwoe1xuICBwYWdlLFxuICBtYXRjaGVzOiBuZXh0TWF0Y2hlcyxcbiAgLi4ubGlua1Byb3BzXG59KSB7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCB7IG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MigpO1xuICBsZXQgeyBsb2FkZXJEYXRhLCBtYXRjaGVzIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBuZXdNYXRjaGVzRm9yRGF0YSA9IFJlYWN0OC51c2VNZW1vKFxuICAgICgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhcbiAgICAgIHBhZ2UsXG4gICAgICBuZXh0TWF0Y2hlcyxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgXCJkYXRhXCJcbiAgICApLFxuICAgIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbWFuaWZlc3QsIGxvY2F0aW9uXVxuICApO1xuICBsZXQgbmV3TWF0Y2hlc0ZvckFzc2V0cyA9IFJlYWN0OC51c2VNZW1vKFxuICAgICgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhcbiAgICAgIHBhZ2UsXG4gICAgICBuZXh0TWF0Y2hlcyxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgXCJhc3NldHNcIlxuICAgICksXG4gICAgW3BhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBtYW5pZmVzdCwgbG9jYXRpb25dXG4gICk7XG4gIGxldCBkYXRhSHJlZnMgPSBSZWFjdDgudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHBhZ2UgPT09IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgcm91dGVzUGFyYW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZm91bmRPcHRPdXRSb3V0ZSA9IGZhbHNlO1xuICAgIG5leHRNYXRjaGVzLmZvckVhY2goKG0pID0+IHtcbiAgICAgIGxldCBtYW5pZmVzdFJvdXRlID0gbWFuaWZlc3Qucm91dGVzW20ucm91dGUuaWRdO1xuICAgICAgaWYgKCFtYW5pZmVzdFJvdXRlIHx8ICFtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIW5ld01hdGNoZXNGb3JEYXRhLnNvbWUoKG0yKSA9PiBtMi5yb3V0ZS5pZCA9PT0gbS5yb3V0ZS5pZCkgJiYgbS5yb3V0ZS5pZCBpbiBsb2FkZXJEYXRhICYmIHJvdXRlTW9kdWxlc1ttLnJvdXRlLmlkXT8uc2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobWFuaWZlc3RSb3V0ZS5oYXNDbGllbnRMb2FkZXIpIHtcbiAgICAgICAgZm91bmRPcHRPdXRSb3V0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXNQYXJhbXMuYWRkKG0ucm91dGUuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyb3V0ZXNQYXJhbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgdXJsID0gc2luZ2xlRmV0Y2hVcmwocGFnZSwgYmFzZW5hbWUsIFwiZGF0YVwiKTtcbiAgICBpZiAoZm91bmRPcHRPdXRSb3V0ZSAmJiByb3V0ZXNQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFxuICAgICAgICBcIl9yb3V0ZXNcIixcbiAgICAgICAgbmV4dE1hdGNoZXMuZmlsdGVyKChtKSA9PiByb3V0ZXNQYXJhbXMuaGFzKG0ucm91dGUuaWQpKS5tYXAoKG0pID0+IG0ucm91dGUuaWQpLmpvaW4oXCIsXCIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW3VybC5wYXRobmFtZSArIHVybC5zZWFyY2hdO1xuICB9LCBbXG4gICAgYmFzZW5hbWUsXG4gICAgbG9hZGVyRGF0YSxcbiAgICBsb2NhdGlvbixcbiAgICBtYW5pZmVzdCxcbiAgICBuZXdNYXRjaGVzRm9yRGF0YSxcbiAgICBuZXh0TWF0Y2hlcyxcbiAgICBwYWdlLFxuICAgIHJvdXRlTW9kdWxlc1xuICBdKTtcbiAgbGV0IG1vZHVsZUhyZWZzID0gUmVhY3Q4LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TW9kdWxlTGlua0hyZWZzKG5ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0KSxcbiAgICBbbmV3TWF0Y2hlc0ZvckFzc2V0cywgbWFuaWZlc3RdXG4gICk7XG4gIGxldCBrZXllZFByZWZldGNoTGlua3MgPSB1c2VLZXllZFByZWZldGNoTGlua3MobmV3TWF0Y2hlc0ZvckFzc2V0cyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoUmVhY3Q4LkZyYWdtZW50LCBudWxsLCBkYXRhSHJlZnMubWFwKChocmVmKSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5OiBocmVmLCByZWw6IFwicHJlZmV0Y2hcIiwgYXM6IFwiZmV0Y2hcIiwgaHJlZiwgLi4ubGlua1Byb3BzIH0pKSwgbW9kdWxlSHJlZnMubWFwKChocmVmKSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5OiBocmVmLCByZWw6IFwibW9kdWxlcHJlbG9hZFwiLCBocmVmLCAuLi5saW5rUHJvcHMgfSkpLCBrZXllZFByZWZldGNoTGlua3MubWFwKCh7IGtleSwgbGluayB9KSA9PiAoXG4gICAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gICAgLy8gYWxyZWFkeSB3aXRoIHRoZWlyIG93biBwcm9wc1xuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXksIG5vbmNlOiBsaW5rUHJvcHMubm9uY2UsIC4uLmxpbmsgfSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gTWV0YSgpIHtcbiAgbGV0IHsgaXNTcGFNb2RlLCByb3V0ZU1vZHVsZXMgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBlcnJvcnMsXG4gICAgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhXG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGVDb250ZXh0KCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBfbWF0Y2hlcyA9IGdldEFjdGl2ZU1hdGNoZXMocm91dGVyTWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuICBpZiAoZXJyb3JzKSB7XG4gICAgZXJyb3IgPSBlcnJvcnNbX21hdGNoZXNbX21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaWRdO1xuICB9XG4gIGxldCBtZXRhID0gW107XG4gIGxldCBsZWFmTWV0YSA9IG51bGw7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgX21hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgX21hdGNoID0gX21hdGNoZXNbaV07XG4gICAgbGV0IHJvdXRlSWQgPSBfbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IGRhdGEyID0gbG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gX21hdGNoLnBhcmFtcztcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG4gICAgbGV0IHJvdXRlTWV0YSA9IFtdO1xuICAgIGxldCBtYXRjaCA9IHtcbiAgICAgIGlkOiByb3V0ZUlkLFxuICAgICAgZGF0YTogZGF0YTIsXG4gICAgICBsb2FkZXJEYXRhOiBkYXRhMixcbiAgICAgIG1ldGE6IFtdLFxuICAgICAgcGFyYW1zOiBfbWF0Y2gucGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IF9tYXRjaC5wYXRobmFtZSxcbiAgICAgIGhhbmRsZTogX21hdGNoLnJvdXRlLmhhbmRsZSxcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgICBtYXRjaGVzW2ldID0gbWF0Y2g7XG4gICAgaWYgKHJvdXRlTW9kdWxlPy5tZXRhKSB7XG4gICAgICByb3V0ZU1ldGEgPSB0eXBlb2Ygcm91dGVNb2R1bGUubWV0YSA9PT0gXCJmdW5jdGlvblwiID8gcm91dGVNb2R1bGUubWV0YSh7XG4gICAgICAgIGRhdGE6IGRhdGEyLFxuICAgICAgICBsb2FkZXJEYXRhOiBkYXRhMixcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pIDogQXJyYXkuaXNBcnJheShyb3V0ZU1vZHVsZS5tZXRhKSA/IFsuLi5yb3V0ZU1vZHVsZS5tZXRhXSA6IHJvdXRlTW9kdWxlLm1ldGE7XG4gICAgfSBlbHNlIGlmIChsZWFmTWV0YSkge1xuICAgICAgcm91dGVNZXRhID0gWy4uLmxlYWZNZXRhXTtcbiAgICB9XG4gICAgcm91dGVNZXRhID0gcm91dGVNZXRhIHx8IFtdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyb3V0ZU1ldGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIHJvdXRlIGF0IFwiICsgX21hdGNoLnJvdXRlLnBhdGggKyBcIiByZXR1cm5zIGFuIGludmFsaWQgdmFsdWUuIEFsbCByb3V0ZSBtZXRhIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBtZXRhIG9iamVjdHMuXFxuXFxuVG8gcmVmZXJlbmNlIHRoZSBtZXRhIGZ1bmN0aW9uIEFQSSwgc2VlIGh0dHBzOi8vcmVtaXgucnVuL3JvdXRlL21ldGFcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbWF0Y2gubWV0YSA9IHJvdXRlTWV0YTtcbiAgICBtYXRjaGVzW2ldID0gbWF0Y2g7XG4gICAgbWV0YSA9IFsuLi5yb3V0ZU1ldGFdO1xuICAgIGxlYWZNZXRhID0gbWV0YTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFJlYWN0OC5GcmFnbWVudCwgbnVsbCwgbWV0YS5mbGF0KCkubWFwKChtZXRhUHJvcHMpID0+IHtcbiAgICBpZiAoIW1ldGFQcm9wcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChcInRhZ05hbWVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIGxldCB7IHRhZ05hbWUsIC4uLnJlc3QgfSA9IG1ldGFQcm9wcztcbiAgICAgIGlmICghaXNWYWxpZE1ldGFUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBBIG1ldGEgb2JqZWN0IHVzZXMgYW4gaW52YWxpZCB0YWdOYW1lOiAke3RhZ05hbWV9LiBFeHBlY3RlZCBlaXRoZXIgJ2xpbmsnIG9yICdtZXRhJ2BcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBsZXQgQ29tcCA9IHRhZ05hbWU7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KENvbXAsIHsga2V5OiBKU09OLnN0cmluZ2lmeShyZXN0KSwgLi4ucmVzdCB9KTtcbiAgICB9XG4gICAgaWYgKFwidGl0bGVcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCB7IGtleTogXCJ0aXRsZVwiIH0sIFN0cmluZyhtZXRhUHJvcHMudGl0bGUpKTtcbiAgICB9XG4gICAgaWYgKFwiY2hhcnNldFwiIGluIG1ldGFQcm9wcykge1xuICAgICAgbWV0YVByb3BzLmNoYXJTZXQgPz8gKG1ldGFQcm9wcy5jaGFyU2V0ID0gbWV0YVByb3BzLmNoYXJzZXQpO1xuICAgICAgZGVsZXRlIG1ldGFQcm9wcy5jaGFyc2V0O1xuICAgIH1cbiAgICBpZiAoXCJjaGFyU2V0XCIgaW4gbWV0YVByb3BzICYmIG1ldGFQcm9wcy5jaGFyU2V0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWV0YVByb3BzLmNoYXJTZXQgPT09IFwic3RyaW5nXCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBcImNoYXJTZXRcIiwgY2hhclNldDogbWV0YVByb3BzLmNoYXJTZXQgfSkgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoXCJzY3JpcHQ6bGQranNvblwiIGluIG1ldGFQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHNbXCJzY3JpcHQ6bGQranNvblwiXSk7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJzY3JpcHRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGBzY3JpcHQ6bGQranNvbjoke2pzb259YCxcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vbGQranNvblwiLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBlc2NhcGVIdG1sKGpzb24pIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsga2V5OiBKU09OLnN0cmluZ2lmeShtZXRhUHJvcHMpLCAuLi5tZXRhUHJvcHMgfSk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRhVGFnKHRhZ05hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0YWdOYW1lID09PSBcInN0cmluZ1wiICYmIC9eKG1ldGF8bGluaykkLy50ZXN0KHRhZ05hbWUpO1xufVxudmFyIGlzSHlkcmF0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldElzSHlkcmF0ZWQoKSB7XG4gIGlzSHlkcmF0ZWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gU2NyaXB0cyhzY3JpcHRQcm9wcykge1xuICBsZXQge1xuICAgIG1hbmlmZXN0LFxuICAgIHNlcnZlckhhbmRvZmZTdHJpbmcsXG4gICAgaXNTcGFNb2RlLFxuICAgIHJlbmRlck1ldGEsXG4gICAgcm91dGVEaXNjb3ZlcnksXG4gICAgc3NyXG4gIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7IHJvdXRlciwgc3RhdGljOiBpc1N0YXRpYywgc3RhdGljQ29udGV4dCB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQyKCk7XG4gIGxldCB7IG1hdGNoZXM6IHJvdXRlck1hdGNoZXMgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQoKTtcbiAgbGV0IGlzUlNDUm91dGVyQ29udGV4dCA9IHVzZUlzUlNDUm91dGVyQ29udGV4dCgpO1xuICBsZXQgZW5hYmxlRm9nT2ZXYXIgPSBpc0ZvZ09mV2FyRW5hYmxlZChyb3V0ZURpc2NvdmVyeSwgc3NyKTtcbiAgaWYgKHJlbmRlck1ldGEpIHtcbiAgICByZW5kZXJNZXRhLmRpZFJlbmRlclNjcmlwdHMgPSB0cnVlO1xuICB9XG4gIGxldCBtYXRjaGVzID0gZ2V0QWN0aXZlTWF0Y2hlcyhyb3V0ZXJNYXRjaGVzLCBudWxsLCBpc1NwYU1vZGUpO1xuICBSZWFjdDgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc0h5ZHJhdGVkKCk7XG4gIH0sIFtdKTtcbiAgbGV0IGluaXRpYWxTY3JpcHRzID0gUmVhY3Q4LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChpc1JTQ1JvdXRlckNvbnRleHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc3RyZWFtU2NyaXB0ID0gXCJ3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydChjb250cm9sbGVyKXt3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQuc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7fX0pLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKTtcIjtcbiAgICBsZXQgY29udGV4dFNjcmlwdCA9IHN0YXRpY0NvbnRleHQgPyBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0ID0gJHtzZXJ2ZXJIYW5kb2ZmU3RyaW5nfTske3N0cmVhbVNjcmlwdH1gIDogXCIgXCI7XG4gICAgbGV0IHJvdXRlTW9kdWxlc1NjcmlwdCA9ICFpc1N0YXRpYyA/IFwiIFwiIDogYCR7bWFuaWZlc3QuaG1yPy5ydW50aW1lID8gYGltcG9ydCAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0Lmhtci5ydW50aW1lKX07YCA6IFwiXCJ9JHshZW5hYmxlRm9nT2ZXYXIgPyBgaW1wb3J0ICR7SlNPTi5zdHJpbmdpZnkobWFuaWZlc3QudXJsKX1gIDogXCJcIn07XG4ke21hdGNoZXMubWFwKChtYXRjaCwgcm91dGVJbmRleCkgPT4ge1xuICAgICAgbGV0IHJvdXRlVmFyTmFtZSA9IGByb3V0ZSR7cm91dGVJbmRleH1gO1xuICAgICAgbGV0IG1hbmlmZXN0RW50cnkgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgaW52YXJpYW50MihtYW5pZmVzdEVudHJ5LCBgUm91dGUgJHttYXRjaC5yb3V0ZS5pZH0gbm90IGZvdW5kIGluIG1hbmlmZXN0YCk7XG4gICAgICBsZXQge1xuICAgICAgICBjbGllbnRBY3Rpb25Nb2R1bGUsXG4gICAgICAgIGNsaWVudExvYWRlck1vZHVsZSxcbiAgICAgICAgY2xpZW50TWlkZGxld2FyZU1vZHVsZSxcbiAgICAgICAgaHlkcmF0ZUZhbGxiYWNrTW9kdWxlLFxuICAgICAgICBtb2R1bGVcbiAgICAgIH0gPSBtYW5pZmVzdEVudHJ5O1xuICAgICAgbGV0IGNodW5rcyA9IFtcbiAgICAgICAgLi4uY2xpZW50QWN0aW9uTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogY2xpZW50QWN0aW9uTW9kdWxlLFxuICAgICAgICAgICAgdmFyTmFtZTogYCR7cm91dGVWYXJOYW1lfV9jbGllbnRBY3Rpb25gXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIC4uLmNsaWVudExvYWRlck1vZHVsZSA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2R1bGU6IGNsaWVudExvYWRlck1vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fY2xpZW50TG9hZGVyYFxuICAgICAgICAgIH1cbiAgICAgICAgXSA6IFtdLFxuICAgICAgICAuLi5jbGllbnRNaWRkbGV3YXJlTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogY2xpZW50TWlkZGxld2FyZU1vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fY2xpZW50TWlkZGxld2FyZWBcbiAgICAgICAgICB9XG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAgLi4uaHlkcmF0ZUZhbGxiYWNrTW9kdWxlID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZHVsZTogaHlkcmF0ZUZhbGxiYWNrTW9kdWxlLFxuICAgICAgICAgICAgdmFyTmFtZTogYCR7cm91dGVWYXJOYW1lfV9IeWRyYXRlRmFsbGJhY2tgXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIHsgbW9kdWxlLCB2YXJOYW1lOiBgJHtyb3V0ZVZhck5hbWV9X21haW5gIH1cbiAgICAgIF07XG4gICAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYGltcG9ydCAqIGFzICR7cm91dGVWYXJOYW1lfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkobW9kdWxlKX07YDtcbiAgICAgIH1cbiAgICAgIGxldCBjaHVua0ltcG9ydHNTbmlwcGV0ID0gY2h1bmtzLm1hcCgoY2h1bmspID0+IGBpbXBvcnQgKiBhcyAke2NodW5rLnZhck5hbWV9IGZyb20gXCIke2NodW5rLm1vZHVsZX1cIjtgKS5qb2luKFwiXFxuXCIpO1xuICAgICAgbGV0IG1lcmdlZENodW5rc1NuaXBwZXQgPSBgY29uc3QgJHtyb3V0ZVZhck5hbWV9ID0geyR7Y2h1bmtzLm1hcCgoY2h1bmspID0+IGAuLi4ke2NodW5rLnZhck5hbWV9YCkuam9pbihcIixcIil9fTtgO1xuICAgICAgcmV0dXJuIFtjaHVua0ltcG9ydHNTbmlwcGV0LCBtZXJnZWRDaHVua3NTbmlwcGV0XS5qb2luKFwiXFxuXCIpO1xuICAgIH0pLmpvaW4oXCJcXG5cIil9XG4gICR7ZW5hYmxlRm9nT2ZXYXIgPyAoXG4gICAgICAvLyBJbmxpbmUgYSBtaW5pbWFsIG1hbmlmZXN0IHdpdGggdGhlIFNTUiBtYXRjaGVzXG4gICAgICBgd2luZG93Ll9fcmVhY3RSb3V0ZXJNYW5pZmVzdCA9ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGdldFBhcnRpYWxNYW5pZmVzdChtYW5pZmVzdCwgcm91dGVyKSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMlxuICAgICAgKX07YFxuICAgICkgOiBcIlwifVxuICB3aW5kb3cuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcyA9IHske21hdGNoZXMubWFwKChtYXRjaCwgaW5kZXgpID0+IGAke0pTT04uc3RyaW5naWZ5KG1hdGNoLnJvdXRlLmlkKX06cm91dGUke2luZGV4fWApLmpvaW4oXCIsXCIpfX07XG5cbmltcG9ydCgke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LmVudHJ5Lm1vZHVsZSl9KTtgO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoUmVhY3Q4LkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICAuLi5zY3JpcHRQcm9wcyxcbiAgICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGNvbnRleHRTY3JpcHQgfSxcbiAgICAgICAgdHlwZTogdm9pZCAwXG4gICAgICB9XG4gICAgKSwgLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJzY3JpcHRcIixcbiAgICAgIHtcbiAgICAgICAgLi4uc2NyaXB0UHJvcHMsXG4gICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiByb3V0ZU1vZHVsZXNTY3JpcHQgfSxcbiAgICAgICAgdHlwZTogXCJtb2R1bGVcIixcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgIH1cbiAgICApKTtcbiAgfSwgW10pO1xuICBsZXQgcHJlbG9hZHMgPSBpc0h5ZHJhdGVkIHx8IGlzUlNDUm91dGVyQ29udGV4dCA/IFtdIDogZGVkdXBlKFxuICAgIG1hbmlmZXN0LmVudHJ5LmltcG9ydHMuY29uY2F0KFxuICAgICAgZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0LCB7XG4gICAgICAgIGluY2x1ZGVIeWRyYXRlRmFsbGJhY2s6IHRydWVcbiAgICAgIH0pXG4gICAgKVxuICApO1xuICBsZXQgc3JpID0gdHlwZW9mIG1hbmlmZXN0LnNyaSA9PT0gXCJvYmplY3RcIiA/IG1hbmlmZXN0LnNyaSA6IHt9O1xuICB3YXJuT25jZShcbiAgICAhaXNSU0NSb3V0ZXJDb250ZXh0LFxuICAgIFwiVGhlIDxTY3JpcHRzIC8+IGVsZW1lbnQgaXMgYSBuby1vcCB3aGVuIHVzaW5nIFJTQyBhbmQgY2FuIGJlIHNhZmVseSByZW1vdmVkLlwiXG4gICk7XG4gIHJldHVybiBpc0h5ZHJhdGVkIHx8IGlzUlNDUm91dGVyQ29udGV4dCA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoUmVhY3Q4LkZyYWdtZW50LCBudWxsLCB0eXBlb2YgbWFuaWZlc3Quc3JpID09PSBcIm9iamVjdFwiID8gLyogQF9fUFVSRV9fICovIFJlYWN0OC5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgXCJyci1pbXBvcnRtYXBcIjogXCJcIixcbiAgICAgIHR5cGU6IFwiaW1wb3J0bWFwXCIsXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpbnRlZ3JpdHk6IHNyaVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgKSA6IG51bGwsICFlbmFibGVGb2dPZldhciA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogbWFuaWZlc3QudXJsLFxuICAgICAgY3Jvc3NPcmlnaW46IHNjcmlwdFByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OiBzcmlbbWFuaWZlc3QudXJsXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSA6IG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDguY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmtcIixcbiAgICB7XG4gICAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgICAgaHJlZjogbWFuaWZlc3QuZW50cnkubW9kdWxlLFxuICAgICAgY3Jvc3NPcmlnaW46IHNjcmlwdFByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OiBzcmlbbWFuaWZlc3QuZW50cnkubW9kdWxlXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSwgcHJlbG9hZHMubWFwKChwYXRoKSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3Q4LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5rXCIsXG4gICAge1xuICAgICAga2V5OiBwYXRoLFxuICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgIGhyZWY6IHBhdGgsXG4gICAgICBjcm9zc09yaWdpbjogc2NyaXB0UHJvcHMuY3Jvc3NPcmlnaW4sXG4gICAgICBpbnRlZ3JpdHk6IHNyaVtwYXRoXSxcbiAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZVxuICAgIH1cbiAgKSksIGluaXRpYWxTY3JpcHRzKTtcbn1cbmZ1bmN0aW9uIGRlZHVwZShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIG1lcmdlUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiAodmFsdWUpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9lcnJvckJvdW5kYXJpZXMudHN4XG52YXIgUmVtaXhFcnJvckJvdW5kYXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDkuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbiB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbiB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlcnJvcjogcHJvcHMuZXJyb3IgfHwgc3RhdGUuZXJyb3IsIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbiB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnksXG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICBpc091dHNpZGVSZW1peEFwcDogdHJ1ZVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSh7XG4gIGVycm9yLFxuICBpc091dHNpZGVSZW1peEFwcFxufSkge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgbGV0IGhleURldmVsb3BlciA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYFxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9LiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMuIENoZWNrIG91dCBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob3ctdG8vZXJyb3ItYm91bmRhcnkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIGBcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KEJvdW5kYXJ5U2hlbGwsIHsgdGl0bGU6IFwiVW5oYW5kbGVkIFRocm93biBSZXNwb25zZSFcIiB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7IHN0eWxlOiB7IGZvbnRTaXplOiBcIjI0cHhcIiB9IH0sIGVycm9yLnN0YXR1cywgXCIgXCIsIGVycm9yLnN0YXR1c1RleHQpLCBFTkFCTEVfREVWX1dBUk5JTkdTID8gaGV5RGV2ZWxvcGVyIDogbnVsbCk7XG4gIH1cbiAgbGV0IGVycm9ySW5zdGFuY2U7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgZXJyb3JJbnN0YW5jZSA9IGVycm9yO1xuICB9IGVsc2Uge1xuICAgIGxldCBlcnJvclN0cmluZyA9IGVycm9yID09IG51bGwgPyBcIlVua25vd24gRXJyb3JcIiA6IHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcInRvU3RyaW5nXCIgaW4gZXJyb3IgPyBlcnJvci50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICAgIGVycm9ySW5zdGFuY2UgPSBuZXcgRXJyb3IoZXJyb3JTdHJpbmcpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgQm91bmRhcnlTaGVsbCxcbiAgICB7XG4gICAgICB0aXRsZTogXCJBcHBsaWNhdGlvbiBFcnJvciFcIixcbiAgICAgIGlzT3V0c2lkZVJlbWl4QXBwXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7IHN0eWxlOiB7IGZvbnRTaXplOiBcIjI0cHhcIiB9IH0sIFwiQXBwbGljYXRpb24gRXJyb3JcIiksXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJwcmVcIixcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwYWRkaW5nOiBcIjJyZW1cIixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcImhzbGEoMTAsIDUwJSwgNTAlLCAwLjEpXCIsXG4gICAgICAgICAgY29sb3I6IFwicmVkXCIsXG4gICAgICAgICAgb3ZlcmZsb3c6IFwiYXV0b1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlcnJvckluc3RhbmNlLnN0YWNrXG4gICAgKSxcbiAgICBoZXlEZXZlbG9wZXJcbiAgKTtcbn1cbmZ1bmN0aW9uIEJvdW5kYXJ5U2hlbGwoe1xuICB0aXRsZSxcbiAgcmVuZGVyU2NyaXB0cyxcbiAgaXNPdXRzaWRlUmVtaXhBcHAsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGxldCB7IHJvdXRlTW9kdWxlcyB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBpZiAocm91dGVNb2R1bGVzLnJvb3Q/LkxheW91dCAmJiAhaXNPdXRzaWRlUmVtaXhBcHApIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImh0bWxcIiwgeyBsYW5nOiBcImVuXCIgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHsgY2hhclNldDogXCJ1dGYtOFwiIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJtZXRhXCIsXG4gICAge1xuICAgICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgICAgY29udGVudDogXCJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLHZpZXdwb3J0LWZpdD1jb3ZlclwiXG4gICAgfVxuICApLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCB0aXRsZSkpLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcIm1haW5cIiwgeyBzdHlsZTogeyBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLCBwYWRkaW5nOiBcIjJyZW1cIiB9IH0sIGNoaWxkcmVuLCByZW5kZXJTY3JpcHRzID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFNjcmlwdHMsIG51bGwpIDogbnVsbCkpKTtcbn1cblxuLy8gbGliL2RvbS9saWIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDEwIGZyb20gXCJyZWFjdFwiO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG50cnkge1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgd2luZG93Ll9fcmVhY3RSb3V0ZXJWZXJzaW9uID0gLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIFwiNy45LjNcIjtcbiAgfVxufSBjYXRjaCAoZSkge1xufVxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIGdldENvbnRleHQ6IG9wdHM/LmdldENvbnRleHQsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICAgIGRhdGFTdHJhdGVneTogb3B0cz8uZGF0YVN0cmF0ZWd5LFxuICAgIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uOiBvcHRzPy5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbixcbiAgICB3aW5kb3c6IG9wdHM/LndpbmRvd1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVIYXNoUm91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cz8uYmFzZW5hbWUsXG4gICAgZ2V0Q29udGV4dDogb3B0cz8uZ2V0Q29udGV4dCxcbiAgICBmdXR1cmU6IG9wdHM/LmZ1dHVyZSxcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdzogb3B0cz8ud2luZG93IH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllcyxcbiAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gICAgZGF0YVN0cmF0ZWd5OiBvcHRzPy5kYXRhU3RyYXRlZ3ksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHM/LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uLFxuICAgIHdpbmRvdzogb3B0cz8ud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gd2luZG93Py5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWFsaXplZFtrZXldID09IG51bGwpIHtcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKHZhbC5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIHdpbmRvdzogd2luZG93MlxufSkge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0MTAudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93OiB3aW5kb3cyLCB2NUNvbXBhdDogdHJ1ZSB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0MTAudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDEwLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGxdXG4gICk7XG4gIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEhhc2hSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIHdpbmRvdzogd2luZG93MiB9KSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QxMC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IHdpbmRvdzIsIHY1Q29tcGF0OiB0cnVlIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaGlzdG9yeVxufSkge1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QxMC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUpID0+IHtcbiAgICAgIFJlYWN0MTAuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gICAgfVxuICApO1xufVxuSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWDIgPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG52YXIgTGluayA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgZnVuY3Rpb24gTGlua1dpdGhSZWYoe1xuICAgIG9uQ2xpY2ssXG4gICAgZGlzY292ZXIgPSBcInJlbmRlclwiLFxuICAgIHByZWZldGNoID0gXCJub25lXCIsXG4gICAgcmVsYXRpdmUsXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgc3RhdGUsXG4gICAgdGFyZ2V0LFxuICAgIHRvLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICB2aWV3VHJhbnNpdGlvbixcbiAgICAuLi5yZXN0XG4gIH0sIGZvcndhcmRlZFJlZikge1xuICAgIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICAgIGxldCBpc0Fic29sdXRlID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiICYmIEFCU09MVVRFX1VSTF9SRUdFWDIudGVzdCh0byk7XG4gICAgbGV0IGFic29sdXRlSHJlZjtcbiAgICBsZXQgaXNFeHRlcm5hbCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgYWJzb2x1dGVIcmVmID0gdG87XG4gICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgdG8pIDogbmV3IFVSTCh0byk7XG4gICAgICAgICAgbGV0IHBhdGggPSBzdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgYDxMaW5rIHRvPVwiJHt0b31cIj4gY29udGFpbnMgYW4gaW52YWxpZCBVUkwgd2hpY2ggd2lsbCBwcm9iYWJseSBicmVhayB3aGVuIGNsaWNrZWQgLSBwbGVhc2UgdXBkYXRlIHRvIGEgdmFsaWQgVVJMIHBhdGguYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvLCB7IHJlbGF0aXZlIH0pO1xuICAgIGxldCBbc2hvdWxkUHJlZmV0Y2gsIHByZWZldGNoUmVmLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IoXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIHJlc3RcbiAgICApO1xuICAgIGxldCBpbnRlcm5hbE9uQ2xpY2sgPSB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7XG4gICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICB2aWV3VHJhbnNpdGlvblxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxpbmsgPSAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcImFcIixcbiAgICAgICAge1xuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgLi4ucHJlZmV0Y2hIYW5kbGVycyxcbiAgICAgICAgICBocmVmOiBhYnNvbHV0ZUhyZWYgfHwgaHJlZixcbiAgICAgICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxuICAgICAgICAgIHJlZjogbWVyZ2VSZWZzKGZvcndhcmRlZFJlZiwgcHJlZmV0Y2hSZWYpLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBcImRhdGEtZGlzY292ZXJcIjogIWlzQWJzb2x1dGUgJiYgZGlzY292ZXIgPT09IFwicmVuZGVyXCIgPyBcInRydWVcIiA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gc2hvdWxkUHJlZmV0Y2ggJiYgIWlzQWJzb2x1dGUgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFJlYWN0MTAuRnJhZ21lbnQsIG51bGwsIGxpbmssIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3MsIHsgcGFnZTogaHJlZiB9KSkgOiBsaW5rO1xuICB9XG4pO1xuTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xudmFyIE5hdkxpbmsgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICBlbmQgPSBmYWxzZSxcbiAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgIHRvLFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIGNoaWxkcmVuLFxuICAgIC4uLnJlc3RcbiAgfSwgcmVmKSB7XG4gICAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmUgfSk7XG4gICAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcm91dGVyU3RhdGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICAgbGV0IHsgbmF2aWdhdG9yLCBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgaXNUcmFuc2l0aW9uaW5nID0gcm91dGVyU3RhdGUgIT0gbnVsbCAmJiAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZShwYXRoKSAmJiB2aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcbiAgICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZSA6IHBhdGgucGF0aG5hbWU7XG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSByb3V0ZXJTdGF0ZSAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gPyByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLnBhdGhuYW1lIDogbnVsbDtcbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAobmV4dExvY2F0aW9uUGF0aG5hbWUgJiYgYmFzZW5hbWUpIHtcbiAgICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb25QYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvblBhdGhuYW1lO1xuICAgIH1cbiAgICBjb25zdCBlbmRTbGFzaFBvc2l0aW9uID0gdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lLmxlbmd0aCAtIDEgOiB0b1BhdGhuYW1lLmxlbmd0aDtcbiAgICBsZXQgaXNBY3RpdmUgPSBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KGVuZFNsYXNoUG9zaXRpb24pID09PSBcIi9cIjtcbiAgICBsZXQgaXNQZW5kaW5nID0gbmV4dExvY2F0aW9uUGF0aG5hbWUgIT0gbnVsbCAmJiAobmV4dExvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHwgIWVuZCAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKTtcbiAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICBpc0FjdGl2ZSxcbiAgICAgIGlzUGVuZGluZyxcbiAgICAgIGlzVHJhbnNpdGlvbmluZ1xuICAgIH07XG4gICAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB2b2lkIDA7XG4gICAgbGV0IGNsYXNzTmFtZTtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcChyZW5kZXJQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzTmFtZSA9IFtcbiAgICAgICAgY2xhc3NOYW1lUHJvcCxcbiAgICAgICAgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCxcbiAgICAgICAgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsLFxuICAgICAgICBpc1RyYW5zaXRpb25pbmcgPyBcInRyYW5zaXRpb25pbmdcIiA6IG51bGxcbiAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AocmVuZGVyUHJvcHMpIDogc3R5bGVQcm9wO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgICAgTGluayxcbiAgICAgIHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnQsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcmVmLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgdG8sXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgICB9LFxuICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihyZW5kZXJQcm9wcykgOiBjaGlsZHJlblxuICAgICk7XG4gIH1cbik7XG5OYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG52YXIgRm9ybSA9IFJlYWN0MTAuZm9yd2FyZFJlZihcbiAgKHtcbiAgICBkaXNjb3ZlciA9IFwicmVuZGVyXCIsXG4gICAgZmV0Y2hlcktleSxcbiAgICBuYXZpZ2F0ZSxcbiAgICByZWxvYWREb2N1bWVudCxcbiAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICBzdGF0ZSxcbiAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kLFxuICAgIGFjdGlvbixcbiAgICBvblN1Ym1pdCxcbiAgICByZWxhdGl2ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgdmlld1RyYW5zaXRpb24sXG4gICAgLi4ucHJvcHNcbiAgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdCgpO1xuICAgIGxldCBmb3JtQWN0aW9uID0gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHsgcmVsYXRpdmUgfSk7XG4gICAgbGV0IGZvcm1NZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBsZXQgaXNBYnNvbHV0ZSA9IHR5cGVvZiBhY3Rpb24gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYMi50ZXN0KGFjdGlvbik7XG4gICAgbGV0IHN1Ym1pdEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbGV0IHN1Ym1pdHRlciA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICAgIGxldCBzdWJtaXRNZXRob2QgPSBzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgbWV0aG9kO1xuICAgICAgc3VibWl0KHN1Ym1pdHRlciB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIG1ldGhvZDogc3VibWl0TWV0aG9kLFxuICAgICAgICBuYXZpZ2F0ZSxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICB2aWV3VHJhbnNpdGlvblxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiZm9ybVwiLFxuICAgICAge1xuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgICAgICBhY3Rpb246IGZvcm1BY3Rpb24sXG4gICAgICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlcixcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIFwiZGF0YS1kaXNjb3ZlclwiOiAhaXNBYnNvbHV0ZSAmJiBkaXNjb3ZlciA9PT0gXCJyZW5kZXJcIiA/IFwidHJ1ZVwiIDogdm9pZCAwXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcbkZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbmZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKHtcbiAgZ2V0S2V5LFxuICBzdG9yYWdlS2V5LFxuICAuLi5wcm9wc1xufSkge1xuICBsZXQgcmVtaXhDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KEZyYW1ld29ya0NvbnRleHQpO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKHsgZ2V0S2V5LCBzdG9yYWdlS2V5IH0pO1xuICBsZXQgc3NyS2V5ID0gUmVhY3QxMC51c2VNZW1vKFxuICAgICgpID0+IHtcbiAgICAgIGlmICghcmVtaXhDb250ZXh0IHx8ICFnZXRLZXkpIHJldHVybiBudWxsO1xuICAgICAgbGV0IHVzZXJLZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBnZXRLZXlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdXNlcktleSAhPT0gbG9jYXRpb24ua2V5ID8gdXNlcktleSA6IG51bGw7XG4gICAgfSxcbiAgICAvLyBOYWgsIHdlIG9ubHkgbmVlZCB0aGlzIHRoZSBmaXJzdCB0aW1lIGZvciB0aGUgU1NSIHJlbmRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXVxuICApO1xuICBpZiAoIXJlbWl4Q29udGV4dCB8fCByZW1peENvbnRleHQuaXNTcGFNb2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHJlc3RvcmVTY3JvbGwgPSAoKHN0b3JhZ2VLZXkyLCByZXN0b3JlS2V5KSA9PiB7XG4gICAgaWYgKCF3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCAhd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5KSB7XG4gICAgICBsZXQga2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzMikuc2xpY2UoMik7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXkgfSwgXCJcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgcG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkyKSB8fCBcInt9XCIpO1xuICAgICAgbGV0IHN0b3JlZFkgPSBwb3NpdGlvbnNbcmVzdG9yZUtleSB8fCB3aW5kb3cuaGlzdG9yeS5zdGF0ZS5rZXldO1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZWRZID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzdG9yZWRZKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkyKTtcbiAgICB9XG4gIH0pLnRvU3RyaW5nKCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGAoJHtyZXN0b3JlU2Nyb2xsfSkoJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWVxuICAgICAgICApfSwgJHtKU09OLnN0cmluZ2lmeShzc3JLZXkpfSlgXG4gICAgICB9XG4gICAgfVxuICApO1xufVxuU2Nyb2xsUmVzdG9yYXRpb24uZGlzcGxheU5hbWUgPSBcIlNjcm9sbFJlc3RvcmF0aW9uXCI7XG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yMihob29rTmFtZSkge1xuICByZXR1cm4gYCR7aG9va05hbWV9IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9lbi9tYWluL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5gO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQzKGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpbnZhcmlhbnQoY3R4LCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yMihob29rTmFtZSkpO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlMihob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudChzdGF0ZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xuICB0YXJnZXQsXG4gIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICBzdGF0ZSxcbiAgcHJldmVudFNjcm9sbFJlc2V0LFxuICByZWxhdGl2ZSxcbiAgdmlld1RyYW5zaXRpb25cbn0gPSB7fSkge1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9KTtcbiAgcmV0dXJuIFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgcmVwbGFjZTIgPSByZXBsYWNlUHJvcCAhPT0gdm9pZCAwID8gcmVwbGFjZVByb3AgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcbiAgICAgICAgbmF2aWdhdGUodG8sIHtcbiAgICAgICAgICByZXBsYWNlOiByZXBsYWNlMixcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgICAgdmlld1RyYW5zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcGF0aCxcbiAgICAgIHJlcGxhY2VQcm9wLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0byxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgdmlld1RyYW5zaXRpb25cbiAgICBdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpIHtcbiAgd2FybmluZyhcbiAgICB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIGBZb3UgY2Fubm90IHVzZSB0aGUgXFxgdXNlU2VhcmNoUGFyYW1zXFxgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXMuYFxuICApO1xuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0MTAudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuICBsZXQgaGFzU2V0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QxMC51c2VSZWYoZmFsc2UpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gUmVhY3QxMC51c2VNZW1vKFxuICAgICgpID0+IChcbiAgICAgIC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gICAgICAvLyBPbmNlIHdlIGNhbGwgdGhhdCB3ZSB3YW50IHRob3NlIHRvIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHlvdSBjYW4ndFxuICAgICAgLy8gcmVtb3ZlIGEgcGFyYW0gd2l0aCBzZXRTZWFyY2hQYXJhbXMoe30pIGlmIGl0IGhhcyBhbiBpbml0aWFsIHZhbHVlXG4gICAgICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihcbiAgICAgICAgbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA/IG51bGwgOiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnRcbiAgICAgIClcbiAgICApLFxuICAgIFtsb2NhdGlvbi5zZWFyY2hdXG4gICk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBuZXdTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gICAgICAgIHR5cGVvZiBuZXh0SW5pdCA9PT0gXCJmdW5jdGlvblwiID8gbmV4dEluaXQobmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpKSA6IG5leHRJbml0XG4gICAgICApO1xuICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfSxcbiAgICBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc11cbiAgKTtcbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc107XG59XG52YXIgZmV0Y2hlcklkID0gMDtcbnZhciBnZXRVbmlxdWVGZXRjaGVySWQgPSAoKSA9PiBgX18ke1N0cmluZygrK2ZldGNoZXJJZCl9X19gO1xuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MyhcInVzZVN1Ym1pdFwiIC8qIFVzZVN1Ym1pdCAqLyk7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgY3VycmVudFJvdXRlSWQgPSB1c2VSb3V0ZUlkKCk7XG4gIHJldHVybiBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh0YXJnZXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgbGV0IHsgYWN0aW9uLCBtZXRob2QsIGVuY1R5cGUsIGZvcm1EYXRhLCBib2R5IH0gPSBnZXRGb3JtU3VibWlzc2lvbkluZm8oXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgYmFzZW5hbWVcbiAgICAgICk7XG4gICAgICBpZiAob3B0aW9ucy5uYXZpZ2F0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGtleSA9IG9wdGlvbnMuZmV0Y2hlcktleSB8fCBnZXRVbmlxdWVGZXRjaGVySWQoKTtcbiAgICAgICAgYXdhaXQgcm91dGVyLmZldGNoKGtleSwgY3VycmVudFJvdXRlSWQsIG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICAgIGZsdXNoU3luYzogb3B0aW9ucy5mbHVzaFN5bmNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCByb3V0ZXIubmF2aWdhdGUob3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXG4gICAgICAgICAgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlLFxuICAgICAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgICAgIGZyb21Sb3V0ZUlkOiBjdXJyZW50Um91dGVJZCxcbiAgICAgICAgICBmbHVzaFN5bmM6IG9wdGlvbnMuZmx1c2hTeW5jLFxuICAgICAgICAgIHZpZXdUcmFuc2l0aW9uOiBvcHRpb25zLnZpZXdUcmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3JvdXRlciwgYmFzZW5hbWUsIGN1cnJlbnRSb3V0ZUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGxldCB7IGJhc2VuYW1lIH0gPSBSZWFjdDEwLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QxMC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGludmFyaWFudChyb3V0ZUNvbnRleHQsIFwidXNlRm9ybUFjdGlvbiBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0XCIpO1xuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTtcbiAgbGV0IHBhdGggPSB7IC4uLnVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwgeyByZWxhdGl2ZSB9KSB9O1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBpZiAoYWN0aW9uID09IG51bGwpIHtcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgbGV0IGluZGV4VmFsdWVzID0gcGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICAgIGxldCBoYXNOYWtlZEluZGV4UGFyYW0gPSBpbmRleFZhbHVlcy5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbiAgICBpZiAoaGFzTmFrZWRJbmRleFBhcmFtKSB7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBpbmRleFZhbHVlcy5maWx0ZXIoKHYpID0+IHYpLmZvckVhY2goKHYpID0+IHBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB2KSk7XG4gICAgICBsZXQgcXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcXMgPyBgPyR7cXN9YCA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG5mdW5jdGlvbiB1c2VGZXRjaGVyKHtcbiAga2V5XG59ID0ge30pIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXCJ1c2VGZXRjaGVyXCIgLyogVXNlRmV0Y2hlciAqLyk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZTIoXCJ1c2VGZXRjaGVyXCIgLyogVXNlRmV0Y2hlciAqLyk7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0MTAudXNlQ29udGV4dChGZXRjaGVyc0NvbnRleHQpO1xuICBsZXQgcm91dGUgPSBSZWFjdDEwLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlSWQgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0/LnJvdXRlLmlkO1xuICBpbnZhcmlhbnQoZmV0Y2hlckRhdGEsIGB1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBGZXRjaGVyc0NvbnRleHRgKTtcbiAgaW52YXJpYW50KHJvdXRlLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0YCk7XG4gIGludmFyaWFudChcbiAgICByb3V0ZUlkICE9IG51bGwsXG4gICAgYHVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFwiaWRcImBcbiAgKTtcbiAgbGV0IGRlZmF1bHRLZXkgPSBSZWFjdDEwLnVzZUlkKCk7XG4gIGxldCBbZmV0Y2hlcktleSwgc2V0RmV0Y2hlcktleV0gPSBSZWFjdDEwLnVzZVN0YXRlKGtleSB8fCBkZWZhdWx0S2V5KTtcbiAgaWYgKGtleSAmJiBrZXkgIT09IGZldGNoZXJLZXkpIHtcbiAgICBzZXRGZXRjaGVyS2V5KGtleSk7XG4gIH1cbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJvdXRlci5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIHJldHVybiAoKSA9PiByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgfSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xuICBsZXQgbG9hZCA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGhyZWYsIG9wdHMpID0+IHtcbiAgICAgIGludmFyaWFudChyb3V0ZUlkLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKTtcbiAgICAgIGF3YWl0IHJvdXRlci5mZXRjaChmZXRjaGVyS2V5LCByb3V0ZUlkLCBocmVmLCBvcHRzKTtcbiAgICB9LFxuICAgIFtmZXRjaGVyS2V5LCByb3V0ZUlkLCByb3V0ZXJdXG4gICk7XG4gIGxldCBzdWJtaXRJbXBsID0gdXNlU3VibWl0KCk7XG4gIGxldCBzdWJtaXQgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh0YXJnZXQsIG9wdHMpID0+IHtcbiAgICAgIGF3YWl0IHN1Ym1pdEltcGwodGFyZ2V0LCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIG5hdmlnYXRlOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hlcktleVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbZmV0Y2hlcktleSwgc3VibWl0SW1wbF1cbiAgKTtcbiAgbGV0IHVuc3RhYmxlX3Jlc2V0ID0gUmVhY3QxMC51c2VDYWxsYmFjaygob3B0cykgPT4gcm91dGVyLnJlc2V0RmV0Y2hlcihmZXRjaGVyS2V5LCBvcHRzKSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdDEwLnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBGZXRjaGVyRm9ybTIgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gICAgICAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChGb3JtLCB7IC4uLnByb3BzLCBuYXZpZ2F0ZTogZmFsc2UsIGZldGNoZXJLZXksIHJlZiB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIEZldGNoZXJGb3JtMi5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gICAgcmV0dXJuIEZldGNoZXJGb3JtMjtcbiAgfSwgW2ZldGNoZXJLZXldKTtcbiAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoZmV0Y2hlcktleSkgfHwgSURMRV9GRVRDSEVSO1xuICBsZXQgZGF0YTIgPSBmZXRjaGVyRGF0YS5nZXQoZmV0Y2hlcktleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdDEwLnVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIEZvcm06IEZldGNoZXJGb3JtLFxuICAgICAgc3VibWl0LFxuICAgICAgbG9hZCxcbiAgICAgIHVuc3RhYmxlX3Jlc2V0LFxuICAgICAgLi4uZmV0Y2hlcixcbiAgICAgIGRhdGE6IGRhdGEyXG4gICAgfSksXG4gICAgW0ZldGNoZXJGb3JtLCBzdWJtaXQsIGxvYWQsIHVuc3RhYmxlX3Jlc2V0LCBmZXRjaGVyLCBkYXRhMl1cbiAgKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbmZ1bmN0aW9uIHVzZUZldGNoZXJzKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUyKFwidXNlRmV0Y2hlcnNcIiAvKiBVc2VGZXRjaGVycyAqLyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHN0YXRlLmZldGNoZXJzLmVudHJpZXMoKSkubWFwKChba2V5LCBmZXRjaGVyXSkgPT4gKHtcbiAgICAuLi5mZXRjaGVyLFxuICAgIGtleVxuICB9KSk7XG59XG52YXIgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItc2Nyb2xsLXBvc2l0aW9uc1wiO1xudmFyIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0ge307XG5mdW5jdGlvbiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIGdldEtleSkge1xuICBsZXQga2V5ID0gbnVsbDtcbiAgaWYgKGdldEtleSkge1xuICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgIGtleSA9IGdldEtleShcbiAgICAgICAge1xuICAgICAgICAgIC4uLmxvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAga2V5ID0gbG9jYXRpb24ua2V5O1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleVxufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIiAvKiBVc2VTY3JvbGxSZXN0b3JhdGlvbiAqLyk7XG4gIGxldCB7IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0IH0gPSB1c2VEYXRhUm91dGVyU3RhdGUyKFxuICAgIFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIiAvKiBVc2VTY3JvbGxSZXN0b3JhdGlvbiAqL1xuICApO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1hdGNoZXMgPSB1c2VNYXRjaGVzKCk7XG4gIGxldCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlUGFnZUhpZGUoXG4gICAgUmVhY3QxMC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBpZiAobmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCBtYXRjaGVzLCBiYXNlbmFtZSwgZ2V0S2V5KTtcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShzYXZlZFNjcm9sbFBvc2l0aW9ucylcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYEZhaWxlZCB0byBzYXZlIHNjcm9sbCBwb3NpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UsIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB3aWxsIG5vdCB3b3JrIHByb3Blcmx5ICgke2Vycm9yfSkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9LCBbbmF2aWdhdGlvbi5zdGF0ZSwgZ2V0S2V5LCBiYXNlbmFtZSwgbG9jYXRpb24sIG1hdGNoZXMsIHN0b3JhZ2VLZXldKVxuICApO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgICAgIHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfSwgW3N0b3JhZ2VLZXldKTtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyPy5lbmFibGVTY3JvbGxSZXN0b3JhdGlvbihcbiAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMsXG4gICAgICAgICgpID0+IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICBnZXRLZXkgPyAobG9jYXRpb24yLCBtYXRjaGVzMikgPT4gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24yLCBtYXRjaGVzMiwgYmFzZW5hbWUsIGdldEtleSkgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4gZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uICYmIGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbigpO1xuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcbiAgICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgYFwiJHtsb2NhdGlvbi5oYXNoLnNsaWNlKFxuICAgICAgICAgICAgMVxuICAgICAgICAgICl9XCIgaXMgbm90IGEgZGVjb2RhYmxlIGVsZW1lbnQgSUQuIFRoZSB2aWV3IHdpbGwgbm90IHNjcm9sbCB0byBpdC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7IGNhcHR1cmUgfSA6IHZvaWQgMDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGxldCB7IGNhcHR1cmUgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHsgY2FwdHVyZSB9IDogdm9pZCAwO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbmZ1bmN0aW9uIHVzZVByb21wdCh7XG4gIHdoZW4sXG4gIG1lc3NhZ2Vcbn0pIHtcbiAgbGV0IGJsb2NrZXIgPSB1c2VCbG9ja2VyKHdoZW4pO1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICBsZXQgcHJvY2VlZCA9IHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpO1xuICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cbmZ1bmN0aW9uIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUodG8sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGxldCB2dENvbnRleHQgPSBSZWFjdDEwLnVzZUNvbnRleHQoVmlld1RyYW5zaXRpb25Db250ZXh0KTtcbiAgaW52YXJpYW50KFxuICAgIHZ0Q29udGV4dCAhPSBudWxsLFxuICAgIFwiYHVzZVZpZXdUcmFuc2l0aW9uU3RhdGVgIG11c3QgYmUgdXNlZCB3aXRoaW4gYHJlYWN0LXJvdXRlci1kb21gJ3MgYFJvdXRlclByb3ZpZGVyYC4gIERpZCB5b3UgYWNjaWRlbnRhbGx5IGltcG9ydCBgUm91dGVyUHJvdmlkZXJgIGZyb20gYHJlYWN0LXJvdXRlcmA/XCJcbiAgKTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MyhcbiAgICBcInVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcIiAvKiB1c2VWaWV3VHJhbnNpdGlvblN0YXRlICovXG4gICk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlIH0pO1xuICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGN1cnJlbnRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgbGV0IG5leHRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcbiAgcmV0dXJuIG1hdGNoUGF0aChwYXRoLnBhdGhuYW1lLCBuZXh0UGF0aCkgIT0gbnVsbCB8fCBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgY3VycmVudFBhdGgpICE9IG51bGw7XG59XG5cbi8vIGxpYi9kb20vc2VydmVyLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QxMSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIFN0YXRpY1JvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCA9IFwiL1wiXG59KSB7XG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cbiAgbGV0IGFjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUHJvcC5wYXRobmFtZSB8fCBcIi9cIixcbiAgICBzZWFyY2g6IGxvY2F0aW9uUHJvcC5zZWFyY2ggfHwgXCJcIixcbiAgICBoYXNoOiBsb2NhdGlvblByb3AuaGFzaCB8fCBcIlwiLFxuICAgIHN0YXRlOiBsb2NhdGlvblByb3Auc3RhdGUgIT0gbnVsbCA/IGxvY2F0aW9uUHJvcC5zdGF0ZSA6IG51bGwsXG4gICAga2V5OiBsb2NhdGlvblByb3Aua2V5IHx8IFwiZGVmYXVsdFwiXG4gIH07XG4gIGxldCBzdGF0aWNOYXZpZ2F0b3IgPSBnZXRTdGF0ZWxlc3NOYXZpZ2F0b3IoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBhY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IHN0YXRpY05hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogdHJ1ZVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIFN0YXRpY1JvdXRlclByb3ZpZGVyKHtcbiAgY29udGV4dCxcbiAgcm91dGVyLFxuICBoeWRyYXRlOiBoeWRyYXRlMiA9IHRydWUsXG4gIG5vbmNlXG59KSB7XG4gIGludmFyaWFudChcbiAgICByb3V0ZXIgJiYgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYHJvdXRlcmAgYW5kIGBjb250ZXh0YCB0byA8U3RhdGljUm91dGVyUHJvdmlkZXI+XCJcbiAgKTtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0ge1xuICAgIHJvdXRlcixcbiAgICBuYXZpZ2F0b3I6IGdldFN0YXRlbGVzc05hdmlnYXRvcigpLFxuICAgIHN0YXRpYzogdHJ1ZSxcbiAgICBzdGF0aWNDb250ZXh0OiBjb250ZXh0LFxuICAgIGJhc2VuYW1lOiBjb250ZXh0LmJhc2VuYW1lIHx8IFwiL1wiXG4gIH07XG4gIGxldCBmZXRjaGVyc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaHlkcmF0ZVNjcmlwdCA9IFwiXCI7XG4gIGlmIChoeWRyYXRlMiAhPT0gZmFsc2UpIHtcbiAgICBsZXQgZGF0YTIgPSB7XG4gICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICBlcnJvcnM6IHNlcmlhbGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycylcbiAgICB9O1xuICAgIGxldCBqc29uID0gaHRtbEVzY2FwZShKU09OLnN0cmluZ2lmeShKU09OLnN0cmluZ2lmeShkYXRhMikpKTtcbiAgICBoeWRyYXRlU2NyaXB0ID0gYHdpbmRvdy5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEgPSBKU09OLnBhcnNlKCR7anNvbn0pO2A7XG4gIH1cbiAgbGV0IHsgc3RhdGUgfSA9IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlcjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzdGF0ZSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZmV0Y2hlcnNDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoVmlld1RyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZTogZGF0YVJvdXRlckNvbnRleHQuYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogZGF0YVJvdXRlckNvbnRleHQubmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBEYXRhUm91dGVzMixcbiAgICAgIHtcbiAgICAgICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgICAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgICAgIHN0YXRlXG4gICAgICB9XG4gICAgKVxuICApKSkpKSwgaHlkcmF0ZVNjcmlwdCA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBub25jZSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogaHlkcmF0ZVNjcmlwdCB9XG4gICAgfVxuICApIDogbnVsbCk7XG59XG5mdW5jdGlvbiBEYXRhUm91dGVzMih7XG4gIHJvdXRlcyxcbiAgZnV0dXJlLFxuICBzdGF0ZVxufSkge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHZvaWQgMCwgc3RhdGUsIHZvaWQgMCwgZnV0dXJlKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmIChpc1JvdXRlRXJyb3JSZXNwb25zZSh2YWwpKSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7IC4uLnZhbCwgX190eXBlOiBcIlJvdXRlRXJyb3JSZXNwb25zZVwiIH07XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0ge1xuICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgX190eXBlOiBcIkVycm9yXCIsXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdWJjbGFzcyAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpLCBzZW5kIHVwIHRoZSB0eXBlIHNvIHdlXG4gICAgICAgIC8vIGNhbiByZS1jcmVhdGUgdGhlIHNhbWUgdHlwZSBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAuLi52YWwubmFtZSAhPT0gXCJFcnJvclwiID8ge1xuICAgICAgICAgIF9fc3ViVHlwZTogdmFsLm5hbWVcbiAgICAgICAgfSA6IHt9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVsZXNzTmF2aWdhdG9yKCkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZUhyZWYsXG4gICAgZW5jb2RlTG9jYXRpb24sXG4gICAgcHVzaCh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZ28oKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJhY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBlbnZpcm9ubWVudC5gXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIHtcbiAgICAuLi5vcHRzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1JvdXRlcihyb3V0ZXMsIGNvbnRleHQsIG9wdHMgPSB7fSkge1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgdm9pZCAwLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBtYXRjaGVzID0gY29udGV4dC5tYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFttYXRjaC5yb3V0ZS5pZF0gfHwgbWF0Y2gucm91dGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm1hdGNoLFxuICAgICAgcm91dGVcbiAgICB9O1xuICB9KTtcbiAgbGV0IG1zZyA9IChtZXRob2QpID0+IGBZb3UgY2Fubm90IHVzZSByb3V0ZXIuJHttZXRob2R9KCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50YDtcbiAgcmV0dXJuIHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5iYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OF9taWRkbGV3YXJlOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0cz8uZnV0dXJlXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGlzdG9yeUFjdGlvbjogXCJQT1BcIiAvKiBQb3AgKi8sXG4gICAgICAgIGxvY2F0aW9uOiBjb250ZXh0LmxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICAgIGFjdGlvbkRhdGE6IGNvbnRleHQuYWN0aW9uRGF0YSxcbiAgICAgICAgZXJyb3JzOiBjb250ZXh0LmVycm9ycyxcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBudWxsLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgICAgICByZXZhbGlkYXRpb246IFwiaWRsZVwiLFxuICAgICAgICBmZXRjaGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgICAgYmxvY2tlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9LFxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJpbml0aWFsaXplXCIpO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgdGhyb3cgbXNnKFwic3Vic2NyaWJlXCIpO1xuICAgIH0sXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gICAgICB0aHJvdyBtc2coXCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvblwiKTtcbiAgICB9LFxuICAgIG5hdmlnYXRlKCkge1xuICAgICAgdGhyb3cgbXNnKFwibmF2aWdhdGVcIik7XG4gICAgfSxcbiAgICBmZXRjaCgpIHtcbiAgICAgIHRocm93IG1zZyhcImZldGNoXCIpO1xuICAgIH0sXG4gICAgcmV2YWxpZGF0ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcInJldmFsaWRhdGVcIik7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGVuY29kZUxvY2F0aW9uLFxuICAgIGdldEZldGNoZXIoKSB7XG4gICAgICByZXR1cm4gSURMRV9GRVRDSEVSO1xuICAgIH0sXG4gICAgZGVsZXRlRmV0Y2hlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUZldGNoZXJcIik7XG4gICAgfSxcbiAgICByZXNldEZldGNoZXIoKSB7XG4gICAgICB0aHJvdyBtc2coXCJyZXNldEZldGNoZXJcIik7XG4gICAgfSxcbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZGlzcG9zZVwiKTtcbiAgICB9LFxuICAgIGdldEJsb2NrZXIoKSB7XG4gICAgICByZXR1cm4gSURMRV9CTE9DS0VSO1xuICAgIH0sXG4gICAgZGVsZXRlQmxvY2tlcigpIHtcbiAgICAgIHRocm93IG1zZyhcImRlbGV0ZUJsb2NrZXJcIik7XG4gICAgfSxcbiAgICBwYXRjaFJvdXRlcygpIHtcbiAgICAgIHRocm93IG1zZyhcInBhdGNoUm91dGVzXCIpO1xuICAgIH0sXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBfaW50ZXJuYWxTZXRSb3V0ZXMoKSB7XG4gICAgICB0aHJvdyBtc2coXCJfaW50ZXJuYWxTZXRSb3V0ZXNcIik7XG4gICAgfSxcbiAgICBfaW50ZXJuYWxTZXRTdGF0ZURvTm90VXNlT3JZb3VXaWxsQnJlYWtZb3VyQXBwKCkge1xuICAgICAgdGhyb3cgbXNnKFwiX2ludGVybmFsU2V0U3RhdGVEb05vdFVzZU9yWW91V2lsbEJyZWFrWW91ckFwcFwiKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xufVxuZnVuY3Rpb24gZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgbGV0IGhyZWYgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICBocmVmID0gaHJlZi5yZXBsYWNlKC8gJC8sIFwiJTIwXCIpO1xuICBsZXQgZW5jb2RlZCA9IEFCU09MVVRFX1VSTF9SRUdFWDMudGVzdChocmVmKSA/IG5ldyBVUkwoaHJlZikgOiBuZXcgVVJMKGhyZWYsIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogZW5jb2RlZC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IGVuY29kZWQuc2VhcmNoLFxuICAgIGhhc2g6IGVuY29kZWQuaGFzaFxuICB9O1xufVxudmFyIEFCU09MVVRFX1VSTF9SRUdFWDMgPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG52YXIgRVNDQVBFX0xPT0tVUDIgPSB7XG4gIFwiJlwiOiBcIlxcXFx1MDAyNlwiLFxuICBcIj5cIjogXCJcXFxcdTAwM2VcIixcbiAgXCI8XCI6IFwiXFxcXHUwMDNjXCIsXG4gIFwiXFx1MjAyOFwiOiBcIlxcXFx1MjAyOFwiLFxuICBcIlxcdTIwMjlcIjogXCJcXFxcdTIwMjlcIlxufTtcbnZhciBFU0NBUEVfUkVHRVgyID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcbmZ1bmN0aW9uIGh0bWxFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShFU0NBUEVfUkVHRVgyLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVAyW21hdGNoXSk7XG59XG5cbmV4cG9ydCB7XG4gIEFjdGlvbixcbiAgY3JlYXRlQnJvd3Nlckhpc3RvcnksXG4gIGludmFyaWFudCxcbiAgY3JlYXRlUGF0aCxcbiAgcGFyc2VQYXRoLFxuICBjcmVhdGVDb250ZXh0LFxuICBSb3V0ZXJDb250ZXh0UHJvdmlkZXIsXG4gIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsXG4gIG1hdGNoUm91dGVzLFxuICBnZW5lcmF0ZVBhdGgsXG4gIG1hdGNoUGF0aCxcbiAgc3RyaXBCYXNlbmFtZSxcbiAgcmVzb2x2ZVBhdGgsXG4gIGRhdGEsXG4gIHJlZGlyZWN0LFxuICByZWRpcmVjdERvY3VtZW50LFxuICByZXBsYWNlLFxuICBFcnJvclJlc3BvbnNlSW1wbCxcbiAgaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIElETEVfTkFWSUdBVElPTixcbiAgSURMRV9GRVRDSEVSLFxuICBJRExFX0JMT0NLRVIsXG4gIGNyZWF0ZVJvdXRlcixcbiAgY3JlYXRlU3RhdGljSGFuZGxlcixcbiAgZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcixcbiAgaXNEYXRhV2l0aFJlc3BvbnNlSW5pdCxcbiAgaXNSZXNwb25zZSxcbiAgaXNSZWRpcmVjdFN0YXR1c0NvZGUsXG4gIGlzUmVkaXJlY3RSZXNwb25zZSxcbiAgaXNNdXRhdGlvbk1ldGhvZCxcbiAgRGF0YVJvdXRlckNvbnRleHQsXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsXG4gIFJTQ1JvdXRlckNvbnRleHQsXG4gIFZpZXdUcmFuc2l0aW9uQ29udGV4dCxcbiAgRmV0Y2hlcnNDb250ZXh0LFxuICBBd2FpdENvbnRleHRQcm92aWRlcixcbiAgTmF2aWdhdGlvbkNvbnRleHQsXG4gIExvY2F0aW9uQ29udGV4dCxcbiAgUm91dGVDb250ZXh0LFxuICBFTkFCTEVfREVWX1dBUk5JTkdTLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlTWF0Y2gsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VPdXRsZXQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSb3V0ZXMsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VNYXRjaGVzLFxuICB1c2VMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZVJvdXRlRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUJsb2NrZXIsXG4gIHdhcm5PbmNlLFxuICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllcyxcbiAgY3JlYXRlTWVtb3J5Um91dGVyLFxuICBVTlNUQUJMRV9UcmFuc2l0aW9uRW5hYmxlZFJvdXRlclByb3ZpZGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXMsXG4gIEF3YWl0LFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgcmVuZGVyTWF0Y2hlcyxcbiAgV2l0aENvbXBvbmVudFByb3BzLFxuICB3aXRoQ29tcG9uZW50UHJvcHMsXG4gIFdpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyxcbiAgd2l0aEh5ZHJhdGVGYWxsYmFja1Byb3BzLFxuICBXaXRoRXJyb3JCb3VuZGFyeVByb3BzLFxuICB3aXRoRXJyb3JCb3VuZGFyeVByb3BzLFxuICBjcmVhdGVTZWFyY2hQYXJhbXMsXG4gIGVzY2FwZUh0bWwsXG4gIGVuY29kZSxcbiAgY3JlYXRlUmVxdWVzdEluaXQsXG4gIFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wsXG4gIFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVMsXG4gIE5PX0JPRFlfU1RBVFVTX0NPREVTLFxuICBTdHJlYW1UcmFuc2ZlcixcbiAgZ2V0VHVyYm9TdHJlYW1TaW5nbGVGZXRjaERhdGFTdHJhdGVneSxcbiAgZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3lJbXBsLFxuICBzdHJpcEluZGV4UGFyYW0sXG4gIHNpbmdsZUZldGNoVXJsLFxuICBkZWNvZGVWaWFUdXJib1N0cmVhbSxcbiAgUmVtaXhFcnJvckJvdW5kYXJ5LFxuICBjcmVhdGVTZXJ2ZXJSb3V0ZXMsXG4gIGNyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQsXG4gIG5vQWN0aW9uRGVmaW5lZEVycm9yLFxuICBjcmVhdGVDbGllbnRSb3V0ZXMsXG4gIHNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcixcbiAgZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbixcbiAgdXNlRm9nT0ZXYXJEaXNjb3ZlcnksXG4gIGdldE1hbmlmZXN0UGF0aCxcbiAgRnJhbWV3b3JrQ29udGV4dCxcbiAgQ1JJVElDQUxfQ1NTX0RBVEFfQVRUUklCVVRFLFxuICBMaW5rcyxcbiAgUHJlZmV0Y2hQYWdlTGlua3MsXG4gIE1ldGEsXG4gIHNldElzSHlkcmF0ZWQsXG4gIFNjcmlwdHMsXG4gIGNyZWF0ZUJyb3dzZXJSb3V0ZXIsXG4gIGNyZWF0ZUhhc2hSb3V0ZXIsXG4gIEJyb3dzZXJSb3V0ZXIsXG4gIEhhc2hSb3V0ZXIsXG4gIEhpc3RvcnlSb3V0ZXIsXG4gIExpbmssXG4gIE5hdkxpbmssXG4gIEZvcm0sXG4gIFNjcm9sbFJlc3RvcmF0aW9uLFxuICB1c2VMaW5rQ2xpY2tIYW5kbGVyLFxuICB1c2VTZWFyY2hQYXJhbXMsXG4gIHVzZVN1Ym1pdCxcbiAgdXNlRm9ybUFjdGlvbixcbiAgdXNlRmV0Y2hlcixcbiAgdXNlRmV0Y2hlcnMsXG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uLFxuICB1c2VCZWZvcmVVbmxvYWQsXG4gIHVzZVByb21wdCxcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZSxcbiAgU3RhdGljUm91dGVyLFxuICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgY3JlYXRlU3RhdGljSGFuZGxlcjIsXG4gIGNyZWF0ZVN0YXRpY1JvdXRlclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/chunk-NISHYRIK.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router/dist/development/dom-export.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/react-router/dist/development/dom-export.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HydratedRouter: () => (/* binding */ HydratedRouter),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider2)\n/* harmony export */ });\n/* harmony import */ var _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-65XJMMLO.mjs */ \"(ssr)/./node_modules/react-router/dist/development/chunk-65XJMMLO.mjs\");\n/* harmony import */ var _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-NISHYRIK.mjs */ \"(ssr)/./node_modules/react-router/dist/development/chunk-NISHYRIK.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/**\n * react-router v7.9.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ /* __next_internal_client_entry_do_not_use__ HydratedRouter,RouterProvider auto */ \n\n// lib/dom-export/dom-router-provider.tsx\n\n\nfunction RouterProvider2(props) {\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.RouterProvider, {\n        flushSync: react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync,\n        ...props\n    });\n}\n// lib/dom-export/hydrated-router.tsx\n\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n    if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n        if (window.__reactRouterManifest.sri === true) {\n            const importMap = document.querySelector(\"script[rr-importmap]\");\n            if (importMap?.textContent) {\n                try {\n                    window.__reactRouterManifest.sri = JSON.parse(importMap.textContent).integrity;\n                } catch (err) {\n                    console.error(\"Failed to parse import map\", err);\n                }\n            }\n        }\n        ssrInfo = {\n            context: window.__reactRouterContext,\n            manifest: window.__reactRouterManifest,\n            routeModules: window.__reactRouterRouteModules,\n            stateDecodingPromise: void 0,\n            router: void 0,\n            routerInitialized: false\n        };\n    }\n}\nfunction createHydratedRouter({ getContext }) {\n    initSsrInfo();\n    if (!ssrInfo) {\n        throw new Error(\"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\");\n    }\n    let localSsrInfo = ssrInfo;\n    if (!ssrInfo.stateDecodingPromise) {\n        let stream = ssrInfo.context.stream;\n        (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.invariant)(stream, \"No stream found for single fetch decoding\");\n        ssrInfo.context.stream = void 0;\n        ssrInfo.stateDecodingPromise = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.decodeViaTurboStream)(stream, window).then((value)=>{\n            ssrInfo.context.state = value.value;\n            localSsrInfo.stateDecodingPromise.value = true;\n        }).catch((e)=>{\n            localSsrInfo.stateDecodingPromise.error = e;\n        });\n    }\n    if (ssrInfo.stateDecodingPromise.error) {\n        throw ssrInfo.stateDecodingPromise.error;\n    }\n    if (!ssrInfo.stateDecodingPromise.value) {\n        throw ssrInfo.stateDecodingPromise;\n    }\n    let routes = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.createClientRoutes)(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.ssr, ssrInfo.context.isSpaMode);\n    let hydrationData = void 0;\n    if (ssrInfo.context.isSpaMode) {\n        let { loaderData } = ssrInfo.context.state;\n        if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n            hydrationData = {\n                loaderData: {\n                    root: loaderData.root\n                }\n            };\n        }\n    } else {\n        hydrationData = (0,_chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_3__.getHydrationData)({\n            state: ssrInfo.context.state,\n            routes,\n            getRouteInfo: (routeId)=>({\n                    clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n                    hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n                    hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n                }),\n            location: window.location,\n            basename: window.__reactRouterContext?.basename,\n            isSpaMode: ssrInfo.context.isSpaMode\n        });\n        if (hydrationData && hydrationData.errors) {\n            hydrationData.errors = (0,_chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_3__.deserializeErrors)(hydrationData.errors);\n        }\n    }\n    let router2 = (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        routes,\n        history: (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)(),\n        basename: ssrInfo.context.basename,\n        getContext,\n        hydrationData,\n        hydrationRouteProperties: _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.hydrationRouteProperties,\n        mapRouteProperties: _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.mapRouteProperties,\n        future: {\n            middleware: ssrInfo.context.future.v8_middleware\n        },\n        dataStrategy: (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.getTurboStreamSingleFetchDataStrategy)(()=>router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.basename),\n        patchRoutesOnNavigation: (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.getPatchRoutesOnNavigationFunction)(ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode, ssrInfo.context.basename)\n    });\n    ssrInfo.router = router2;\n    if (router2.state.initialized) {\n        ssrInfo.routerInitialized = true;\n        router2.initialize();\n    }\n    router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.createClientRoutesWithHMRRevalidationOptOut;\n    window.__reactRouterDataRouter = router2;\n    return router2;\n}\nfunction HydratedRouter(props) {\n    if (!router) {\n        router = createHydratedRouter({\n            getContext: props.getContext\n        });\n    }\n    let [criticalCss, setCriticalCss] = react__WEBPACK_IMPORTED_MODULE_0__.useState( true ? ssrInfo?.context.criticalCss : 0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (true) {\n            setCriticalCss(void 0);\n        }\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if ( true && criticalCss === void 0) {\n            document.querySelectorAll(`[${_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach((element)=>element.remove());\n        }\n    }, [\n        criticalCss\n    ]);\n    let [location, setLocation] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state.location);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n            ssrInfo.routerInitialized = true;\n            ssrInfo.router.initialize();\n        }\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        if (ssrInfo && ssrInfo.router) {\n            return ssrInfo.router.subscribe((newState)=>{\n                if (newState.location !== location) {\n                    setLocation(newState.location);\n                }\n            });\n        }\n    }, [\n        location\n    ]);\n    (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.invariant)(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n    (0,_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.useFogOFWarDiscovery)(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode);\n    return(// This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.FrameworkContext.Provider, {\n        value: {\n            manifest: ssrInfo.manifest,\n            routeModules: ssrInfo.routeModules,\n            future: ssrInfo.context.future,\n            criticalCss,\n            ssr: ssrInfo.context.ssr,\n            isSpaMode: ssrInfo.context.isSpaMode,\n            routeDiscovery: ssrInfo.context.routeDiscovery\n        }\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_2__.RemixErrorBoundary, {\n        location\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouterProvider2, {\n        router,\n        unstable_onError: props.unstable_onError\n    }))), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null)));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvZG9tLWV4cG9ydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLHNGQUs2QjtBQWlCQTtBQUU5Qix5Q0FBeUM7QUFDVjtBQUNPO0FBQ3RDLFNBQVNtQixnQkFBZ0JDLEtBQUs7SUFDNUIsT0FBTyxhQUFhLGlCQUFHSCxnREFBbUIsQ0FBQ1osK0RBQWNBLEVBQUU7UUFBRWlCLFdBQVdKLGdEQUFrQjtRQUFFLEdBQUdFLEtBQUs7SUFBQztBQUN2RztBQUVBLHFDQUFxQztBQUNMO0FBQ2hDLElBQUlJLFVBQVU7QUFDZCxJQUFJQyxTQUFTO0FBQ2IsU0FBU0M7SUFDUCxJQUFJLENBQUNGLFdBQVdHLE9BQU9DLG9CQUFvQixJQUFJRCxPQUFPRSxxQkFBcUIsSUFBSUYsT0FBT0cseUJBQXlCLEVBQUU7UUFDL0csSUFBSUgsT0FBT0UscUJBQXFCLENBQUNFLEdBQUcsS0FBSyxNQUFNO1lBQzdDLE1BQU1DLFlBQVlDLFNBQVNDLGFBQWEsQ0FBQztZQUN6QyxJQUFJRixXQUFXRyxhQUFhO2dCQUMxQixJQUFJO29CQUNGUixPQUFPRSxxQkFBcUIsQ0FBQ0UsR0FBRyxHQUFHSyxLQUFLQyxLQUFLLENBQzNDTCxVQUFVRyxXQUFXLEVBQ3JCRyxTQUFTO2dCQUNiLEVBQUUsT0FBT0MsS0FBSztvQkFDWkMsUUFBUUMsS0FBSyxDQUFDLDhCQUE4QkY7Z0JBQzlDO1lBQ0Y7UUFDRjtRQUNBZixVQUFVO1lBQ1JrQixTQUFTZixPQUFPQyxvQkFBb0I7WUFDcENlLFVBQVVoQixPQUFPRSxxQkFBcUI7WUFDdENlLGNBQWNqQixPQUFPRyx5QkFBeUI7WUFDOUNlLHNCQUFzQixLQUFLO1lBQzNCcEIsUUFBUSxLQUFLO1lBQ2JxQixtQkFBbUI7UUFDckI7SUFDRjtBQUNGO0FBQ0EsU0FBU0MscUJBQXFCLEVBQzVCQyxVQUFVLEVBQ1g7SUFDQ3RCO0lBQ0EsSUFBSSxDQUFD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QyxRQUFRa0IsT0FBTyxDQUFDZ0IsR0FBRztZQUN4QkMsV0FBV25DLFFBQVFrQixPQUFPLENBQUNpQixTQUFTO1lBQ3BDb0IsZ0JBQWdCdkQsUUFBUWtCLE9BQU8sQ0FBQ3FDLGNBQWM7UUFDaEQ7SUFDRixHQUNBLGFBQWEsaUJBQUd4RCxnREFBb0IsQ0FBQ25CLG1FQUFrQkEsRUFBRTtRQUFFaUU7SUFBUyxHQUFHLGFBQWEsaUJBQUc5QyxnREFBb0IsQ0FDekdKLGlCQUNBO1FBQ0VNO1FBQ0EyRSxrQkFBa0JoRixNQUFNZ0YsZ0JBQWdCO0lBQzFDLE1BRUQsYUFBYSxpQkFBRzdFLGdEQUFvQixDQUFDQSwyQ0FBZSxFQUFFO0FBRTdEO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZS1jby9ldGhvcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZGlzdC9kZXZlbG9wbWVudC9kb20tZXhwb3J0Lm1qcz8wYTRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3Qtcm91dGVyIHY3LjkuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBjbGllbnRcIjtcbmltcG9ydCB7XG4gIGRlc2VyaWFsaXplRXJyb3JzLFxuICBnZXRIeWRyYXRpb25EYXRhXG59IGZyb20gXCIuL2NodW5rLTY1WEpNTUxPLm1qc1wiO1xuaW1wb3J0IHtcbiAgQ1JJVElDQUxfQ1NTX0RBVEFfQVRUUklCVVRFLFxuICBGcmFtZXdvcmtDb250ZXh0LFxuICBSZW1peEVycm9yQm91bmRhcnksXG4gIFJvdXRlclByb3ZpZGVyLFxuICBjcmVhdGVCcm93c2VySGlzdG9yeSxcbiAgY3JlYXRlQ2xpZW50Um91dGVzLFxuICBjcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0LFxuICBjcmVhdGVSb3V0ZXIsXG4gIGRlY29kZVZpYVR1cmJvU3RyZWFtLFxuICBnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uLFxuICBnZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5LFxuICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gIGludmFyaWFudCxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICB1c2VGb2dPRldhckRpc2NvdmVyeVxufSBmcm9tIFwiLi9jaHVuay1OSVNIWVJJSy5tanNcIjtcblxuLy8gbGliL2RvbS1leHBvcnQvZG9tLXJvdXRlci1wcm92aWRlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIyKHByb3BzKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXJQcm92aWRlciwgeyBmbHVzaFN5bmM6IFJlYWN0RE9NLmZsdXNoU3luYywgLi4ucHJvcHMgfSk7XG59XG5cbi8vIGxpYi9kb20tZXhwb3J0L2h5ZHJhdGVkLXJvdXRlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbnZhciBzc3JJbmZvID0gbnVsbDtcbnZhciByb3V0ZXIgPSBudWxsO1xuZnVuY3Rpb24gaW5pdFNzckluZm8oKSB7XG4gIGlmICghc3NySW5mbyAmJiB3aW5kb3cuX19yZWFjdFJvdXRlckNvbnRleHQgJiYgd2luZG93Ll9fcmVhY3RSb3V0ZXJNYW5pZmVzdCAmJiB3aW5kb3cuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcykge1xuICAgIGlmICh3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0LnNyaSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgaW1wb3J0TWFwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInNjcmlwdFtyci1pbXBvcnRtYXBdXCIpO1xuICAgICAgaWYgKGltcG9ydE1hcD8udGV4dENvbnRlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0LnNyaSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICBpbXBvcnRNYXAudGV4dENvbnRlbnRcbiAgICAgICAgICApLmludGVncml0eTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBpbXBvcnQgbWFwXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3NySW5mbyA9IHtcbiAgICAgIGNvbnRleHQ6IHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dCxcbiAgICAgIG1hbmlmZXN0OiB3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzOiB3aW5kb3cuX19yZWFjdFJvdXRlclJvdXRlTW9kdWxlcyxcbiAgICAgIHN0YXRlRGVjb2RpbmdQcm9taXNlOiB2b2lkIDAsXG4gICAgICByb3V0ZXI6IHZvaWQgMCxcbiAgICAgIHJvdXRlckluaXRpYWxpemVkOiBmYWxzZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGVkUm91dGVyKHtcbiAgZ2V0Q29udGV4dFxufSkge1xuICBpbml0U3NySW5mbygpO1xuICBpZiAoIXNzckluZm8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBtdXN0IGJlIHVzaW5nIHRoZSBTU1IgZmVhdHVyZXMgb2YgUmVhY3QgUm91dGVyIGluIG9yZGVyIHRvIHNraXAgcGFzc2luZyBhIGByb3V0ZXJgIHByb3AgdG8gYDxSb3V0ZXJQcm92aWRlcj5gXCJcbiAgICApO1xuICB9XG4gIGxldCBsb2NhbFNzckluZm8gPSBzc3JJbmZvO1xuICBpZiAoIXNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UpIHtcbiAgICBsZXQgc3RyZWFtID0gc3NySW5mby5jb250ZXh0LnN0cmVhbTtcbiAgICBpbnZhcmlhbnQoc3RyZWFtLCBcIk5vIHN0cmVhbSBmb3VuZCBmb3Igc2luZ2xlIGZldGNoIGRlY29kaW5nXCIpO1xuICAgIHNzckluZm8uY29udGV4dC5zdHJlYW0gPSB2b2lkIDA7XG4gICAgc3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZSA9IGRlY29kZVZpYVR1cmJvU3RyZWFtKHN0cmVhbSwgd2luZG93KS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgc3NySW5mby5jb250ZXh0LnN0YXRlID0gdmFsdWUudmFsdWU7XG4gICAgICBsb2NhbFNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UudmFsdWUgPSB0cnVlO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBsb2NhbFNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UuZXJyb3IgPSBlO1xuICAgIH0pO1xuICB9XG4gIGlmIChzc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlLmVycm9yKSB7XG4gICAgdGhyb3cgc3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZS5lcnJvcjtcbiAgfVxuICBpZiAoIXNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UudmFsdWUpIHtcbiAgICB0aHJvdyBzc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlO1xuICB9XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVDbGllbnRSb3V0ZXMoXG4gICAgc3NySW5mby5tYW5pZmVzdC5yb3V0ZXMsXG4gICAgc3NySW5mby5yb3V0ZU1vZHVsZXMsXG4gICAgc3NySW5mby5jb250ZXh0LnN0YXRlLFxuICAgIHNzckluZm8uY29udGV4dC5zc3IsXG4gICAgc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZVxuICApO1xuICBsZXQgaHlkcmF0aW9uRGF0YSA9IHZvaWQgMDtcbiAgaWYgKHNzckluZm8uY29udGV4dC5pc1NwYU1vZGUpIHtcbiAgICBsZXQgeyBsb2FkZXJEYXRhIH0gPSBzc3JJbmZvLmNvbnRleHQuc3RhdGU7XG4gICAgaWYgKHNzckluZm8ubWFuaWZlc3Qucm91dGVzLnJvb3Q/Lmhhc0xvYWRlciAmJiBsb2FkZXJEYXRhICYmIFwicm9vdFwiIGluIGxvYWRlckRhdGEpIHtcbiAgICAgIGh5ZHJhdGlvbkRhdGEgPSB7XG4gICAgICAgIGxvYWRlckRhdGE6IHtcbiAgICAgICAgICByb290OiBsb2FkZXJEYXRhLnJvb3RcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaHlkcmF0aW9uRGF0YSA9IGdldEh5ZHJhdGlvbkRhdGEoe1xuICAgICAgc3RhdGU6IHNzckluZm8uY29udGV4dC5zdGF0ZSxcbiAgICAgIHJvdXRlcyxcbiAgICAgIGdldFJvdXRlSW5mbzogKHJvdXRlSWQpID0+ICh7XG4gICAgICAgIGNsaWVudExvYWRlcjogc3NySW5mby5yb3V0ZU1vZHVsZXNbcm91dGVJZF0/LmNsaWVudExvYWRlcixcbiAgICAgICAgaGFzTG9hZGVyOiBzc3JJbmZvLm1hbmlmZXN0LnJvdXRlc1tyb3V0ZUlkXT8uaGFzTG9hZGVyID09PSB0cnVlLFxuICAgICAgICBoYXNIeWRyYXRlRmFsbGJhY2s6IHNzckluZm8ucm91dGVNb2R1bGVzW3JvdXRlSWRdPy5IeWRyYXRlRmFsbGJhY2sgIT0gbnVsbFxuICAgICAgfSksXG4gICAgICBsb2NhdGlvbjogd2luZG93LmxvY2F0aW9uLFxuICAgICAgYmFzZW5hbWU6IHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dD8uYmFzZW5hbWUsXG4gICAgICBpc1NwYU1vZGU6IHNzckluZm8uY29udGV4dC5pc1NwYU1vZGVcbiAgICB9KTtcbiAgICBpZiAoaHlkcmF0aW9uRGF0YSAmJiBoeWRyYXRpb25EYXRhLmVycm9ycykge1xuICAgICAgaHlkcmF0aW9uRGF0YS5lcnJvcnMgPSBkZXNlcmlhbGl6ZUVycm9ycyhoeWRyYXRpb25EYXRhLmVycm9ycyk7XG4gICAgfVxuICB9XG4gIGxldCByb3V0ZXIyID0gY3JlYXRlUm91dGVyKHtcbiAgICByb3V0ZXMsXG4gICAgaGlzdG9yeTogY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSxcbiAgICBiYXNlbmFtZTogc3NySW5mby5jb250ZXh0LmJhc2VuYW1lLFxuICAgIGdldENvbnRleHQsXG4gICAgaHlkcmF0aW9uRGF0YSxcbiAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIGZ1dHVyZToge1xuICAgICAgbWlkZGxld2FyZTogc3NySW5mby5jb250ZXh0LmZ1dHVyZS52OF9taWRkbGV3YXJlXG4gICAgfSxcbiAgICBkYXRhU3RyYXRlZ3k6IGdldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3koXG4gICAgICAoKSA9PiByb3V0ZXIyLFxuICAgICAgc3NySW5mby5tYW5pZmVzdCxcbiAgICAgIHNzckluZm8ucm91dGVNb2R1bGVzLFxuICAgICAgc3NySW5mby5jb250ZXh0LnNzcixcbiAgICAgIHNzckluZm8uY29udGV4dC5iYXNlbmFtZVxuICAgICksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IGdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24oXG4gICAgICBzc3JJbmZvLm1hbmlmZXN0LFxuICAgICAgc3NySW5mby5yb3V0ZU1vZHVsZXMsXG4gICAgICBzc3JJbmZvLmNvbnRleHQuc3NyLFxuICAgICAgc3NySW5mby5jb250ZXh0LnJvdXRlRGlzY292ZXJ5LFxuICAgICAgc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZSxcbiAgICAgIHNzckluZm8uY29udGV4dC5iYXNlbmFtZVxuICAgIClcbiAgfSk7XG4gIHNzckluZm8ucm91dGVyID0gcm91dGVyMjtcbiAgaWYgKHJvdXRlcjIuc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JJbmZvLnJvdXRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICByb3V0ZXIyLmluaXRpYWxpemUoKTtcbiAgfVxuICByb3V0ZXIyLmNyZWF0ZVJvdXRlc0ZvckhNUiA9IC8qIHNwYWNlciBzbyB0cy1pZ25vcmUgZG9lcyBub3QgYWZmZWN0IHRoZSByaWdodCBoYW5kIG9mIHRoZSBhc3NpZ25tZW50ICovXG4gIGNyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQ7XG4gIHdpbmRvdy5fX3JlYWN0Um91dGVyRGF0YVJvdXRlciA9IHJvdXRlcjI7XG4gIHJldHVybiByb3V0ZXIyO1xufVxuZnVuY3Rpb24gSHlkcmF0ZWRSb3V0ZXIocHJvcHMpIHtcbiAgaWYgKCFyb3V0ZXIpIHtcbiAgICByb3V0ZXIgPSBjcmVhdGVIeWRyYXRlZFJvdXRlcih7XG4gICAgICBnZXRDb250ZXh0OiBwcm9wcy5nZXRDb250ZXh0XG4gICAgfSk7XG4gIH1cbiAgbGV0IFtjcml0aWNhbENzcywgc2V0Q3JpdGljYWxDc3NdID0gUmVhY3QyLnVzZVN0YXRlKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgPyBzc3JJbmZvPy5jb250ZXh0LmNyaXRpY2FsQ3NzIDogdm9pZCAwXG4gICk7XG4gIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBzZXRDcml0aWNhbENzcyh2b2lkIDApO1xuICAgIH1cbiAgfSwgW10pO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiBjcml0aWNhbENzcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbJHtDUklUSUNBTF9DU1NfREFUQV9BVFRSSUJVVEV9XWApLmZvckVhY2goKGVsZW1lbnQpID0+IGVsZW1lbnQucmVtb3ZlKCkpO1xuICAgIH1cbiAgfSwgW2NyaXRpY2FsQ3NzXSk7XG4gIGxldCBbbG9jYXRpb24sIHNldExvY2F0aW9uXSA9IFJlYWN0Mi51c2VTdGF0ZShyb3V0ZXIuc3RhdGUubG9jYXRpb24pO1xuICBSZWFjdDIudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3NySW5mbyAmJiBzc3JJbmZvLnJvdXRlciAmJiAhc3NySW5mby5yb3V0ZXJJbml0aWFsaXplZCkge1xuICAgICAgc3NySW5mby5yb3V0ZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBzc3JJbmZvLnJvdXRlci5pbml0aWFsaXplKCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIFJlYWN0Mi51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzc3JJbmZvICYmIHNzckluZm8ucm91dGVyKSB7XG4gICAgICByZXR1cm4gc3NySW5mby5yb3V0ZXIuc3Vic2NyaWJlKChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICBpZiAobmV3U3RhdGUubG9jYXRpb24gIT09IGxvY2F0aW9uKSB7XG4gICAgICAgICAgc2V0TG9jYXRpb24obmV3U3RhdGUubG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtsb2NhdGlvbl0pO1xuICBpbnZhcmlhbnQoc3NySW5mbywgXCJzc3JJbmZvIHVuYXZhaWxhYmxlIGZvciBIeWRyYXRlZFJvdXRlclwiKTtcbiAgdXNlRm9nT0ZXYXJEaXNjb3ZlcnkoXG4gICAgcm91dGVyLFxuICAgIHNzckluZm8ubWFuaWZlc3QsXG4gICAgc3NySW5mby5yb3V0ZU1vZHVsZXMsXG4gICAgc3NySW5mby5jb250ZXh0LnNzcixcbiAgICBzc3JJbmZvLmNvbnRleHQucm91dGVEaXNjb3ZlcnksXG4gICAgc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZVxuICApO1xuICByZXR1cm4gKFxuICAgIC8vIFRoaXMgZnJhZ21lbnQgaXMgaW1wb3J0YW50IHRvIGVuc3VyZSB3ZSBtYXRjaCB0aGUgPFNlcnZlclJvdXRlcj4gSlNYXG4gICAgLy8gc3RydWN0dXJlIHNvIHRoYXQgdXNlSWQgdmFsdWVzIGh5ZHJhdGUgY29ycmVjdGx5XG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgRnJhbWV3b3JrQ29udGV4dC5Qcm92aWRlcixcbiAgICAgIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBtYW5pZmVzdDogc3NySW5mby5tYW5pZmVzdCxcbiAgICAgICAgICByb3V0ZU1vZHVsZXM6IHNzckluZm8ucm91dGVNb2R1bGVzLFxuICAgICAgICAgIGZ1dHVyZTogc3NySW5mby5jb250ZXh0LmZ1dHVyZSxcbiAgICAgICAgICBjcml0aWNhbENzcyxcbiAgICAgICAgICBzc3I6IHNzckluZm8uY29udGV4dC5zc3IsXG4gICAgICAgICAgaXNTcGFNb2RlOiBzc3JJbmZvLmNvbnRleHQuaXNTcGFNb2RlLFxuICAgICAgICAgIHJvdXRlRGlzY292ZXJ5OiBzc3JJbmZvLmNvbnRleHQucm91dGVEaXNjb3ZlcnlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZW1peEVycm9yQm91bmRhcnksIHsgbG9jYXRpb24gfSwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgICBSb3V0ZXJQcm92aWRlcjIsXG4gICAgICAgIHtcbiAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgdW5zdGFibGVfb25FcnJvcjogcHJvcHMudW5zdGFibGVfb25FcnJvclxuICAgICAgICB9XG4gICAgICApKVxuICAgICksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZWFjdDIuRnJhZ21lbnQsIG51bGwpKVxuICApO1xufVxuZXhwb3J0IHtcbiAgSHlkcmF0ZWRSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyMiBhcyBSb3V0ZXJQcm92aWRlclxufTtcbiJdLCJuYW1lcyI6WyJkZXNlcmlhbGl6ZUVycm9ycyIsImdldEh5ZHJhdGlvbkRhdGEiLCJDUklUSUNBTF9DU1NfREFUQV9BVFRSSUJVVEUiLCJGcmFtZXdvcmtDb250ZXh0IiwiUmVtaXhFcnJvckJvdW5kYXJ5IiwiUm91dGVyUHJvdmlkZXIiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsImNyZWF0ZUNsaWVudFJvdXRlcyIsImNyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQiLCJjcmVhdGVSb3V0ZXIiLCJkZWNvZGVWaWFUdXJib1N0cmVhbSIsImdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24iLCJnZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5IiwiaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzIiwiaW52YXJpYW50IiwibWFwUm91dGVQcm9wZXJ0aWVzIiwidXNlRm9nT0ZXYXJEaXNjb3ZlcnkiLCJSZWFjdCIsIlJlYWN0RE9NIiwiUm91dGVyUHJvdmlkZXIyIiwicHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiZmx1c2hTeW5jIiwiUmVhY3QyIiwic3NySW5mbyIsInJvdXRlciIsImluaXRTc3JJbmZvIiwid2luZG93IiwiX19yZWFjdFJvdXRlckNvbnRleHQiLCJfX3JlYWN0Um91dGVyTWFuaWZlc3QiLCJfX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzIiwic3JpIiwiaW1wb3J0TWFwIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJKU09OIiwicGFyc2UiLCJpbnRlZ3JpdHkiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJjb250ZXh0IiwibWFuaWZlc3QiLCJyb3V0ZU1vZHVsZXMiLCJzdGF0ZURlY29kaW5nUHJvbWlzZSIsInJvdXRlckluaXRpYWxpemVkIiwiY3JlYXRlSHlkcmF0ZWRSb3V0ZXIiLCJnZXRDb250ZXh0IiwiRXJyb3IiLCJsb2NhbFNzckluZm8iLCJzdHJlYW0iLCJ0aGVuIiwidmFsdWUiLCJzdGF0ZSIsImNhdGNoIiwiZSIsInJvdXRlcyIsInNzciIsImlzU3BhTW9kZSIsImh5ZHJhdGlvbkRhdGEiLCJsb2FkZXJEYXRhIiwicm9vdCIsImhhc0xvYWRlciIsImdldFJvdXRlSW5mbyIsInJvdXRlSWQiLCJjbGllbnRMb2FkZXIiLCJoYXNIeWRyYXRlRmFsbGJhY2siLCJIeWRyYXRlRmFsbGJhY2siLCJsb2NhdGlvbiIsImJhc2VuYW1lIiwiZXJyb3JzIiwicm91dGVyMiIsImhpc3RvcnkiLCJmdXR1cmUiLCJtaWRkbGV3YXJlIiwidjhfbWlkZGxld2FyZSIsImRhdGFTdHJhdGVneSIsInBhdGNoUm91dGVzT25OYXZpZ2F0aW9uIiwicm91dGVEaXNjb3ZlcnkiLCJpbml0aWFsaXplZCIsImluaXRpYWxpemUiLCJjcmVhdGVSb3V0ZXNGb3JITVIiLCJfX3JlYWN0Um91dGVyRGF0YVJvdXRlciIsIkh5ZHJhdGVkUm91dGVyIiwiY3JpdGljYWxDc3MiLCJzZXRDcml0aWNhbENzcyIsInVzZVN0YXRlIiwicHJvY2VzcyIsInVzZUVmZmVjdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWxlbWVudCIsInJlbW92ZSIsInNldExvY2F0aW9uIiwidXNlTGF5b3V0RWZmZWN0Iiwic3Vic2NyaWJlIiwibmV3U3RhdGUiLCJGcmFnbWVudCIsIlByb3ZpZGVyIiwidW5zdGFibGVfb25FcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/dom-export.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router/dist/development/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/react-router/dist/development/index.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Await: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Await),\n/* harmony export */   BrowserRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.BrowserRouter),\n/* harmony export */   Form: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Form),\n/* harmony export */   HashRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.HashRouter),\n/* harmony export */   IDLE_BLOCKER: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.IDLE_BLOCKER),\n/* harmony export */   IDLE_FETCHER: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.IDLE_NAVIGATION),\n/* harmony export */   Link: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Link),\n/* harmony export */   Links: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Links),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.MemoryRouter),\n/* harmony export */   Meta: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Meta),\n/* harmony export */   NavLink: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Outlet),\n/* harmony export */   PrefetchPageLinks: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.PrefetchPageLinks),\n/* harmony export */   Route: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Router),\n/* harmony export */   RouterContextProvider: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.RouterContextProvider),\n/* harmony export */   RouterProvider: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Routes),\n/* harmony export */   Scripts: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.Scripts),\n/* harmony export */   ScrollRestoration: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.ScrollRestoration),\n/* harmony export */   ServerRouter: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.ServerRouter),\n/* harmony export */   StaticRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.StaticRouter),\n/* harmony export */   StaticRouterProvider: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.StaticRouterProvider),\n/* harmony export */   UNSAFE_AwaitContextProvider: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.AwaitContextProvider),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.DataRouterStateContext),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.ErrorResponseImpl),\n/* harmony export */   UNSAFE_FetchersContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.FetchersContext),\n/* harmony export */   UNSAFE_FrameworkContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.FrameworkContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.NavigationContext),\n/* harmony export */   UNSAFE_RSCDefaultRootErrorBoundary: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.RSCDefaultRootErrorBoundary),\n/* harmony export */   UNSAFE_RemixErrorBoundary: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.RemixErrorBoundary),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.RouteContext),\n/* harmony export */   UNSAFE_ServerMode: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.ServerMode),\n/* harmony export */   UNSAFE_SingleFetchRedirectSymbol: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.SingleFetchRedirectSymbol),\n/* harmony export */   UNSAFE_ViewTransitionContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewTransitionContext),\n/* harmony export */   UNSAFE_WithComponentProps: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.WithComponentProps),\n/* harmony export */   UNSAFE_WithErrorBoundaryProps: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.WithErrorBoundaryProps),\n/* harmony export */   UNSAFE_WithHydrateFallbackProps: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.WithHydrateFallbackProps),\n/* harmony export */   UNSAFE_createBrowserHistory: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createBrowserHistory),\n/* harmony export */   UNSAFE_createClientRoutes: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createClientRoutes),\n/* harmony export */   UNSAFE_createClientRoutesWithHMRRevalidationOptOut: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createClientRoutesWithHMRRevalidationOptOut),\n/* harmony export */   UNSAFE_createRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createRouter),\n/* harmony export */   UNSAFE_decodeViaTurboStream: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.decodeViaTurboStream),\n/* harmony export */   UNSAFE_deserializeErrors: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.deserializeErrors),\n/* harmony export */   UNSAFE_getHydrationData: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.getHydrationData),\n/* harmony export */   UNSAFE_getPatchRoutesOnNavigationFunction: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.getPatchRoutesOnNavigationFunction),\n/* harmony export */   UNSAFE_getTurboStreamSingleFetchDataStrategy: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.getTurboStreamSingleFetchDataStrategy),\n/* harmony export */   UNSAFE_hydrationRouteProperties: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.hydrationRouteProperties),\n/* harmony export */   UNSAFE_invariant: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.invariant),\n/* harmony export */   UNSAFE_mapRouteProperties: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.mapRouteProperties),\n/* harmony export */   UNSAFE_shouldHydrateRouteLoader: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.shouldHydrateRouteLoader),\n/* harmony export */   UNSAFE_useFogOFWarDiscovery: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useFogOFWarDiscovery),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useScrollRestoration),\n/* harmony export */   UNSAFE_withComponentProps: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.withComponentProps),\n/* harmony export */   UNSAFE_withErrorBoundaryProps: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.withErrorBoundaryProps),\n/* harmony export */   UNSAFE_withHydrateFallbackProps: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.withHydrateFallbackProps),\n/* harmony export */   createBrowserRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createBrowserRouter),\n/* harmony export */   createContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createContext),\n/* harmony export */   createCookie: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.createCookie),\n/* harmony export */   createCookieSessionStorage: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.createCookieSessionStorage),\n/* harmony export */   createHashRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createMemoryRouter),\n/* harmony export */   createMemorySessionStorage: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.createMemorySessionStorage),\n/* harmony export */   createPath: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createPath),\n/* harmony export */   createRequestHandler: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.createRequestHandler),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createRoutesFromElements),\n/* harmony export */   createRoutesStub: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.createRoutesStub),\n/* harmony export */   createSearchParams: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createSearchParams),\n/* harmony export */   createSession: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.createSession),\n/* harmony export */   createSessionStorage: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.createSessionStorage),\n/* harmony export */   createStaticHandler: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createStaticHandler2),\n/* harmony export */   createStaticRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.createStaticRouter),\n/* harmony export */   data: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.data),\n/* harmony export */   generatePath: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.generatePath),\n/* harmony export */   href: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.href),\n/* harmony export */   isCookie: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.isCookie),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.isRouteErrorResponse),\n/* harmony export */   isSession: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.isSession),\n/* harmony export */   matchPath: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.renderMatches),\n/* harmony export */   replace: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.replace),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.HistoryRouter),\n/* harmony export */   unstable_RSCHydratedRouter: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.RSCHydratedRouter),\n/* harmony export */   unstable_RSCStaticRouter: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.RSCStaticRouter),\n/* harmony export */   unstable_createCallServer: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.createCallServer),\n/* harmony export */   unstable_getRSCStream: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.getRSCStream),\n/* harmony export */   unstable_routeRSCServerRequest: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.routeRSCServerRequest),\n/* harmony export */   unstable_setDevServerHooks: () => (/* reexport safe */ _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__.setDevServerHooks),\n/* harmony export */   unstable_usePrompt: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.usePrompt),\n/* harmony export */   useActionData: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useBlocker),\n/* harmony export */   useFetcher: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useFetcher),\n/* harmony export */   useFetchers: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useFetchers),\n/* harmony export */   useFormAction: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useSearchParams),\n/* harmony export */   useSubmit: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useSubmit),\n/* harmony export */   useViewTransitionState: () => (/* reexport safe */ _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__.useViewTransitionState)\n/* harmony export */ });\n/* harmony import */ var _chunk_65XJMMLO_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-65XJMMLO.mjs */ \"(ssr)/./node_modules/react-router/dist/development/chunk-65XJMMLO.mjs\");\n/* harmony import */ var _chunk_NISHYRIK_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-NISHYRIK.mjs */ \"(ssr)/./node_modules/react-router/dist/development/chunk-NISHYRIK.mjs\");\n/**\n * react-router v7.9.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ /* __next_internal_client_entry_do_not_use__ Await,BrowserRouter,Form,HashRouter,IDLE_BLOCKER,IDLE_FETCHER,IDLE_NAVIGATION,Link,Links,MemoryRouter,Meta,NavLink,Navigate,NavigationType,Outlet,PrefetchPageLinks,Route,Router,RouterContextProvider,RouterProvider,Routes,Scripts,ScrollRestoration,ServerRouter,StaticRouter,StaticRouterProvider,UNSAFE_AwaitContextProvider,UNSAFE_DataRouterContext,UNSAFE_DataRouterStateContext,UNSAFE_ErrorResponseImpl,UNSAFE_FetchersContext,UNSAFE_FrameworkContext,UNSAFE_LocationContext,UNSAFE_NavigationContext,UNSAFE_RSCDefaultRootErrorBoundary,UNSAFE_RemixErrorBoundary,UNSAFE_RouteContext,UNSAFE_ServerMode,UNSAFE_SingleFetchRedirectSymbol,UNSAFE_ViewTransitionContext,UNSAFE_WithComponentProps,UNSAFE_WithErrorBoundaryProps,UNSAFE_WithHydrateFallbackProps,UNSAFE_createBrowserHistory,UNSAFE_createClientRoutes,UNSAFE_createClientRoutesWithHMRRevalidationOptOut,UNSAFE_createRouter,UNSAFE_decodeViaTurboStream,UNSAFE_deserializeErrors,UNSAFE_getHydrationData,UNSAFE_getPatchRoutesOnNavigationFunction,UNSAFE_getTurboStreamSingleFetchDataStrategy,UNSAFE_hydrationRouteProperties,UNSAFE_invariant,UNSAFE_mapRouteProperties,UNSAFE_shouldHydrateRouteLoader,UNSAFE_useFogOFWarDiscovery,UNSAFE_useScrollRestoration,UNSAFE_withComponentProps,UNSAFE_withErrorBoundaryProps,UNSAFE_withHydrateFallbackProps,createBrowserRouter,createContext,createCookie,createCookieSessionStorage,createHashRouter,createMemoryRouter,createMemorySessionStorage,createPath,createRequestHandler,createRoutesFromChildren,createRoutesFromElements,createRoutesStub,createSearchParams,createSession,createSessionStorage,createStaticHandler,createStaticRouter,data,generatePath,href,isCookie,isRouteErrorResponse,isSession,matchPath,matchRoutes,parsePath,redirect,redirectDocument,renderMatches,replace,resolvePath,unstable_HistoryRouter,unstable_RSCHydratedRouter,unstable_RSCStaticRouter,unstable_createCallServer,unstable_getRSCStream,unstable_routeRSCServerRequest,unstable_setDevServerHooks,unstable_usePrompt,useActionData,useAsyncError,useAsyncValue,useBeforeUnload,useBlocker,useFetcher,useFetchers,useFormAction,useHref,useInRouterContext,useLinkClickHandler,useLoaderData,useLocation,useMatch,useMatches,useNavigate,useNavigation,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRevalidator,useRouteError,useRouteLoaderData,useRoutes,useSearchParams,useSubmit,useViewTransitionState auto */ \n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLDYzRUF3QjZCO0FBOEdBO0FBbUk1QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BlLWNvL2V0aG9zLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2RldmVsb3BtZW50L2luZGV4Lm1qcz82MWEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3Qtcm91dGVyIHY3LjkuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBjbGllbnRcIjtcbmltcG9ydCB7XG4gIFJTQ0RlZmF1bHRSb290RXJyb3JCb3VuZGFyeSxcbiAgUlNDSHlkcmF0ZWRSb3V0ZXIsXG4gIFJTQ1N0YXRpY1JvdXRlcixcbiAgU2VydmVyTW9kZSxcbiAgU2VydmVyUm91dGVyLFxuICBjcmVhdGVDYWxsU2VydmVyLFxuICBjcmVhdGVDb29raWUsXG4gIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlUmVxdWVzdEhhbmRsZXIsXG4gIGNyZWF0ZVJvdXRlc1N0dWIsXG4gIGNyZWF0ZVNlc3Npb24sXG4gIGNyZWF0ZVNlc3Npb25TdG9yYWdlLFxuICBkZXNlcmlhbGl6ZUVycm9ycyxcbiAgZ2V0SHlkcmF0aW9uRGF0YSxcbiAgZ2V0UlNDU3RyZWFtLFxuICBocmVmLFxuICBpc0Nvb2tpZSxcbiAgaXNTZXNzaW9uLFxuICByb3V0ZVJTQ1NlcnZlclJlcXVlc3QsXG4gIHNldERldlNlcnZlckhvb2tzXG59IGZyb20gXCIuL2NodW5rLTY1WEpNTUxPLm1qc1wiO1xuaW1wb3J0IHtcbiAgQWN0aW9uLFxuICBBd2FpdCxcbiAgQXdhaXRDb250ZXh0UHJvdmlkZXIsXG4gIEJyb3dzZXJSb3V0ZXIsXG4gIERhdGFSb3V0ZXJDb250ZXh0LFxuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBFcnJvclJlc3BvbnNlSW1wbCxcbiAgRmV0Y2hlcnNDb250ZXh0LFxuICBGb3JtLFxuICBGcmFtZXdvcmtDb250ZXh0LFxuICBIYXNoUm91dGVyLFxuICBIaXN0b3J5Um91dGVyLFxuICBJRExFX0JMT0NLRVIsXG4gIElETEVfRkVUQ0hFUixcbiAgSURMRV9OQVZJR0FUSU9OLFxuICBMaW5rLFxuICBMaW5rcyxcbiAgTG9jYXRpb25Db250ZXh0LFxuICBNZW1vcnlSb3V0ZXIsXG4gIE1ldGEsXG4gIE5hdkxpbmssXG4gIE5hdmlnYXRlLFxuICBOYXZpZ2F0aW9uQ29udGV4dCxcbiAgT3V0bGV0LFxuICBQcmVmZXRjaFBhZ2VMaW5rcyxcbiAgUmVtaXhFcnJvckJvdW5kYXJ5LFxuICBSb3V0ZSxcbiAgUm91dGVDb250ZXh0LFxuICBSb3V0ZXIsXG4gIFJvdXRlckNvbnRleHRQcm92aWRlcixcbiAgUm91dGVyUHJvdmlkZXIsXG4gIFJvdXRlcyxcbiAgU2NyaXB0cyxcbiAgU2Nyb2xsUmVzdG9yYXRpb24sXG4gIFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wsXG4gIFN0YXRpY1JvdXRlcixcbiAgU3RhdGljUm91dGVyUHJvdmlkZXIsXG4gIFZpZXdUcmFuc2l0aW9uQ29udGV4dCxcbiAgV2l0aENvbXBvbmVudFByb3BzLFxuICBXaXRoRXJyb3JCb3VuZGFyeVByb3BzLFxuICBXaXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHMsXG4gIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBjcmVhdGVCcm93c2VyUm91dGVyLFxuICBjcmVhdGVDbGllbnRSb3V0ZXMsXG4gIGNyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQsXG4gIGNyZWF0ZUNvbnRleHQsXG4gIGNyZWF0ZUhhc2hSb3V0ZXIsXG4gIGNyZWF0ZU1lbW9yeVJvdXRlcixcbiAgY3JlYXRlUGF0aCxcbiAgY3JlYXRlUm91dGVyLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgY3JlYXRlU2VhcmNoUGFyYW1zLFxuICBjcmVhdGVTdGF0aWNIYW5kbGVyMiBhcyBjcmVhdGVTdGF0aWNIYW5kbGVyLFxuICBjcmVhdGVTdGF0aWNSb3V0ZXIsXG4gIGRhdGEsXG4gIGRlY29kZVZpYVR1cmJvU3RyZWFtLFxuICBnZW5lcmF0ZVBhdGgsXG4gIGdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24sXG4gIGdldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3ksXG4gIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllcyxcbiAgaW52YXJpYW50LFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZSxcbiAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICBtYXRjaFBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGgsXG4gIHJlZGlyZWN0LFxuICByZWRpcmVjdERvY3VtZW50LFxuICByZW5kZXJNYXRjaGVzLFxuICByZXBsYWNlLFxuICByZXNvbHZlUGF0aCxcbiAgc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyLFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VCZWZvcmVVbmxvYWQsXG4gIHVzZUJsb2NrZXIsXG4gIHVzZUZldGNoZXIsXG4gIHVzZUZldGNoZXJzLFxuICB1c2VGb2dPRldhckRpc2NvdmVyeSxcbiAgdXNlRm9ybUFjdGlvbixcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMaW5rQ2xpY2tIYW5kbGVyLFxuICB1c2VMb2FkZXJEYXRhLFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VPdXRsZXRDb250ZXh0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVByb21wdCxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXMsXG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uLFxuICB1c2VTZWFyY2hQYXJhbXMsXG4gIHVzZVN1Ym1pdCxcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZSxcbiAgd2l0aENvbXBvbmVudFByb3BzLFxuICB3aXRoRXJyb3JCb3VuZGFyeVByb3BzLFxuICB3aXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHNcbn0gZnJvbSBcIi4vY2h1bmstTklTSFlSSUsubWpzXCI7XG5leHBvcnQge1xuICBBd2FpdCxcbiAgQnJvd3NlclJvdXRlcixcbiAgRm9ybSxcbiAgSGFzaFJvdXRlcixcbiAgSURMRV9CTE9DS0VSLFxuICBJRExFX0ZFVENIRVIsXG4gIElETEVfTkFWSUdBVElPTixcbiAgTGluayxcbiAgTGlua3MsXG4gIE1lbW9yeVJvdXRlcixcbiAgTWV0YSxcbiAgTmF2TGluayxcbiAgTmF2aWdhdGUsXG4gIEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSxcbiAgT3V0bGV0LFxuICBQcmVmZXRjaFBhZ2VMaW5rcyxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVyQ29udGV4dFByb3ZpZGVyLFxuICBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzLFxuICBTY3JpcHRzLFxuICBTY3JvbGxSZXN0b3JhdGlvbixcbiAgU2VydmVyUm91dGVyLFxuICBTdGF0aWNSb3V0ZXIsXG4gIFN0YXRpY1JvdXRlclByb3ZpZGVyLFxuICBBd2FpdENvbnRleHRQcm92aWRlciBhcyBVTlNBRkVfQXdhaXRDb250ZXh0UHJvdmlkZXIsXG4gIERhdGFSb3V0ZXJDb250ZXh0IGFzIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCxcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgRXJyb3JSZXNwb25zZUltcGwgYXMgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsLFxuICBGZXRjaGVyc0NvbnRleHQgYXMgVU5TQUZFX0ZldGNoZXJzQ29udGV4dCxcbiAgRnJhbWV3b3JrQ29udGV4dCBhcyBVTlNBRkVfRnJhbWV3b3JrQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgUlNDRGVmYXVsdFJvb3RFcnJvckJvdW5kYXJ5IGFzIFVOU0FGRV9SU0NEZWZhdWx0Um9vdEVycm9yQm91bmRhcnksXG4gIFJlbWl4RXJyb3JCb3VuZGFyeSBhcyBVTlNBRkVfUmVtaXhFcnJvckJvdW5kYXJ5LFxuICBSb3V0ZUNvbnRleHQgYXMgVU5TQUZFX1JvdXRlQ29udGV4dCxcbiAgU2VydmVyTW9kZSBhcyBVTlNBRkVfU2VydmVyTW9kZSxcbiAgU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCBhcyBVTlNBRkVfU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCxcbiAgVmlld1RyYW5zaXRpb25Db250ZXh0IGFzIFVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQsXG4gIFdpdGhDb21wb25lbnRQcm9wcyBhcyBVTlNBRkVfV2l0aENvbXBvbmVudFByb3BzLFxuICBXaXRoRXJyb3JCb3VuZGFyeVByb3BzIGFzIFVOU0FGRV9XaXRoRXJyb3JCb3VuZGFyeVByb3BzLFxuICBXaXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHMgYXMgVU5TQUZFX1dpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyxcbiAgY3JlYXRlQnJvd3Nlckhpc3RvcnkgYXMgVU5TQUZFX2NyZWF0ZUJyb3dzZXJIaXN0b3J5LFxuICBjcmVhdGVDbGllbnRSb3V0ZXMgYXMgVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlcyxcbiAgY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCBhcyBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCxcbiAgY3JlYXRlUm91dGVyIGFzIFVOU0FGRV9jcmVhdGVSb3V0ZXIsXG4gIGRlY29kZVZpYVR1cmJvU3RyZWFtIGFzIFVOU0FGRV9kZWNvZGVWaWFUdXJib1N0cmVhbSxcbiAgZGVzZXJpYWxpemVFcnJvcnMgYXMgVU5TQUZFX2Rlc2VyaWFsaXplRXJyb3JzLFxuICBnZXRIeWRyYXRpb25EYXRhIGFzIFVOU0FGRV9nZXRIeWRyYXRpb25EYXRhLFxuICBnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uIGFzIFVOU0FGRV9nZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uLFxuICBnZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5IGFzIFVOU0FGRV9nZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5LFxuICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMgYXMgVU5TQUZFX2h5ZHJhdGlvblJvdXRlUHJvcGVydGllcyxcbiAgaW52YXJpYW50IGFzIFVOU0FGRV9pbnZhcmlhbnQsXG4gIG1hcFJvdXRlUHJvcGVydGllcyBhcyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICBzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIgYXMgVU5TQUZFX3Nob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcixcbiAgdXNlRm9nT0ZXYXJEaXNjb3ZlcnkgYXMgVU5TQUZFX3VzZUZvZ09GV2FyRGlzY292ZXJ5LFxuICB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24sXG4gIHdpdGhDb21wb25lbnRQcm9wcyBhcyBVTlNBRkVfd2l0aENvbXBvbmVudFByb3BzLFxuICB3aXRoRXJyb3JCb3VuZGFyeVByb3BzIGFzIFVOU0FGRV93aXRoRXJyb3JCb3VuZGFyeVByb3BzLFxuICB3aXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHMgYXMgVU5TQUZFX3dpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyxcbiAgY3JlYXRlQnJvd3NlclJvdXRlcixcbiAgY3JlYXRlQ29udGV4dCxcbiAgY3JlYXRlQ29va2llLFxuICBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlSGFzaFJvdXRlcixcbiAgY3JlYXRlTWVtb3J5Um91dGVyLFxuICBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlUGF0aCxcbiAgY3JlYXRlUmVxdWVzdEhhbmRsZXIsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLFxuICBjcmVhdGVSb3V0ZXNTdHViLFxuICBjcmVhdGVTZWFyY2hQYXJhbXMsXG4gIGNyZWF0ZVNlc3Npb24sXG4gIGNyZWF0ZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVTdGF0aWNIYW5kbGVyLFxuICBjcmVhdGVTdGF0aWNSb3V0ZXIsXG4gIGRhdGEsXG4gIGdlbmVyYXRlUGF0aCxcbiAgaHJlZixcbiAgaXNDb29raWUsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBpc1Nlc3Npb24sXG4gIG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aCxcbiAgcmVkaXJlY3QsXG4gIHJlZGlyZWN0RG9jdW1lbnQsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlcGxhY2UsXG4gIHJlc29sdmVQYXRoLFxuICBIaXN0b3J5Um91dGVyIGFzIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIsXG4gIFJTQ0h5ZHJhdGVkUm91dGVyIGFzIHVuc3RhYmxlX1JTQ0h5ZHJhdGVkUm91dGVyLFxuICBSU0NTdGF0aWNSb3V0ZXIgYXMgdW5zdGFibGVfUlNDU3RhdGljUm91dGVyLFxuICBjcmVhdGVDYWxsU2VydmVyIGFzIHVuc3RhYmxlX2NyZWF0ZUNhbGxTZXJ2ZXIsXG4gIGdldFJTQ1N0cmVhbSBhcyB1bnN0YWJsZV9nZXRSU0NTdHJlYW0sXG4gIHJvdXRlUlNDU2VydmVyUmVxdWVzdCBhcyB1bnN0YWJsZV9yb3V0ZVJTQ1NlcnZlclJlcXVlc3QsXG4gIHNldERldlNlcnZlckhvb2tzIGFzIHVuc3RhYmxlX3NldERldlNlcnZlckhvb2tzLFxuICB1c2VQcm9tcHQgYXMgdW5zdGFibGVfdXNlUHJvbXB0LFxuICB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlLFxuICB1c2VCZWZvcmVVbmxvYWQsXG4gIHVzZUJsb2NrZXIsXG4gIHVzZUZldGNoZXIsXG4gIHVzZUZldGNoZXJzLFxuICB1c2VGb3JtQWN0aW9uLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxpbmtDbGlja0hhbmRsZXIsXG4gIHVzZUxvYWRlckRhdGEsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTWF0Y2hlcyxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZU91dGxldENvbnRleHQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcixcbiAgdXNlUm91dGVFcnJvcixcbiAgdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXMsXG4gIHVzZVNlYXJjaFBhcmFtcyxcbiAgdXNlU3VibWl0LFxuICB1c2VWaWV3VHJhbnNpdGlvblN0YXRlXG59O1xuIl0sIm5hbWVzIjpbIlJTQ0RlZmF1bHRSb290RXJyb3JCb3VuZGFyeSIsIlJTQ0h5ZHJhdGVkUm91dGVyIiwiUlNDU3RhdGljUm91dGVyIiwiU2VydmVyTW9kZSIsIlNlcnZlclJvdXRlciIsImNyZWF0ZUNhbGxTZXJ2ZXIiLCJjcmVhdGVDb29raWUiLCJjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSIsImNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlIiwiY3JlYXRlUmVxdWVzdEhhbmRsZXIiLCJjcmVhdGVSb3V0ZXNTdHViIiwiY3JlYXRlU2Vzc2lvbiIsImNyZWF0ZVNlc3Npb25TdG9yYWdlIiwiZGVzZXJpYWxpemVFcnJvcnMiLCJnZXRIeWRyYXRpb25EYXRhIiwiZ2V0UlNDU3RyZWFtIiwiaHJlZiIsImlzQ29va2llIiwiaXNTZXNzaW9uIiwicm91dGVSU0NTZXJ2ZXJSZXF1ZXN0Iiwic2V0RGV2U2VydmVySG9va3MiLCJBY3Rpb24iLCJBd2FpdCIsIkF3YWl0Q29udGV4dFByb3ZpZGVyIiwiQnJvd3NlclJvdXRlciIsIkRhdGFSb3V0ZXJDb250ZXh0IiwiRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIkVycm9yUmVzcG9uc2VJbXBsIiwiRmV0Y2hlcnNDb250ZXh0IiwiRm9ybSIsIkZyYW1ld29ya0NvbnRleHQiLCJIYXNoUm91dGVyIiwiSGlzdG9yeVJvdXRlciIsIklETEVfQkxPQ0tFUiIsIklETEVfRkVUQ0hFUiIsIklETEVfTkFWSUdBVElPTiIsIkxpbmsiLCJMaW5rcyIsIkxvY2F0aW9uQ29udGV4dCIsIk1lbW9yeVJvdXRlciIsIk1ldGEiLCJOYXZMaW5rIiwiTmF2aWdhdGUiLCJOYXZpZ2F0aW9uQ29udGV4dCIsIk91dGxldCIsIlByZWZldGNoUGFnZUxpbmtzIiwiUmVtaXhFcnJvckJvdW5kYXJ5IiwiUm91dGUiLCJSb3V0ZUNvbnRleHQiLCJSb3V0ZXIiLCJSb3V0ZXJDb250ZXh0UHJvdmlkZXIiLCJSb3V0ZXJQcm92aWRlciIsIlJvdXRlcyIsIlNjcmlwdHMiLCJTY3JvbGxSZXN0b3JhdGlvbiIsIlNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wiLCJTdGF0aWNSb3V0ZXIiLCJTdGF0aWNSb3V0ZXJQcm92aWRlciIsIlZpZXdUcmFuc2l0aW9uQ29udGV4dCIsIldpdGhDb21wb25lbnRQcm9wcyIsIldpdGhFcnJvckJvdW5kYXJ5UHJvcHMiLCJXaXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHMiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsImNyZWF0ZUJyb3dzZXJSb3V0ZXIiLCJjcmVhdGVDbGllbnRSb3V0ZXMiLCJjcmVhdGVDbGllbnRSb3V0ZXNXaXRoSE1SUmV2YWxpZGF0aW9uT3B0T3V0IiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZUhhc2hSb3V0ZXIiLCJjcmVhdGVNZW1vcnlSb3V0ZXIiLCJjcmVhdGVQYXRoIiwiY3JlYXRlUm91dGVyIiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzIiwiY3JlYXRlU2VhcmNoUGFyYW1zIiwiY3JlYXRlU3RhdGljSGFuZGxlcjIiLCJjcmVhdGVTdGF0aWNIYW5kbGVyIiwiY3JlYXRlU3RhdGljUm91dGVyIiwiZGF0YSIsImRlY29kZVZpYVR1cmJvU3RyZWFtIiwiZ2VuZXJhdGVQYXRoIiwiZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbiIsImdldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kiLCJoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMiLCJpbnZhcmlhbnQiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsIm1hcFJvdXRlUHJvcGVydGllcyIsIm1hdGNoUGF0aCIsIm1hdGNoUm91dGVzIiwicGFyc2VQYXRoIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVuZGVyTWF0Y2hlcyIsInJlcGxhY2UiLCJyZXNvbHZlUGF0aCIsInNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlciIsInVzZUFjdGlvbkRhdGEiLCJ1c2VBc3luY0Vycm9yIiwidXNlQXN5bmNWYWx1ZSIsInVzZUJlZm9yZVVubG9hZCIsInVzZUJsb2NrZXIiLCJ1c2VGZXRjaGVyIiwidXNlRmV0Y2hlcnMiLCJ1c2VGb2dPRldhckRpc2NvdmVyeSIsInVzZUZvcm1BY3Rpb24iLCJ1c2VIcmVmIiwidXNlSW5Sb3V0ZXJDb250ZXh0IiwidXNlTGlua0NsaWNrSGFuZGxlciIsInVzZUxvYWRlckRhdGEiLCJ1c2VMb2NhdGlvbiIsInVzZU1hdGNoIiwidXNlTWF0Y2hlcyIsInVzZU5hdmlnYXRlIiwidXNlTmF2aWdhdGlvbiIsInVzZU5hdmlnYXRpb25UeXBlIiwidXNlT3V0bGV0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZVBhcmFtcyIsInVzZVByb21wdCIsInVzZVJlc29sdmVkUGF0aCIsInVzZVJldmFsaWRhdG9yIiwidXNlUm91dGVFcnJvciIsInVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZVJvdXRlcyIsInVzZVNjcm9sbFJlc3RvcmF0aW9uIiwidXNlU2VhcmNoUGFyYW1zIiwidXNlU3VibWl0IiwidXNlVmlld1RyYW5zaXRpb25TdGF0ZSIsIndpdGhDb21wb25lbnRQcm9wcyIsIndpdGhFcnJvckJvdW5kYXJ5UHJvcHMiLCJ3aXRoSHlkcmF0ZUZhbGxiYWNrUHJvcHMiLCJOYXZpZ2F0aW9uVHlwZSIsIlVOU0FGRV9Bd2FpdENvbnRleHRQcm92aWRlciIsIlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCIsIlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIiwiVU5TQUZFX0ZldGNoZXJzQ29udGV4dCIsIlVOU0FGRV9GcmFtZXdvcmtDb250ZXh0IiwiVU5TQUZFX0xvY2F0aW9uQ29udGV4dCIsIlVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCIsIlVOU0FGRV9SU0NEZWZhdWx0Um9vdEVycm9yQm91bmRhcnkiLCJVTlNBRkVfUmVtaXhFcnJvckJvdW5kYXJ5IiwiVU5TQUZFX1JvdXRlQ29udGV4dCIsIlVOU0FGRV9TZXJ2ZXJNb2RlIiwiVU5TQUZFX1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wiLCJVTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0IiwiVU5TQUZFX1dpdGhDb21wb25lbnRQcm9wcyIsIlVOU0FGRV9XaXRoRXJyb3JCb3VuZGFyeVByb3BzIiwiVU5TQUZFX1dpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyIsIlVOU0FGRV9jcmVhdGVCcm93c2VySGlzdG9yeSIsIlVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXMiLCJVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCIsIlVOU0FGRV9jcmVhdGVSb3V0ZXIiLCJVTlNBRkVfZGVjb2RlVmlhVHVyYm9TdHJlYW0iLCJVTlNBRkVfZGVzZXJpYWxpemVFcnJvcnMiLCJVTlNBRkVfZ2V0SHlkcmF0aW9uRGF0YSIsIlVOU0FGRV9nZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uIiwiVU5TQUZFX2dldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kiLCJVTlNBRkVfaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzIiwiVU5TQUZFX2ludmFyaWFudCIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyIiwiVU5TQUZFX3VzZUZvZ09GV2FyRGlzY292ZXJ5IiwiVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uIiwiVU5TQUZFX3dpdGhDb21wb25lbnRQcm9wcyIsIlVOU0FGRV93aXRoRXJyb3JCb3VuZGFyeVByb3BzIiwiVU5TQUZFX3dpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyIsInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXIiLCJ1bnN0YWJsZV9SU0NIeWRyYXRlZFJvdXRlciIsInVuc3RhYmxlX1JTQ1N0YXRpY1JvdXRlciIsInVuc3RhYmxlX2NyZWF0ZUNhbGxTZXJ2ZXIiLCJ1bnN0YWJsZV9nZXRSU0NTdHJlYW0iLCJ1bnN0YWJsZV9yb3V0ZVJTQ1NlcnZlclJlcXVlc3QiLCJ1bnN0YWJsZV9zZXREZXZTZXJ2ZXJIb29rcyIsInVuc3RhYmxlX3VzZVByb21wdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/index.mjs\n");

/***/ })

};
;